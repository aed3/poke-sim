#pragma once

/**
 * FILE ORDER
 * external/entt/config/macro.h
 * external/entt/config/version.h
 * external/entt/config/config.h
 * external/entt/container/fwd.hpp
 * external/entt/core/fwd.hpp
 * external/entt/core/type_traits.hpp
 * external/entt/core/compressed_pair.hpp
 * external/entt/core/iterator.hpp
 * external/entt/core/memory.hpp
 * external/entt/container/dense_map.hpp
 * external/entt/container/dense_set.hpp
 * external/entt/core/utility.hpp
 * external/entt/core/algorithm.hpp
 * external/entt/core/attribute.h
 * external/entt/core/hashed_string.hpp
 * external/entt/core/type_info.hpp
 * external/entt/core/any.hpp
 * external/entt/entity/fwd.hpp
 * external/entt/entity/entity.hpp
 * external/entt/entity/sparse_set.hpp
 * external/entt/entity/component.hpp
 * external/entt/entity/storage.hpp
 * external/entt/entity/group.hpp
 * external/entt/signal/fwd.hpp
 * external/entt/signal/delegate.hpp
 * external/entt/signal/sigh.hpp
 * external/entt/entity/mixin.hpp
 * external/entt/entity/view.hpp
 * external/entt/entity/registry.hpp
 * external/entt/locator/locator.hpp
 * external/entt/meta/context.hpp
 * external/entt/meta/adl_pointer.hpp
 * external/entt/meta/fwd.hpp
 * external/entt/core/enum.hpp
 * external/entt/meta/type_traits.hpp
 * external/entt/meta/node.hpp
 * external/entt/meta/range.hpp
 * external/entt/meta/meta.hpp
 * external/entt/meta/resolve.hpp
 * src/Types/Entity.hpp
 * src/Components/EntityHolders/Battle.hpp
 * src/Config/Config.hpp
 * src/Components/EntityHolders/BattleTree.hpp
 * src/Config/Require.hpp
 * external/entt/meta/policy.hpp
 * external/entt/meta/utility.hpp
 * external/entt/meta/factory.hpp
 * src/Utilities/AssertComponentsEqual.hpp
 * src/Types/Registry.hpp
 * src/Utilities/AssertComponentsEqual.cpp
 * external/entt/entity/handle.hpp
 * src/Types/Enums/PseudoWeather.hpp
 * src/Types/Enums/SideCondition.hpp
 * src/Types/Enums/Status.hpp
 * src/Types/Enums/Terrain.hpp
 * src/Types/Enums/Volatile.hpp
 * src/Types/Enums/Weather.hpp
 * src/Utilities/Variant.hpp
 * src/Types/Effect.hpp
 * src/Types/Enums/Move.hpp
 * src/Types/Enums/Stat.hpp
 * src/Types/Stats.hpp
 * src/AnalyzeEffect/Setup/AnalyzeEffectInputSetup.hpp
 * src/Types/Enums/Slot.hpp
 * src/Battle/Helpers/Helpers.hpp
 * src/Battle/Setup/StateSetupBase.hpp
 * src/Components/Boosts.hpp
 * src/Components/EVsIVs.hpp
 * src/Types/Enums/Type.hpp
 * src/Components/SpeciesTypes.hpp
 * src/Components/Stats.hpp
 * src/Types/Enums/Ability.hpp
 * src/Types/Enums/Gender.hpp
 * src/Types/Enums/Item.hpp
 * src/Types/Enums/Nature.hpp
 * src/Types/Enums/Species.hpp
 * src/Types/Enums/TypeEffectiveness.hpp
 * src/Types/Random.hpp
 * src/Utilities/TypeChart.hpp
 * src/Types/MechanicConstants.hpp
 * src/Utilities/MaxSizedVector.hpp
 * src/Types/State.hpp
 * src/Battle/Setup/PokemonStateSetup.hpp
 * src/Battle/Setup/BattleStateSetup.hpp
 * src/Battle/Setup/EnumToTag.hpp
 * src/Types/Move.hpp
 * src/Battle/Setup/MoveStateSetup.hpp
 * src/Types/Enums/PlayerSideId.hpp
 * src/Battle/Setup/SideStateSetup.hpp
 * src/CalcDamage/Setup/CalcDamageInputSetup.hpp
 * src/Components/EntityHolders/Current.hpp
 * src/Components/Tags/Current.hpp
 * src/Components/CalcDamage/Aliases.hpp
 * src/Components/Decisions.hpp
 * src/Components/EntityHolders/ActionQueue.hpp
 * src/Components/EntityHolders/Side.hpp
 * src/Components/EntityHolders/Sides.hpp
 * src/Components/Tags/PokemonTags.hpp
 * src/Components/Tags/SimulationTags.hpp
 * src/Components/EntityHolders/MoveEffect.hpp
 * src/Types/Enums/ActionOrder.hpp
 * src/Types/Enums/AddedTargets.hpp
 * src/Types/Enums/BattleFormat.hpp
 * src/Types/Enums/DamageRollKind.hpp
 * src/Types/Enums/GameMechanics.hpp
 * src/Types/Enums/MoveCategory.hpp
 * src/Types/Enums/MoveTarget.hpp
 * src/Types/Enums/StabBoostKind.hpp
 * src/Pokedex/Pokedex.hpp
 * src/Components/Tags/BattleTags.hpp
 * src/Components/Tags/Selection.hpp
 * src/Utilities/Tags.hpp
 * src/Utilities/RegistryLoop.hpp
 * src/Simulation/RegistryContainer.hpp
 * src/Simulation/SimulationOptions.hpp
 * src/Types/Damage.hpp
 * src/Types/Event.hpp
 * src/Simulation/Simulation.hpp
 * src/Components/AnalyzeEffect/Aliases.hpp
 * src/Components/AnalyzeEffect/AnalyzeEffectInputs.hpp
 * src/Components/EntityHolders/FoeSide.hpp
 * src/Components/EntityHolders/MoveSlots.hpp
 * src/Components/EntityHolders/Team.hpp
 * src/Components/ID.hpp
 * src/Components/Level.hpp
 * src/Components/Names/AbilityNames.hpp
 * src/Components/Names/GenderNames.hpp
 * src/Components/Names/ItemNames.hpp
 * src/Components/Names/MoveNames.hpp
 * src/Components/Names/NatureNames.hpp
 * src/Components/Names/PseudoWeatherNames.hpp
 * src/Components/Names/SideConditionNames.hpp
 * src/Components/Names/SpeciesNames.hpp
 * src/Components/Names/StatusNames.hpp
 * src/Components/Names/TerrainNames.hpp
 * src/Components/Names/VolatileNames.hpp
 * src/Components/Names/WeatherNames.hpp
 * src/Components/PP.hpp
 * src/Components/Probability.hpp
 * src/Components/RNGSeed.hpp
 * src/Components/Turn.hpp
 * src/Utilities/DebugChecks.hpp
 * src/Simulation/SimulationSetupDebugChecks.hpp
 * src/Simulation/SimulationSetup.cpp
 * src/Components/Damage.hpp
 * src/Components/SimulationResults.hpp
 * src/Simulation/SimulationResults.hpp
 * src/Simulation/SimulationResults.cpp
 * src/AnalyzeEffect/AnalyzeEffect.hpp
 * src/Battle/Pokemon/ManagePokemonState.hpp
 * src/CalcDamage/CalcDamage.hpp
 * src/Components/HitCount.hpp
 * src/SimulateTurn/SimulateTurn.hpp
 * src/Simulation/Simulation.cpp
 * src/Battle/Helpers/IntegerModify.hpp
 * src/Components/EntityHolders/ChoiceLock.hpp
 * src/Components/EventModifier.hpp
 * src/Components/Tags/ItemTags.hpp
 * src/Components/Tags/StatusTags.hpp
 * src/Pokedex/Abilities/Static.hpp
 * src/Pokedex/Effects/ChoiceLock.hpp
 * src/Pokedex/Items/AssaultVest.hpp
 * src/Pokedex/Items/BrightPowder.hpp
 * src/Pokedex/Items/ChoiceScarf.hpp
 * src/Pokedex/Items/ChoiceSpecs.hpp
 * src/Pokedex/Items/FocusSash.hpp
 * src/Pokedex/Items/LifeOrb.hpp
 * src/Simulation/RunEvent.hpp
 * src/Utilities/SelectForView.hpp
 * src/Simulation/RunEvent.cpp
 * src/Components/Accuracy.hpp
 * src/Components/RandomEventOutputs.hpp
 * src/Components/SimulateTurn/MoveHitStepTags.hpp
 * src/Components/Tags/MoveTags.hpp
 * src/Components/RandomEventInputs.hpp
 * src/SimulateTurn/RandomChance.hpp
 * src/Simulation/MoveHitSteps.hpp
 * src/Simulation/MoveHitSteps.cpp
 * src/Battle/Clone/Clone.hpp
 * src/Battle/ManageBattleState.hpp
 * src/CalcDamage/Helpers.hpp
 * src/Components/AddedTargets.hpp
 * src/Components/CloneFromCloneTo.hpp
 * src/Components/Names/SourceSlotName.hpp
 * src/Components/Names/TargetSlotName.hpp
 * src/Components/SimulateTurn/ActionNames.hpp
 * src/Components/SimulateTurn/ActionTags.hpp
 * src/Components/SimulateTurn/SimulateTurnInput.hpp
 * src/Components/SpeedSort.hpp
 * src/Components/Tags/TargetTags.hpp
 * src/SimulateTurn/ManageActionQueue.hpp
 * src/SimulateTurn/SimulateTurn.cpp
 * src/Components/CalcDamage/CriticalHit.hpp
 * src/Utilities/RNG.hpp
 * src/SimulateTurn/RandomChance.cpp
 * src/Components/SimulateTurn/SpeedTieIndexes.hpp
 * src/Components/SimulateTurn/TeamAction.hpp
 * src/SimulateTurn/ManageActionQueue.cpp
 * src/SimulateTurn/CalcDamageSpecifics.hpp
 * src/SimulateTurn/CalcDamageSpecifics.cpp
 * src/Components/Pokedex/Abilities.hpp
 * src/Components/Pokedex/BaseStats.hpp
 * src/Pokedex/Setup/DexDataSetup.hpp
 * src/Pokedex/Setup/SpeciesDexDataSetup.hpp
 * src/Pokedex/Setup/SpeciesDexDataSetup.cpp
 * src/Components/BasePower.hpp
 * src/Components/Chance.hpp
 * src/Components/Names/TypeNames.hpp
 * src/Components/Priority.hpp
 * src/Pokedex/Setup/MoveDexDataSetup.hpp
 * src/Pokedex/Setup/MoveDexDataSetup.cpp
 * src/Pokedex/Setup/ItemDexDataSetup.hpp
 * src/Pokedex/Setup/ItemDexDataSetup.cpp
 * src/Pokedex/Species/Ampharos.hpp
 * src/Pokedex/Species/Dragapult.hpp
 * src/Pokedex/Species/Empoleon.hpp
 * src/Pokedex/Species/Gardevoir.hpp
 * src/Pokedex/Species/Pangoro.hpp
 * src/Pokedex/Species/Ribombee.hpp
 * src/Pokedex/Setup/GetSpeciesBuild.cpp
 * src/Pokedex/Moves/FuryAttack.hpp
 * src/Pokedex/Moves/KnockOff.hpp
 * src/Pokedex/Moves/Moonblast.hpp
 * src/Pokedex/Moves/QuiverDance.hpp
 * src/Pokedex/Moves/Thunderbolt.hpp
 * src/Pokedex/Moves/WillOWisp.hpp
 * src/Pokedex/Setup/GetMoveBuild.cpp
 * src/Pokedex/Setup/GetItemBuild.cpp
 * src/Pokedex/Setup/AbilityDexDataSetup.hpp
 * src/Pokedex/Setup/GetAbilityBuild.cpp
 * src/Pokedex/Setup/AbilityDexDataSetup.cpp
 * src/Pokedex/Pokedex.cpp
 * src/Pokedex/Items/ItemEvents.cpp
 * src/Pokedex/Effects/EffectEvents.cpp
 * src/Pokedex/Abilities/AbilityEvents.cpp
 * src/CalcDamage/Setup/CalcDamageInputSetup.cpp
 * src/Battle/Pokemon/PokemonDataChecks.hpp
 * src/Components/PlayerSide.hpp
 * src/CalcDamage/CalcDamageDebugChecks.hpp
 * src/Components/CalcDamage/DamageCalcVariables.hpp
 * src/CalcDamage/CalcDamage.cpp
 * src/Battle/Setup/SideStateSetup.cpp
 * src/Components/Position.hpp
 * src/Components/Tags/AbilityTags.hpp
 * src/Components/Tags/NatureTags.hpp
 * src/Battle/Setup/PokemonStateSetup.cpp
 * src/Battle/Setup/MoveStateSetup.cpp
 * src/Battle/Setup/EnumToTag.cpp
 * src/Battle/Setup/BattleStateSetup.cpp
 * src/Components/EntityHolders/LastUsedMove.hpp
 * src/Components/Names/StatNames.hpp
 * src/Battle/Pokemon/ManagePokemonState.cpp
 * src/Battle/ManageBattleState.cpp
 * src/Battle/Helpers/Helpers.cpp
 * src/Components/EntityHolders/Pokemon.hpp
 * src/Battle/Clone/Clone.cpp
 * src/AnalyzeEffect/Setup/AnalyzeEffectInputSetup.cpp
 * src/AnalyzeEffect/AnalyzeEffectDebugChecks.hpp
 * src/Components/AnalyzeEffect/RemovedEffect.hpp
 * src/AnalyzeEffect/AnalyzeEffect.cpp
 * src/Components/Tags/TypeTags.hpp
 * src/Pokedex/Names.hpp
 * src/Utilities/LambdaToDelegate.hpp
 * src/PokeSim.hpp
 */


//////////////////// START OF external/entt/config/macro.h /////////////////////

#ifndef ENTT_CONFIG_MACRO_H
#define ENTT_CONFIG_MACRO_H

#define ENTT_STR(arg) #arg
#define ENTT_XSTR(arg) ENTT_STR(arg)

#endif

///////////////////// END OF external/entt/config/macro.h //////////////////////

/////////////////// START OF external/entt/config/version.h ////////////////////

#ifndef ENTT_CONFIG_VERSION_H
#define ENTT_CONFIG_VERSION_H


#define ENTT_VERSION_MAJOR 3
#define ENTT_VERSION_MINOR 12
#define ENTT_VERSION_PATCH 2

#define ENTT_VERSION \
    ENTT_XSTR(ENTT_VERSION_MAJOR) \
    "." ENTT_XSTR(ENTT_VERSION_MINOR) "." ENTT_XSTR(ENTT_VERSION_PATCH)

#endif

//////////////////// END OF external/entt/config/version.h /////////////////////

//////////////////// START OF external/entt/config/config.h ////////////////////

#ifndef ENTT_CONFIG_CONFIG_H
#define ENTT_CONFIG_CONFIG_H


#if defined(__cpp_exceptions) && !defined(ENTT_NOEXCEPTION)
#    define ENTT_CONSTEXPR
#    define ENTT_THROW throw
#    define ENTT_TRY try
#    define ENTT_CATCH catch(...)
#else
#    define ENTT_CONSTEXPR constexpr // use only with throwing functions (waiting for C++20)
#    define ENTT_THROW
#    define ENTT_TRY if(true)
#    define ENTT_CATCH if(false)
#endif

#ifdef ENTT_USE_ATOMIC
#    include <atomic>
#    define ENTT_MAYBE_ATOMIC(Type) std::atomic<Type>
#else
#    define ENTT_MAYBE_ATOMIC(Type) Type
#endif

#ifndef ENTT_ID_TYPE
#    include <cstdint>
#    define ENTT_ID_TYPE std::uint32_t
#endif

#ifndef ENTT_SPARSE_PAGE
#    define ENTT_SPARSE_PAGE 4096
#endif

#ifndef ENTT_PACKED_PAGE
#    define ENTT_PACKED_PAGE 1024
#endif

#ifdef ENTT_DISABLE_ASSERT
#    undef ENTT_ASSERT
#    define ENTT_ASSERT(condition, msg) (void(0))
#elif !defined ENTT_ASSERT
#    include <cassert>
#    define ENTT_ASSERT(condition, msg) assert(condition)
#endif

#ifdef ENTT_DISABLE_ASSERT
#    undef ENTT_ASSERT_CONSTEXPR
#    define ENTT_ASSERT_CONSTEXPR(condition, msg) (void(0))
#elif !defined ENTT_ASSERT_CONSTEXPR
#    define ENTT_ASSERT_CONSTEXPR(condition, msg) ENTT_ASSERT(condition, msg)
#endif

#define ENTT_FAIL(msg) ENTT_ASSERT(false, msg);

#ifdef ENTT_NO_ETO
#    define ENTT_ETO_TYPE(Type) void
#else
#    define ENTT_ETO_TYPE(Type) Type
#endif

#ifdef ENTT_STANDARD_CPP
#    define ENTT_NONSTD false
#else
#    define ENTT_NONSTD true
#    if defined __clang__ || defined __GNUC__
#        define ENTT_PRETTY_FUNCTION __PRETTY_FUNCTION__
#        define ENTT_PRETTY_FUNCTION_PREFIX '='
#        define ENTT_PRETTY_FUNCTION_SUFFIX ']'
#    elif defined _MSC_VER
#        define ENTT_PRETTY_FUNCTION __FUNCSIG__
#        define ENTT_PRETTY_FUNCTION_PREFIX '<'
#        define ENTT_PRETTY_FUNCTION_SUFFIX '>'
#    endif
#endif

#if defined _MSC_VER
#    pragma detect_mismatch("entt.version", ENTT_VERSION)
#    pragma detect_mismatch("entt.noexcept", ENTT_XSTR(ENTT_TRY))
#    pragma detect_mismatch("entt.id", ENTT_XSTR(ENTT_ID_TYPE))
#    pragma detect_mismatch("entt.nonstd", ENTT_XSTR(ENTT_NONSTD))
#endif

#endif

///////////////////// END OF external/entt/config/config.h /////////////////////

/////////////////// START OF external/entt/container/fwd.hpp ///////////////////

#ifndef ENTT_CONTAINER_FWD_HPP
#define ENTT_CONTAINER_FWD_HPP

#include <functional>
#include <memory>

namespace entt {

template<
    typename Key,
    typename Type,
    typename = std::hash<Key>,
    typename = std::equal_to<Key>,
    typename = std::allocator<std::pair<const Key, Type>>>
class dense_map;

template<
    typename Type,
    typename = std::hash<Type>,
    typename = std::equal_to<Type>,
    typename = std::allocator<Type>>
class dense_set;

} // namespace entt

#endif

//////////////////// END OF external/entt/container/fwd.hpp ////////////////////

///////////////////// START OF external/entt/core/fwd.hpp //////////////////////

#ifndef ENTT_CORE_FWD_HPP
#define ENTT_CORE_FWD_HPP

#include <cstddef>

namespace entt {

template<std::size_t Len = sizeof(double[2]), std::size_t = alignof(double[2])>
class basic_any;

/*! @brief Alias declaration for type identifiers. */
using id_type = ENTT_ID_TYPE;

/*! @brief Alias declaration for the most common use case. */
using any = basic_any<>;

} // namespace entt

#endif

////////////////////// END OF external/entt/core/fwd.hpp ///////////////////////

///////////////// START OF external/entt/core/type_traits.hpp //////////////////

#ifndef ENTT_CORE_TYPE_TRAITS_HPP
#define ENTT_CORE_TYPE_TRAITS_HPP

#include <cstddef>
#include <iterator>
#include <tuple>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @brief Utility class to disambiguate overloaded functions.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
struct choice_t
    // Unfortunately, doxygen cannot parse such a construct.
    : /*! @cond TURN_OFF_DOXYGEN */ choice_t<N - 1> /*! @endcond */
{};

/*! @copybrief choice_t */
template<>
struct choice_t<0> {};

/**
 * @brief Variable template for the choice trick.
 * @tparam N Number of choices available.
 */
template<std::size_t N>
inline constexpr choice_t<N> choice{};

/**
 * @brief Identity type trait.
 *
 * Useful to establish non-deduced contexts in template argument deduction
 * (waiting for C++20) or to provide types through function arguments.
 *
 * @tparam Type A type.
 */
template<typename Type>
struct type_identity {
    /*! @brief Identity type. */
    using type = Type;
};

/**
 * @brief Helper type.
 * @tparam Type A type.
 */
template<typename Type>
using type_identity_t = typename type_identity<Type>::type;

/**
 * @brief A type-only `sizeof` wrapper that returns 0 where `sizeof` complains.
 * @tparam Type The type of which to return the size.
 */
template<typename Type, typename = void>
struct size_of: std::integral_constant<std::size_t, 0u> {};

/*! @copydoc size_of */
template<typename Type>
struct size_of<Type, std::void_t<decltype(sizeof(Type))>>
    : std::integral_constant<std::size_t, sizeof(Type)> {};

/**
 * @brief Helper variable template.
 * @tparam Type The type of which to return the size.
 */
template<typename Type>
inline constexpr std::size_t size_of_v = size_of<Type>::value;

/**
 * @brief Using declaration to be used to _repeat_ the same type a number of
 * times equal to the size of a given parameter pack.
 * @tparam Type A type to repeat.
 */
template<typename Type, typename>
using unpack_as_type = Type;

/**
 * @brief Helper variable template to be used to _repeat_ the same value a
 * number of times equal to the size of a given parameter pack.
 * @tparam Value A value to repeat.
 */
template<auto Value, typename>
inline constexpr auto unpack_as_value = Value;

/**
 * @brief Wraps a static constant.
 * @tparam Value A static constant.
 */
template<auto Value>
using integral_constant = std::integral_constant<decltype(Value), Value>;

/**
 * @brief Alias template to facilitate the creation of named values.
 * @tparam Value A constant value at least convertible to `id_type`.
 */
template<id_type Value>
using tag = integral_constant<Value>;

/**
 * @brief A class to use to push around lists of types, nothing more.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list {
    /*! @brief Type list type. */
    using type = type_list;
    /*! @brief Compile-time number of elements in the type list. */
    static constexpr auto size = sizeof...(Type);
};

/*! @brief Primary template isn't defined on purpose. */
template<std::size_t, typename>
struct type_list_element;

/**
 * @brief Provides compile-time indexed access to the types of a type list.
 * @tparam Index Index of the type to return.
 * @tparam First First type provided by the type list.
 * @tparam Other Other types provided by the type list.
 */
template<std::size_t Index, typename First, typename... Other>
struct type_list_element<Index, type_list<First, Other...>>
    : type_list_element<Index - 1u, type_list<Other...>> {};

/**
 * @brief Provides compile-time indexed access to the types of a type list.
 * @tparam First First type provided by the type list.
 * @tparam Other Other types provided by the type list.
 */
template<typename First, typename... Other>
struct type_list_element<0u, type_list<First, Other...>> {
    /*! @brief Searched type. */
    using type = First;
};

/**
 * @brief Helper type.
 * @tparam Index Index of the type to return.
 * @tparam List Type list to search into.
 */
template<std::size_t Index, typename List>
using type_list_element_t = typename type_list_element<Index, List>::type;

/*! @brief Primary template isn't defined on purpose. */
template<typename, typename>
struct type_list_index;

/**
 * @brief Provides compile-time type access to the types of a type list.
 * @tparam Type Type to look for and for which to return the index.
 * @tparam First First type provided by the type list.
 * @tparam Other Other types provided by the type list.
 */
template<typename Type, typename First, typename... Other>
struct type_list_index<Type, type_list<First, Other...>> {
    /*! @brief Unsigned integer type. */
    using value_type = std::size_t;
    /*! @brief Compile-time position of the given type in the sublist. */
    static constexpr value_type value = 1u + type_list_index<Type, type_list<Other...>>::value;
};

/**
 * @brief Provides compile-time type access to the types of a type list.
 * @tparam Type Type to look for and for which to return the index.
 * @tparam Other Other types provided by the type list.
 */
template<typename Type, typename... Other>
struct type_list_index<Type, type_list<Type, Other...>> {
    static_assert(type_list_index<Type, type_list<Other...>>::value == sizeof...(Other), "Non-unique type");
    /*! @brief Unsigned integer type. */
    using value_type = std::size_t;
    /*! @brief Compile-time position of the given type in the sublist. */
    static constexpr value_type value = 0u;
};

/**
 * @brief Provides compile-time type access to the types of a type list.
 * @tparam Type Type to look for and for which to return the index.
 */
template<typename Type>
struct type_list_index<Type, type_list<>> {
    /*! @brief Unsigned integer type. */
    using value_type = std::size_t;
    /*! @brief Compile-time position of the given type in the sublist. */
    static constexpr value_type value = 0u;
};

/**
 * @brief Helper variable template.
 * @tparam List Type list.
 * @tparam Type Type to look for and for which to return the index.
 */
template<typename Type, typename List>
inline constexpr std::size_t type_list_index_v = type_list_index<Type, List>::value;

/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the first type list.
 * @tparam Other Types provided by the second type list.
 * @return A type list composed by the types of both the type lists.
 */
template<typename... Type, typename... Other>
constexpr type_list<Type..., Other...> operator+(type_list<Type...>, type_list<Other...>) {
    return {};
}

/*! @brief Primary template isn't defined on purpose. */
template<typename...>
struct type_list_cat;

/*! @brief Concatenates multiple type lists. */
template<>
struct type_list_cat<> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<>;
};

/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the first type list.
 * @tparam Other Types provided by the second type list.
 * @tparam List Other type lists, if any.
 */
template<typename... Type, typename... Other, typename... List>
struct type_list_cat<type_list<Type...>, type_list<Other...>, List...> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = typename type_list_cat<type_list<Type..., Other...>, List...>::type;
};

/**
 * @brief Concatenates multiple type lists.
 * @tparam Type Types provided by the type list.
 */
template<typename... Type>
struct type_list_cat<type_list<Type...>> {
    /*! @brief A type list composed by the types of all the type lists. */
    using type = type_list<Type...>;
};

/**
 * @brief Helper type.
 * @tparam List Type lists to concatenate.
 */
template<typename... List>
using type_list_cat_t = typename type_list_cat<List...>::type;

/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct type_list_unique;

/**
 * @brief Removes duplicates types from a type list.
 * @tparam Type One of the types provided by the given type list.
 * @tparam Other The other types provided by the given type list.
 */
template<typename Type, typename... Other>
struct type_list_unique<type_list<Type, Other...>> {
    /*! @brief A type list without duplicate types. */
    using type = std::conditional_t<
        (std::is_same_v<Type, Other> || ...),
        typename type_list_unique<type_list<Other...>>::type,
        type_list_cat_t<type_list<Type>, typename type_list_unique<type_list<Other...>>::type>>;
};

/*! @brief Removes duplicates types from a type list. */
template<>
struct type_list_unique<type_list<>> {
    /*! @brief A type list without duplicate types. */
    using type = type_list<>;
};

/**
 * @brief Helper type.
 * @tparam Type A type list.
 */
template<typename Type>
using type_list_unique_t = typename type_list_unique<Type>::type;

/**
 * @brief Provides the member constant `value` to true if a type list contains a
 * given type, false otherwise.
 * @tparam List Type list.
 * @tparam Type Type to look for.
 */
template<typename List, typename Type>
struct type_list_contains;

/**
 * @copybrief type_list_contains
 * @tparam Type Types provided by the type list.
 * @tparam Other Type to look for.
 */
template<typename... Type, typename Other>
struct type_list_contains<type_list<Type...>, Other>
    : std::bool_constant<(std::is_same_v<Type, Other> || ...)> {};

/**
 * @brief Helper variable template.
 * @tparam List Type list.
 * @tparam Type Type to look for.
 */
template<typename List, typename Type>
inline constexpr bool type_list_contains_v = type_list_contains<List, Type>::value;

/*! @brief Primary template isn't defined on purpose. */
template<typename...>
struct type_list_diff;

/**
 * @brief Computes the difference between two type lists.
 * @tparam Type Types provided by the first type list.
 * @tparam Other Types provided by the second type list.
 */
template<typename... Type, typename... Other>
struct type_list_diff<type_list<Type...>, type_list<Other...>> {
    /*! @brief A type list that is the difference between the two type lists. */
    using type = type_list_cat_t<std::conditional_t<type_list_contains_v<type_list<Other...>, Type>, type_list<>, type_list<Type>>...>;
};

/**
 * @brief Helper type.
 * @tparam List Type lists between which to compute the difference.
 */
template<typename... List>
using type_list_diff_t = typename type_list_diff<List...>::type;

/*! @brief Primary template isn't defined on purpose. */
template<typename, template<typename...> class>
struct type_list_transform;

/**
 * @brief Applies a given _function_ to a type list and generate a new list.
 * @tparam Type Types provided by the type list.
 * @tparam Op Unary operation as template class with a type member named `type`.
 */
template<typename... Type, template<typename...> class Op>
struct type_list_transform<type_list<Type...>, Op> {
    /*! @brief Resulting type list after applying the transform function. */
    using type = type_list<typename Op<Type>::type...>;
};

/**
 * @brief Helper type.
 * @tparam List Type list.
 * @tparam Op Unary operation as template class with a type member named `type`.
 */
template<typename List, template<typename...> class Op>
using type_list_transform_t = typename type_list_transform<List, Op>::type;

/**
 * @brief A class to use to push around lists of constant values, nothing more.
 * @tparam Value Values provided by the value list.
 */
template<auto... Value>
struct value_list {
    /*! @brief Value list type. */
    using type = value_list;
    /*! @brief Compile-time number of elements in the value list. */
    static constexpr auto size = sizeof...(Value);
};

/*! @brief Primary template isn't defined on purpose. */
template<std::size_t, typename>
struct value_list_element;

/**
 * @brief Provides compile-time indexed access to the values of a value list.
 * @tparam Index Index of the value to return.
 * @tparam Value First value provided by the value list.
 * @tparam Other Other values provided by the value list.
 */
template<std::size_t Index, auto Value, auto... Other>
struct value_list_element<Index, value_list<Value, Other...>>
    : value_list_element<Index - 1u, value_list<Other...>> {};

/**
 * @brief Provides compile-time indexed access to the types of a type list.
 * @tparam Value First value provided by the value list.
 * @tparam Other Other values provided by the value list.
 */
template<auto Value, auto... Other>
struct value_list_element<0u, value_list<Value, Other...>> {
    /*! @brief Searched type. */
    using type = decltype(Value);
    /*! @brief Searched value. */
    static constexpr auto value = Value;
};

/**
 * @brief Helper type.
 * @tparam Index Index of the type to return.
 * @tparam List Value list to search into.
 */
template<std::size_t Index, typename List>
using value_list_element_t = typename value_list_element<Index, List>::type;

/**
 * @brief Helper type.
 * @tparam Index Index of the value to return.
 * @tparam List Value list to search into.
 */
template<std::size_t Index, typename List>
inline constexpr auto value_list_element_v = value_list_element<Index, List>::value;

/*! @brief Primary template isn't defined on purpose. */
template<auto, typename>
struct value_list_index;

/**
 * @brief Provides compile-time type access to the values of a value list.
 * @tparam Value Value to look for and for which to return the index.
 * @tparam First First value provided by the value list.
 * @tparam Other Other values provided by the value list.
 */
template<auto Value, auto First, auto... Other>
struct value_list_index<Value, value_list<First, Other...>> {
    /*! @brief Unsigned integer type. */
    using value_type = std::size_t;
    /*! @brief Compile-time position of the given value in the sublist. */
    static constexpr value_type value = 1u + value_list_index<Value, value_list<Other...>>::value;
};

/**
 * @brief Provides compile-time type access to the values of a value list.
 * @tparam Value Value to look for and for which to return the index.
 * @tparam Other Other values provided by the value list.
 */
template<auto Value, auto... Other>
struct value_list_index<Value, value_list<Value, Other...>> {
    static_assert(value_list_index<Value, value_list<Other...>>::value == sizeof...(Other), "Non-unique type");
    /*! @brief Unsigned integer type. */
    using value_type = std::size_t;
    /*! @brief Compile-time position of the given value in the sublist. */
    static constexpr value_type value = 0u;
};

/**
 * @brief Provides compile-time type access to the values of a value list.
 * @tparam Value Value to look for and for which to return the index.
 */
template<auto Value>
struct value_list_index<Value, value_list<>> {
    /*! @brief Unsigned integer type. */
    using value_type = std::size_t;
    /*! @brief Compile-time position of the given type in the sublist. */
    static constexpr value_type value = 0u;
};

/**
 * @brief Helper variable template.
 * @tparam List Value list.
 * @tparam Value Value to look for and for which to return the index.
 */
template<auto Value, typename List>
inline constexpr std::size_t value_list_index_v = value_list_index<Value, List>::value;

/**
 * @brief Concatenates multiple value lists.
 * @tparam Value Values provided by the first value list.
 * @tparam Other Values provided by the second value list.
 * @return A value list composed by the values of both the value lists.
 */
template<auto... Value, auto... Other>
constexpr value_list<Value..., Other...> operator+(value_list<Value...>, value_list<Other...>) {
    return {};
}

/*! @brief Primary template isn't defined on purpose. */
template<typename...>
struct value_list_cat;

/*! @brief Concatenates multiple value lists. */
template<>
struct value_list_cat<> {
    /*! @brief A value list composed by the values of all the value lists. */
    using type = value_list<>;
};

/**
 * @brief Concatenates multiple value lists.
 * @tparam Value Values provided by the first value list.
 * @tparam Other Values provided by the second value list.
 * @tparam List Other value lists, if any.
 */
template<auto... Value, auto... Other, typename... List>
struct value_list_cat<value_list<Value...>, value_list<Other...>, List...> {
    /*! @brief A value list composed by the values of all the value lists. */
    using type = typename value_list_cat<value_list<Value..., Other...>, List...>::type;
};

/**
 * @brief Concatenates multiple value lists.
 * @tparam Value Values provided by the value list.
 */
template<auto... Value>
struct value_list_cat<value_list<Value...>> {
    /*! @brief A value list composed by the values of all the value lists. */
    using type = value_list<Value...>;
};

/**
 * @brief Helper type.
 * @tparam List Value lists to concatenate.
 */
template<typename... List>
using value_list_cat_t = typename value_list_cat<List...>::type;

/*! @brief Primary template isn't defined on purpose. */
template<typename>
struct value_list_unique;

/**
 * @brief Removes duplicates values from a value list.
 * @tparam Value One of the values provided by the given value list.
 * @tparam Other The other values provided by the given value list.
 */
template<auto Value, auto... Other>
struct value_list_unique<value_list<Value, Other...>> {
    /*! @brief A value list without duplicate types. */
    using type = std::conditional_t<
        ((Value == Other) || ...),
        typename value_list_unique<value_list<Other...>>::type,
        value_list_cat_t<value_list<Value>, typename value_list_unique<value_list<Other...>>::type>>;
};

/*! @brief Removes duplicates values from a value list. */
template<>
struct value_list_unique<value_list<>> {
    /*! @brief A value list without duplicate types. */
    using type = value_list<>;
};

/**
 * @brief Helper type.
 * @tparam Type A value list.
 */
template<typename Type>
using value_list_unique_t = typename value_list_unique<Type>::type;

/**
 * @brief Provides the member constant `value` to true if a value list contains
 * a given value, false otherwise.
 * @tparam List Value list.
 * @tparam Value Value to look for.
 */
template<typename List, auto Value>
struct value_list_contains;

/**
 * @copybrief value_list_contains
 * @tparam Value Values provided by the value list.
 * @tparam Other Value to look for.
 */
template<auto... Value, auto Other>
struct value_list_contains<value_list<Value...>, Other>
    : std::bool_constant<((Value == Other) || ...)> {};

/**
 * @brief Helper variable template.
 * @tparam List Value list.
 * @tparam Value Value to look for.
 */
template<typename List, auto Value>
inline constexpr bool value_list_contains_v = value_list_contains<List, Value>::value;

/*! @brief Primary template isn't defined on purpose. */
template<typename...>
class value_list_diff;

/**
 * @brief Computes the difference between two value lists.
 * @tparam Value Values provided by the first value list.
 * @tparam Other Values provided by the second value list.
 */
template<auto... Value, auto... Other>
class value_list_diff<value_list<Value...>, value_list<Other...>> {
    using v141_toolset_workaround = value_list<Other...>;

public:
    /*! @brief A value list that is the difference between the two value lists. */
    using type = value_list_cat_t<std::conditional_t<value_list_contains_v<v141_toolset_workaround, Value>, value_list<>, value_list<Value>>...>;
};

/**
 * @brief Helper type.
 * @tparam List Value lists between which to compute the difference.
 */
template<typename... List>
using value_list_diff_t = typename value_list_diff<List...>::type;

/*! @brief Same as std::is_invocable, but with tuples. */
template<typename, typename>
struct is_applicable: std::false_type {};

/**
 * @copybrief is_applicable
 * @tparam Func A valid function type.
 * @tparam Tuple Tuple-like type.
 * @tparam Args The list of arguments to use to probe the function type.
 */
template<typename Func, template<typename...> class Tuple, typename... Args>
struct is_applicable<Func, Tuple<Args...>>: std::is_invocable<Func, Args...> {};

/**
 * @copybrief is_applicable
 * @tparam Func A valid function type.
 * @tparam Tuple Tuple-like type.
 * @tparam Args The list of arguments to use to probe the function type.
 */
template<typename Func, template<typename...> class Tuple, typename... Args>
struct is_applicable<Func, const Tuple<Args...>>: std::is_invocable<Func, Args...> {};

/**
 * @brief Helper variable template.
 * @tparam Func A valid function type.
 * @tparam Args The list of arguments to use to probe the function type.
 */
template<typename Func, typename Args>
inline constexpr bool is_applicable_v = is_applicable<Func, Args>::value;

/*! @brief Same as std::is_invocable_r, but with tuples for arguments. */
template<typename, typename, typename>
struct is_applicable_r: std::false_type {};

/**
 * @copybrief is_applicable_r
 * @tparam Ret The type to which the return type of the function should be
 * convertible.
 * @tparam Func A valid function type.
 * @tparam Args The list of arguments to use to probe the function type.
 */
template<typename Ret, typename Func, typename... Args>
struct is_applicable_r<Ret, Func, std::tuple<Args...>>: std::is_invocable_r<Ret, Func, Args...> {};

/**
 * @brief Helper variable template.
 * @tparam Ret The type to which the return type of the function should be
 * convertible.
 * @tparam Func A valid function type.
 * @tparam Args The list of arguments to use to probe the function type.
 */
template<typename Ret, typename Func, typename Args>
inline constexpr bool is_applicable_r_v = is_applicable_r<Ret, Func, Args>::value;

/**
 * @brief Provides the member constant `value` to true if a given type is
 * complete, false otherwise.
 * @tparam Type The type to test.
 */
template<typename Type, typename = void>
struct is_complete: std::false_type {};

/*! @copydoc is_complete */
template<typename Type>
struct is_complete<Type, std::void_t<decltype(sizeof(Type))>>: std::true_type {};

/**
 * @brief Helper variable template.
 * @tparam Type The type to test.
 */
template<typename Type>
inline constexpr bool is_complete_v = is_complete<Type>::value;

/**
 * @brief Provides the member constant `value` to true if a given type is an
 * iterator, false otherwise.
 * @tparam Type The type to test.
 */
template<typename Type, typename = void>
struct is_iterator: std::false_type {};

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename, typename = void>
struct has_iterator_category: std::false_type {};

template<typename Type>
struct has_iterator_category<Type, std::void_t<typename std::iterator_traits<Type>::iterator_category>>: std::true_type {};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/*! @copydoc is_iterator */
template<typename Type>
struct is_iterator<Type, std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_pointer_t<Type>>, void>>>
    : internal::has_iterator_category<Type> {};

/**
 * @brief Helper variable template.
 * @tparam Type The type to test.
 */
template<typename Type>
inline constexpr bool is_iterator_v = is_iterator<Type>::value;

/**
 * @brief Provides the member constant `value` to true if a given type is both
 * an empty and non-final class, false otherwise.
 * @tparam Type The type to test
 */
template<typename Type>
struct is_ebco_eligible
    : std::bool_constant<std::is_empty_v<Type> && !std::is_final_v<Type>> {};

/**
 * @brief Helper variable template.
 * @tparam Type The type to test.
 */
template<typename Type>
inline constexpr bool is_ebco_eligible_v = is_ebco_eligible<Type>::value;

/**
 * @brief Provides the member constant `value` to true if `Type::is_transparent`
 * is valid and denotes a type, false otherwise.
 * @tparam Type The type to test.
 */
template<typename Type, typename = void>
struct is_transparent: std::false_type {};

/*! @copydoc is_transparent */
template<typename Type>
struct is_transparent<Type, std::void_t<typename Type::is_transparent>>: std::true_type {};

/**
 * @brief Helper variable template.
 * @tparam Type The type to test.
 */
template<typename Type>
inline constexpr bool is_transparent_v = is_transparent<Type>::value;

/**
 * @brief Provides the member constant `value` to true if a given type is
 * equality comparable, false otherwise.
 * @tparam Type The type to test.
 */
template<typename Type, typename = void>
struct is_equality_comparable: std::false_type {};

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename, typename = void>
struct has_tuple_size_value: std::false_type {};

template<typename Type>
struct has_tuple_size_value<Type, std::void_t<decltype(std::tuple_size<const Type>::value)>>: std::true_type {};

template<typename Type, std::size_t... Index>
[[nodiscard]] constexpr bool unpack_maybe_equality_comparable(std::index_sequence<Index...>) {
    return (is_equality_comparable<std::tuple_element_t<Index, Type>>::value && ...);
}

template<typename>
[[nodiscard]] constexpr bool maybe_equality_comparable(choice_t<0>) {
    return true;
}

template<typename Type>
[[nodiscard]] constexpr auto maybe_equality_comparable(choice_t<1>) -> decltype(std::declval<typename Type::value_type>(), bool{}) {
    if constexpr(is_iterator_v<Type>) {
        return true;
    } else if constexpr(std::is_same_v<typename Type::value_type, Type>) {
        return maybe_equality_comparable<Type>(choice<0>);
    } else {
        return is_equality_comparable<typename Type::value_type>::value;
    }
}

template<typename Type>
[[nodiscard]] constexpr std::enable_if_t<is_complete_v<std::tuple_size<std::remove_cv_t<Type>>>, bool> maybe_equality_comparable(choice_t<2>) {
    if constexpr(has_tuple_size_value<Type>::value) {
        return unpack_maybe_equality_comparable<Type>(std::make_index_sequence<std::tuple_size<Type>::value>{});
    } else {
        return maybe_equality_comparable<Type>(choice<1>);
    }
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/*! @copydoc is_equality_comparable */
template<typename Type>
struct is_equality_comparable<Type, std::void_t<decltype(std::declval<Type>() == std::declval<Type>())>>
    : std::bool_constant<internal::maybe_equality_comparable<Type>(choice<2>)> {};

/*! @copydoc is_equality_comparable */
template<typename Type, auto N>
struct is_equality_comparable<Type[N]>: std::false_type {};

/**
 * @brief Helper variable template.
 * @tparam Type The type to test.
 */
template<typename Type>
inline constexpr bool is_equality_comparable_v = is_equality_comparable<Type>::value;

/**
 * @brief Transcribes the constness of a type to another type.
 * @tparam To The type to which to transcribe the constness.
 * @tparam From The type from which to transcribe the constness.
 */
template<typename To, typename From>
struct constness_as {
    /*! @brief The type resulting from the transcription of the constness. */
    using type = std::remove_const_t<To>;
};

/*! @copydoc constness_as */
template<typename To, typename From>
struct constness_as<To, const From> {
    /*! @brief The type resulting from the transcription of the constness. */
    using type = const To;
};

/**
 * @brief Alias template to facilitate the transcription of the constness.
 * @tparam To The type to which to transcribe the constness.
 * @tparam From The type from which to transcribe the constness.
 */
template<typename To, typename From>
using constness_as_t = typename constness_as<To, From>::type;

/**
 * @brief Extracts the class of a non-static member object or function.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
class member_class {
    static_assert(std::is_member_pointer_v<Member>, "Invalid pointer type to non-static member object or function");

    template<typename Class, typename Ret, typename... Args>
    static Class *clazz(Ret (Class::*)(Args...));

    template<typename Class, typename Ret, typename... Args>
    static Class *clazz(Ret (Class::*)(Args...) const);

    template<typename Class, typename Type>
    static Class *clazz(Type Class::*);

public:
    /*! @brief The class of the given non-static member object or function. */
    using type = std::remove_pointer_t<decltype(clazz(std::declval<Member>()))>;
};

/**
 * @brief Helper type.
 * @tparam Member A pointer to a non-static member object or function.
 */
template<typename Member>
using member_class_t = typename member_class<Member>::type;

/**
 * @brief Extracts the n-th argument of a given function or member function.
 * @tparam Index The index of the argument to extract.
 * @tparam Candidate A valid function, member function or data member.
 */
template<std::size_t Index, auto Candidate>
class nth_argument {
    template<typename Ret, typename... Args>
    static constexpr type_list<Args...> pick_up(Ret (*)(Args...));

    template<typename Ret, typename Class, typename... Args>
    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...));

    template<typename Ret, typename Class, typename... Args>
    static constexpr type_list<Args...> pick_up(Ret (Class ::*)(Args...) const);

    template<typename Type, typename Class>
    static constexpr type_list<Type> pick_up(Type Class ::*);

public:
    /*! @brief N-th argument of the given function or member function. */
    using type = type_list_element_t<Index, decltype(pick_up(Candidate))>;
};

/**
 * @brief Helper type.
 * @tparam Index The index of the argument to extract.
 * @tparam Candidate A valid function, member function or data member.
 */
template<std::size_t Index, auto Candidate>
using nth_argument_t = typename nth_argument<Index, Candidate>::type;

} // namespace entt

template<typename... Type>
struct std::tuple_size<entt::type_list<Type...>>: std::integral_constant<std::size_t, entt::type_list<Type...>::size> {};

template<std::size_t Index, typename... Type>
struct std::tuple_element<Index, entt::type_list<Type...>>: entt::type_list_element<Index, entt::type_list<Type...>> {};

template<auto... Value>
struct std::tuple_size<entt::value_list<Value...>>: std::integral_constant<std::size_t, entt::value_list<Value...>::size> {};

template<std::size_t Index, auto... Value>
struct std::tuple_element<Index, entt::value_list<Value...>>: entt::value_list_element<Index, entt::value_list<Value...>> {};

#endif

////////////////// END OF external/entt/core/type_traits.hpp ///////////////////

/////////////// START OF external/entt/core/compressed_pair.hpp ////////////////

#ifndef ENTT_CORE_COMPRESSED_PAIR_HPP
#define ENTT_CORE_COMPRESSED_PAIR_HPP

#include <cstddef>
#include <tuple>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Type, std::size_t, typename = void>
struct compressed_pair_element {
    using reference = Type &;
    using const_reference = const Type &;

    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<Type>>>
    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<Type>)
        : value{} {}

    template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
    constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<Type, Arg>)
        : value{std::forward<Arg>(arg)} {}

    template<typename... Args, std::size_t... Index>
    constexpr compressed_pair_element(std::tuple<Args...> args, std::index_sequence<Index...>) noexcept(std::is_nothrow_constructible_v<Type, Args...>)
        : value{std::forward<Args>(std::get<Index>(args))...} {}

    [[nodiscard]] constexpr reference get() noexcept {
        return value;
    }

    [[nodiscard]] constexpr const_reference get() const noexcept {
        return value;
    }

private:
    Type value;
};

template<typename Type, std::size_t Tag>
struct compressed_pair_element<Type, Tag, std::enable_if_t<is_ebco_eligible_v<Type>>>: Type {
    using reference = Type &;
    using const_reference = const Type &;
    using base_type = Type;

    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<base_type>>>
    constexpr compressed_pair_element() noexcept(std::is_nothrow_default_constructible_v<base_type>)
        : base_type{} {}

    template<typename Arg, typename = std::enable_if_t<!std::is_same_v<std::remove_cv_t<std::remove_reference_t<Arg>>, compressed_pair_element>>>
    constexpr compressed_pair_element(Arg &&arg) noexcept(std::is_nothrow_constructible_v<base_type, Arg>)
        : base_type{std::forward<Arg>(arg)} {}

    template<typename... Args, std::size_t... Index>
    constexpr compressed_pair_element(std::tuple<Args...> args, std::index_sequence<Index...>) noexcept(std::is_nothrow_constructible_v<base_type, Args...>)
        : base_type{std::forward<Args>(std::get<Index>(args))...} {}

    [[nodiscard]] constexpr reference get() noexcept {
        return *this;
    }

    [[nodiscard]] constexpr const_reference get() const noexcept {
        return *this;
    }
};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief A compressed pair.
 *
 * A pair that exploits the _Empty Base Class Optimization_ (or _EBCO_) to
 * reduce its final size to a minimum.
 *
 * @tparam First The type of the first element that the pair stores.
 * @tparam Second The type of the second element that the pair stores.
 */
template<typename First, typename Second>
class compressed_pair final
    : internal::compressed_pair_element<First, 0u>,
      internal::compressed_pair_element<Second, 1u> {
    using first_base = internal::compressed_pair_element<First, 0u>;
    using second_base = internal::compressed_pair_element<Second, 1u>;

public:
    /*! @brief The type of the first element that the pair stores. */
    using first_type = First;
    /*! @brief The type of the second element that the pair stores. */
    using second_type = Second;

    /**
     * @brief Default constructor, conditionally enabled.
     *
     * This constructor is only available when the types that the pair stores
     * are both at least default constructible.
     *
     * @tparam Dummy Dummy template parameter used for internal purposes.
     */
    template<bool Dummy = true, typename = std::enable_if_t<Dummy && std::is_default_constructible_v<first_type> && std::is_default_constructible_v<second_type>>>
    constexpr compressed_pair() noexcept(std::is_nothrow_default_constructible_v<first_base> &&std::is_nothrow_default_constructible_v<second_base>)
        : first_base{},
          second_base{} {}

    /**
     * @brief Copy constructor.
     * @param other The instance to copy from.
     */
    constexpr compressed_pair(const compressed_pair &other) noexcept(std::is_nothrow_copy_constructible_v<first_base> &&std::is_nothrow_copy_constructible_v<second_base>) = default;

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    constexpr compressed_pair(compressed_pair &&other) noexcept(std::is_nothrow_move_constructible_v<first_base> &&std::is_nothrow_move_constructible_v<second_base>) = default;

    /**
     * @brief Constructs a pair from its values.
     * @tparam Arg Type of value to use to initialize the first element.
     * @tparam Other Type of value to use to initialize the second element.
     * @param arg Value to use to initialize the first element.
     * @param other Value to use to initialize the second element.
     */
    template<typename Arg, typename Other>
    constexpr compressed_pair(Arg &&arg, Other &&other) noexcept(std::is_nothrow_constructible_v<first_base, Arg> &&std::is_nothrow_constructible_v<second_base, Other>)
        : first_base{std::forward<Arg>(arg)},
          second_base{std::forward<Other>(other)} {}

    /**
     * @brief Constructs a pair by forwarding the arguments to its parts.
     * @tparam Args Types of arguments to use to initialize the first element.
     * @tparam Other Types of arguments to use to initialize the second element.
     * @param args Arguments to use to initialize the first element.
     * @param other Arguments to use to initialize the second element.
     */
    template<typename... Args, typename... Other>
    constexpr compressed_pair(std::piecewise_construct_t, std::tuple<Args...> args, std::tuple<Other...> other) noexcept(std::is_nothrow_constructible_v<first_base, Args...> &&std::is_nothrow_constructible_v<second_base, Other...>)
        : first_base{std::move(args), std::index_sequence_for<Args...>{}},
          second_base{std::move(other), std::index_sequence_for<Other...>{}} {}

    /**
     * @brief Copy assignment operator.
     * @param other The instance to copy from.
     * @return This compressed pair object.
     */
    constexpr compressed_pair &operator=(const compressed_pair &other) noexcept(std::is_nothrow_copy_assignable_v<first_base> &&std::is_nothrow_copy_assignable_v<second_base>) = default;

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This compressed pair object.
     */
    constexpr compressed_pair &operator=(compressed_pair &&other) noexcept(std::is_nothrow_move_assignable_v<first_base> &&std::is_nothrow_move_assignable_v<second_base>) = default;

    /**
     * @brief Returns the first element that a pair stores.
     * @return The first element that a pair stores.
     */
    [[nodiscard]] constexpr first_type &first() noexcept {
        return static_cast<first_base &>(*this).get();
    }

    /*! @copydoc first */
    [[nodiscard]] constexpr const first_type &first() const noexcept {
        return static_cast<const first_base &>(*this).get();
    }

    /**
     * @brief Returns the second element that a pair stores.
     * @return The second element that a pair stores.
     */
    [[nodiscard]] constexpr second_type &second() noexcept {
        return static_cast<second_base &>(*this).get();
    }

    /*! @copydoc second */
    [[nodiscard]] constexpr const second_type &second() const noexcept {
        return static_cast<const second_base &>(*this).get();
    }

    /**
     * @brief Swaps two compressed pair objects.
     * @param other The compressed pair to swap with.
     */
    constexpr void swap(compressed_pair &other) noexcept(std::is_nothrow_swappable_v<first_type> &&std::is_nothrow_swappable_v<second_type>) {
        using std::swap;
        swap(first(), other.first());
        swap(second(), other.second());
    }

    /**
     * @brief Extracts an element from the compressed pair.
     * @tparam Index An integer value that is either 0 or 1.
     * @return Returns a reference to the first element if `Index` is 0 and a
     * reference to the second element if `Index` is 1.
     */
    template<std::size_t Index>
    constexpr decltype(auto) get() noexcept {
        if constexpr(Index == 0u) {
            return first();
        } else {
            static_assert(Index == 1u, "Index out of bounds");
            return second();
        }
    }

    /*! @copydoc get */
    template<std::size_t Index>
    constexpr decltype(auto) get() const noexcept {
        if constexpr(Index == 0u) {
            return first();
        } else {
            static_assert(Index == 1u, "Index out of bounds");
            return second();
        }
    }
};

/**
 * @brief Deduction guide.
 * @tparam Type Type of value to use to initialize the first element.
 * @tparam Other Type of value to use to initialize the second element.
 */
template<typename Type, typename Other>
compressed_pair(Type &&, Other &&) -> compressed_pair<std::decay_t<Type>, std::decay_t<Other>>;

/**
 * @brief Swaps two compressed pair objects.
 * @tparam First The type of the first element that the pairs store.
 * @tparam Second The type of the second element that the pairs store.
 * @param lhs A valid compressed pair object.
 * @param rhs A valid compressed pair object.
 */
template<typename First, typename Second>
inline constexpr void swap(compressed_pair<First, Second> &lhs, compressed_pair<First, Second> &rhs) {
    lhs.swap(rhs);
}

} // namespace entt

// disable structured binding support for clang 6, it messes when specializing tuple_size
#if !defined __clang_major__ || __clang_major__ > 6
namespace std {

/**
 * @brief `std::tuple_size` specialization for `compressed_pair`s.
 * @tparam First The type of the first element that the pair stores.
 * @tparam Second The type of the second element that the pair stores.
 */
template<typename First, typename Second>
struct tuple_size<entt::compressed_pair<First, Second>>: integral_constant<size_t, 2u> {};

/**
 * @brief `std::tuple_element` specialization for `compressed_pair`s.
 * @tparam Index The index of the type to return.
 * @tparam First The type of the first element that the pair stores.
 * @tparam Second The type of the second element that the pair stores.
 */
template<size_t Index, typename First, typename Second>
struct tuple_element<Index, entt::compressed_pair<First, Second>>: conditional<Index == 0u, First, Second> {
    static_assert(Index < 2u, "Index out of bounds");
};

} // namespace std
#endif

#endif

//////////////// END OF external/entt/core/compressed_pair.hpp /////////////////

/////////////////// START OF external/entt/core/iterator.hpp ///////////////////

#ifndef ENTT_CORE_ITERATOR_HPP
#define ENTT_CORE_ITERATOR_HPP

#include <iterator>
#include <memory>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @brief Helper type to use as pointer with input iterators.
 * @tparam Type of wrapped value.
 */
template<typename Type>
struct input_iterator_pointer final {
    /*! @brief Value type. */
    using value_type = Type;
    /*! @brief Pointer type. */
    using pointer = Type *;
    /*! @brief Reference type. */
    using reference = Type &;

    /**
     * @brief Constructs a proxy object by move.
     * @param val Value to use to initialize the proxy object.
     */
    constexpr input_iterator_pointer(value_type &&val) noexcept(std::is_nothrow_move_constructible_v<value_type>)
        : value{std::move(val)} {}

    /**
     * @brief Access operator for accessing wrapped values.
     * @return A pointer to the wrapped value.
     */
    [[nodiscard]] constexpr pointer operator->() noexcept {
        return std::addressof(value);
    }

    /**
     * @brief Dereference operator for accessing wrapped values.
     * @return A reference to the wrapped value.
     */
    [[nodiscard]] constexpr reference operator*() noexcept {
        return value;
    }

private:
    Type value;
};

/**
 * @brief Plain iota iterator (waiting for C++20).
 * @tparam Type Value type.
 */
template<typename Type>
class iota_iterator final {
    static_assert(std::is_integral_v<Type>, "Not an integral type");

public:
    /*! @brief Value type, likely an integral one. */
    using value_type = Type;
    /*! @brief Invalid pointer type. */
    using pointer = void;
    /*! @brief Non-reference type, same as value type. */
    using reference = value_type;
    /*! @brief Difference type. */
    using difference_type = std::ptrdiff_t;
    /*! @brief Iterator category. */
    using iterator_category = std::input_iterator_tag;

    /*! @brief Default constructor. */
    constexpr iota_iterator() noexcept
        : current{} {}

    /**
     * @brief Constructs an iota iterator from a given value.
     * @param init The initial value assigned to the iota iterator.
     */
    constexpr iota_iterator(const value_type init) noexcept
        : current{init} {}

    /**
     * @brief Pre-increment operator.
     * @return This iota iterator.
     */
    constexpr iota_iterator &operator++() noexcept {
        return ++current, *this;
    }

    /**
     * @brief Post-increment operator.
     * @return This iota iterator.
     */
    constexpr iota_iterator operator++(int) noexcept {
        iota_iterator orig = *this;
        return ++(*this), orig;
    }

    /**
     * @brief Dereference operator.
     * @return The underlying value.
     */
    [[nodiscard]] constexpr reference operator*() const noexcept {
        return current;
    }

private:
    value_type current;
};

/**
 * @brief Comparison operator.
 * @tparam Type Value type of the iota iterator.
 * @param lhs A properly initialized iota iterator.
 * @param rhs A properly initialized iota iterator.
 * @return True if the two iterators are identical, false otherwise.
 */
template<typename Type>
[[nodiscard]] constexpr bool operator==(const iota_iterator<Type> &lhs, const iota_iterator<Type> &rhs) noexcept {
    return *lhs == *rhs;
}

/**
 * @brief Comparison operator.
 * @tparam Type Value type of the iota iterator.
 * @param lhs A properly initialized iota iterator.
 * @param rhs A properly initialized iota iterator.
 * @return True if the two iterators differ, false otherwise.
 */
template<typename Type>
[[nodiscard]] constexpr bool operator!=(const iota_iterator<Type> &lhs, const iota_iterator<Type> &rhs) noexcept {
    return !(lhs == rhs);
}

/**
 * @brief Utility class to create an iterable object from a pair of iterators.
 * @tparam It Type of iterator.
 * @tparam Sentinel Type of sentinel.
 */
template<typename It, typename Sentinel = It>
struct iterable_adaptor final {
    /*! @brief Value type. */
    using value_type = typename std::iterator_traits<It>::value_type;
    /*! @brief Iterator type. */
    using iterator = It;
    /*! @brief Sentinel type. */
    using sentinel = Sentinel;

    /*! @brief Default constructor. */
    constexpr iterable_adaptor() noexcept(std::is_nothrow_default_constructible_v<iterator> &&std::is_nothrow_default_constructible_v<sentinel>)
        : first{},
          last{} {}

    /**
     * @brief Creates an iterable object from a pair of iterators.
     * @param from Begin iterator.
     * @param to End iterator.
     */
    constexpr iterable_adaptor(iterator from, sentinel to) noexcept(std::is_nothrow_move_constructible_v<iterator> &&std::is_nothrow_move_constructible_v<sentinel>)
        : first{std::move(from)},
          last{std::move(to)} {}

    /**
     * @brief Returns an iterator to the beginning.
     * @return An iterator to the first element of the range.
     */
    [[nodiscard]] constexpr iterator begin() const noexcept {
        return first;
    }

    /**
     * @brief Returns an iterator to the end.
     * @return An iterator to the element following the last element of the
     * range.
     */
    [[nodiscard]] constexpr sentinel end() const noexcept {
        return last;
    }

    /*! @copydoc begin */
    [[nodiscard]] constexpr iterator cbegin() const noexcept {
        return begin();
    }

    /*! @copydoc end */
    [[nodiscard]] constexpr sentinel cend() const noexcept {
        return end();
    }

private:
    It first;
    Sentinel last;
};

} // namespace entt

#endif

//////////////////// END OF external/entt/core/iterator.hpp ////////////////////

//////////////////// START OF external/entt/core/memory.hpp ////////////////////

#ifndef ENTT_CORE_MEMORY_HPP
#define ENTT_CORE_MEMORY_HPP

#include <cstddef>
#include <limits>
#include <memory>
#include <tuple>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @brief Checks whether a value is a power of two or not.
 * @param value A value that may or may not be a power of two.
 * @return True if the value is a power of two, false otherwise.
 */
[[nodiscard]] inline constexpr bool is_power_of_two(const std::size_t value) noexcept {
    return value && ((value & (value - 1)) == 0);
}

/**
 * @brief Computes the smallest power of two greater than or equal to a value.
 * @param value The value to use.
 * @return The smallest power of two greater than or equal to the given value.
 */
[[nodiscard]] inline constexpr std::size_t next_power_of_two(const std::size_t value) noexcept {
    ENTT_ASSERT_CONSTEXPR(value < (std::size_t{1u} << (std::numeric_limits<std::size_t>::digits - 1)), "Numeric limits exceeded");
    std::size_t curr = value - (value != 0u);

    for(int next = 1; next < std::numeric_limits<std::size_t>::digits; next = next * 2) {
        curr |= curr >> next;
    }

    return ++curr;
}

/**
 * @brief Fast module utility function (powers of two only).
 * @param value A value for which to calculate the modulus.
 * @param mod _Modulus_, it must be a power of two.
 * @return The common remainder.
 */
[[nodiscard]] inline constexpr std::size_t fast_mod(const std::size_t value, const std::size_t mod) noexcept {
    ENTT_ASSERT_CONSTEXPR(is_power_of_two(mod), "Value must be a power of two");
    return value & (mod - 1u);
}

/**
 * @brief Unwraps fancy pointers, does nothing otherwise (waiting for C++20).
 * @tparam Type Pointer type.
 * @param ptr Fancy or raw pointer.
 * @return A raw pointer that represents the address of the original pointer.
 */
template<typename Type>
[[nodiscard]] constexpr auto to_address(Type &&ptr) noexcept {
    if constexpr(std::is_pointer_v<std::decay_t<Type>>) {
        return ptr;
    } else {
        return to_address(std::forward<Type>(ptr).operator->());
    }
}

/**
 * @brief Utility function to design allocation-aware containers.
 * @tparam Allocator Type of allocator.
 * @param lhs A valid allocator.
 * @param rhs Another valid allocator.
 */
template<typename Allocator>
constexpr void propagate_on_container_copy_assignment([[maybe_unused]] Allocator &lhs, [[maybe_unused]] Allocator &rhs) noexcept {
    if constexpr(std::allocator_traits<Allocator>::propagate_on_container_copy_assignment::value) {
        lhs = rhs;
    }
}

/**
 * @brief Utility function to design allocation-aware containers.
 * @tparam Allocator Type of allocator.
 * @param lhs A valid allocator.
 * @param rhs Another valid allocator.
 */
template<typename Allocator>
constexpr void propagate_on_container_move_assignment([[maybe_unused]] Allocator &lhs, [[maybe_unused]] Allocator &rhs) noexcept {
    if constexpr(std::allocator_traits<Allocator>::propagate_on_container_move_assignment::value) {
        lhs = std::move(rhs);
    }
}

/**
 * @brief Utility function to design allocation-aware containers.
 * @tparam Allocator Type of allocator.
 * @param lhs A valid allocator.
 * @param rhs Another valid allocator.
 */
template<typename Allocator>
constexpr void propagate_on_container_swap([[maybe_unused]] Allocator &lhs, [[maybe_unused]] Allocator &rhs) noexcept {
    if constexpr(std::allocator_traits<Allocator>::propagate_on_container_swap::value) {
        using std::swap;
        swap(lhs, rhs);
    } else {
        ENTT_ASSERT_CONSTEXPR(lhs == rhs, "Cannot swap the containers");
    }
}

/**
 * @brief Deleter for allocator-aware unique pointers (waiting for C++20).
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Allocator>
struct allocation_deleter: private Allocator {
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Pointer type. */
    using pointer = typename std::allocator_traits<Allocator>::pointer;

    /**
     * @brief Inherited constructors.
     * @param alloc The allocator to use.
     */
    constexpr allocation_deleter(const allocator_type &alloc) noexcept(std::is_nothrow_copy_constructible_v<allocator_type>)
        : Allocator{alloc} {}

    /**
     * @brief Destroys the pointed object and deallocates its memory.
     * @param ptr A valid pointer to an object of the given type.
     */
    constexpr void operator()(pointer ptr) noexcept(std::is_nothrow_destructible_v<typename allocator_type::value_type>) {
        using alloc_traits = std::allocator_traits<Allocator>;
        alloc_traits::destroy(*this, to_address(ptr));
        alloc_traits::deallocate(*this, ptr, 1u);
    }
};

/**
 * @brief Allows `std::unique_ptr` to use allocators (waiting for C++20).
 * @tparam Type Type of object to allocate for and to construct.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 * @tparam Args Types of arguments to use to construct the object.
 * @param allocator The allocator to use.
 * @param args Parameters to use to construct the object.
 * @return A properly initialized unique pointer with a custom deleter.
 */
template<typename Type, typename Allocator, typename... Args>
ENTT_CONSTEXPR auto allocate_unique(Allocator &allocator, Args &&...args) {
    static_assert(!std::is_array_v<Type>, "Array types are not supported");

    using alloc_traits = typename std::allocator_traits<Allocator>::template rebind_traits<Type>;
    using allocator_type = typename alloc_traits::allocator_type;

    allocator_type alloc{allocator};
    auto ptr = alloc_traits::allocate(alloc, 1u);

    ENTT_TRY {
        alloc_traits::construct(alloc, to_address(ptr), std::forward<Args>(args)...);
    }
    ENTT_CATCH {
        alloc_traits::deallocate(alloc, ptr, 1u);
        ENTT_THROW;
    }

    return std::unique_ptr<Type, allocation_deleter<allocator_type>>{ptr, alloc};
}

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Type>
struct uses_allocator_construction {
    template<typename Allocator, typename... Params>
    static constexpr auto args([[maybe_unused]] const Allocator &allocator, Params &&...params) noexcept {
        if constexpr(!std::uses_allocator_v<Type, Allocator> && std::is_constructible_v<Type, Params...>) {
            return std::forward_as_tuple(std::forward<Params>(params)...);
        } else {
            static_assert(std::uses_allocator_v<Type, Allocator>, "Ill-formed request");

            if constexpr(std::is_constructible_v<Type, std::allocator_arg_t, const Allocator &, Params...>) {
                return std::tuple<std::allocator_arg_t, const Allocator &, Params &&...>{std::allocator_arg, allocator, std::forward<Params>(params)...};
            } else {
                static_assert(std::is_constructible_v<Type, Params..., const Allocator &>, "Ill-formed request");
                return std::forward_as_tuple(std::forward<Params>(params)..., allocator);
            }
        }
    }
};

template<typename Type, typename Other>
struct uses_allocator_construction<std::pair<Type, Other>> {
    using type = std::pair<Type, Other>;

    template<typename Allocator, typename First, typename Second>
    static constexpr auto args(const Allocator &allocator, std::piecewise_construct_t, First &&first, Second &&second) noexcept {
        return std::make_tuple(
            std::piecewise_construct,
            std::apply([&allocator](auto &&...curr) { return uses_allocator_construction<Type>::args(allocator, std::forward<decltype(curr)>(curr)...); }, std::forward<First>(first)),
            std::apply([&allocator](auto &&...curr) { return uses_allocator_construction<Other>::args(allocator, std::forward<decltype(curr)>(curr)...); }, std::forward<Second>(second)));
    }

    template<typename Allocator>
    static constexpr auto args(const Allocator &allocator) noexcept {
        return uses_allocator_construction<type>::args(allocator, std::piecewise_construct, std::tuple<>{}, std::tuple<>{});
    }

    template<typename Allocator, typename First, typename Second>
    static constexpr auto args(const Allocator &allocator, First &&first, Second &&second) noexcept {
        return uses_allocator_construction<type>::args(allocator, std::piecewise_construct, std::forward_as_tuple(std::forward<First>(first)), std::forward_as_tuple(std::forward<Second>(second)));
    }

    template<typename Allocator, typename First, typename Second>
    static constexpr auto args(const Allocator &allocator, const std::pair<First, Second> &value) noexcept {
        return uses_allocator_construction<type>::args(allocator, std::piecewise_construct, std::forward_as_tuple(value.first), std::forward_as_tuple(value.second));
    }

    template<typename Allocator, typename First, typename Second>
    static constexpr auto args(const Allocator &allocator, std::pair<First, Second> &&value) noexcept {
        return uses_allocator_construction<type>::args(allocator, std::piecewise_construct, std::forward_as_tuple(std::move(value.first)), std::forward_as_tuple(std::move(value.second)));
    }
};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Uses-allocator construction utility (waiting for C++20).
 *
 * Primarily intended for internal use. Prepares the argument list needed to
 * create an object of a given type by means of uses-allocator construction.
 *
 * @tparam Type Type to return arguments for.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 * @tparam Args Types of arguments to use to construct the object.
 * @param allocator The allocator to use.
 * @param args Parameters to use to construct the object.
 * @return The arguments needed to create an object of the given type.
 */
template<typename Type, typename Allocator, typename... Args>
constexpr auto uses_allocator_construction_args(const Allocator &allocator, Args &&...args) noexcept {
    return internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...);
}

/**
 * @brief Uses-allocator construction utility (waiting for C++20).
 *
 * Primarily intended for internal use. Creates an object of a given type by
 * means of uses-allocator construction.
 *
 * @tparam Type Type of object to create.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 * @tparam Args Types of arguments to use to construct the object.
 * @param allocator The allocator to use.
 * @param args Parameters to use to construct the object.
 * @return A newly created object of the given type.
 */
template<typename Type, typename Allocator, typename... Args>
constexpr Type make_obj_using_allocator(const Allocator &allocator, Args &&...args) {
    return std::make_from_tuple<Type>(internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
}

/**
 * @brief Uses-allocator construction utility (waiting for C++20).
 *
 * Primarily intended for internal use. Creates an object of a given type by
 * means of uses-allocator construction at an uninitialized memory location.
 *
 * @tparam Type Type of object to create.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 * @tparam Args Types of arguments to use to construct the object.
 * @param value Memory location in which to place the object.
 * @param allocator The allocator to use.
 * @param args Parameters to use to construct the object.
 * @return A pointer to the newly created object of the given type.
 */
template<typename Type, typename Allocator, typename... Args>
constexpr Type *uninitialized_construct_using_allocator(Type *value, const Allocator &allocator, Args &&...args) {
    return std::apply([value](auto &&...curr) { return new(value) Type(std::forward<decltype(curr)>(curr)...); }, internal::uses_allocator_construction<Type>::args(allocator, std::forward<Args>(args)...));
}

} // namespace entt

#endif

///////////////////// END OF external/entt/core/memory.hpp /////////////////////

//////////////// START OF external/entt/container/dense_map.hpp ////////////////

#ifndef ENTT_CONTAINER_DENSE_MAP_HPP
#define ENTT_CONTAINER_DENSE_MAP_HPP

#include <cmath>
#include <cstddef>
#include <functional>
#include <iterator>
#include <limits>
#include <memory>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Key, typename Type>
struct dense_map_node final {
    using value_type = std::pair<Key, Type>;

    template<typename... Args>
    dense_map_node(const std::size_t pos, Args &&...args)
        : next{pos},
          element{std::forward<Args>(args)...} {}

    template<typename Allocator, typename... Args>
    dense_map_node(std::allocator_arg_t, const Allocator &allocator, const std::size_t pos, Args &&...args)
        : next{pos},
          element{entt::make_obj_using_allocator<value_type>(allocator, std::forward<Args>(args)...)} {}

    template<typename Allocator>
    dense_map_node(std::allocator_arg_t, const Allocator &allocator, const dense_map_node &other)
        : next{other.next},
          element{entt::make_obj_using_allocator<value_type>(allocator, other.element)} {}

    template<typename Allocator>
    dense_map_node(std::allocator_arg_t, const Allocator &allocator, dense_map_node &&other)
        : next{other.next},
          element{entt::make_obj_using_allocator<value_type>(allocator, std::move(other.element))} {}

    std::size_t next;
    value_type element;
};

template<typename It>
class dense_map_iterator final {
    template<typename>
    friend class dense_map_iterator;

    using first_type = decltype(std::as_const(std::declval<It>()->element.first));
    using second_type = decltype((std::declval<It>()->element.second));

public:
    using value_type = std::pair<first_type, second_type>;
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::input_iterator_tag;

    constexpr dense_map_iterator() noexcept
        : it{} {}

    constexpr dense_map_iterator(const It iter) noexcept
        : it{iter} {}

    template<typename Other, typename = std::enable_if_t<!std::is_same_v<It, Other> && std::is_constructible_v<It, Other>>>
    constexpr dense_map_iterator(const dense_map_iterator<Other> &other) noexcept
        : it{other.it} {}

    constexpr dense_map_iterator &operator++() noexcept {
        return ++it, *this;
    }

    constexpr dense_map_iterator operator++(int) noexcept {
        dense_map_iterator orig = *this;
        return ++(*this), orig;
    }

    constexpr dense_map_iterator &operator--() noexcept {
        return --it, *this;
    }

    constexpr dense_map_iterator operator--(int) noexcept {
        dense_map_iterator orig = *this;
        return operator--(), orig;
    }

    constexpr dense_map_iterator &operator+=(const difference_type value) noexcept {
        it += value;
        return *this;
    }

    constexpr dense_map_iterator operator+(const difference_type value) const noexcept {
        dense_map_iterator copy = *this;
        return (copy += value);
    }

    constexpr dense_map_iterator &operator-=(const difference_type value) noexcept {
        return (*this += -value);
    }

    constexpr dense_map_iterator operator-(const difference_type value) const noexcept {
        return (*this + -value);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
        return {it[value].element.first, it[value].element.second};
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return operator*();
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return {it->element.first, it->element.second};
    }

    template<typename Lhs, typename Rhs>
    friend constexpr std::ptrdiff_t operator-(const dense_map_iterator<Lhs> &, const dense_map_iterator<Rhs> &) noexcept;

    template<typename Lhs, typename Rhs>
    friend constexpr bool operator==(const dense_map_iterator<Lhs> &, const dense_map_iterator<Rhs> &) noexcept;

    template<typename Lhs, typename Rhs>
    friend constexpr bool operator<(const dense_map_iterator<Lhs> &, const dense_map_iterator<Rhs> &) noexcept;

private:
    It it;
};

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr std::ptrdiff_t operator-(const dense_map_iterator<Lhs> &lhs, const dense_map_iterator<Rhs> &rhs) noexcept {
    return lhs.it - rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator==(const dense_map_iterator<Lhs> &lhs, const dense_map_iterator<Rhs> &rhs) noexcept {
    return lhs.it == rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator!=(const dense_map_iterator<Lhs> &lhs, const dense_map_iterator<Rhs> &rhs) noexcept {
    return !(lhs == rhs);
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator<(const dense_map_iterator<Lhs> &lhs, const dense_map_iterator<Rhs> &rhs) noexcept {
    return lhs.it < rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator>(const dense_map_iterator<Lhs> &lhs, const dense_map_iterator<Rhs> &rhs) noexcept {
    return rhs < lhs;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator<=(const dense_map_iterator<Lhs> &lhs, const dense_map_iterator<Rhs> &rhs) noexcept {
    return !(lhs > rhs);
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator>=(const dense_map_iterator<Lhs> &lhs, const dense_map_iterator<Rhs> &rhs) noexcept {
    return !(lhs < rhs);
}

template<typename It>
class dense_map_local_iterator final {
    template<typename>
    friend class dense_map_local_iterator;

    using first_type = decltype(std::as_const(std::declval<It>()->element.first));
    using second_type = decltype((std::declval<It>()->element.second));

public:
    using value_type = std::pair<first_type, second_type>;
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::input_iterator_tag;

    constexpr dense_map_local_iterator() noexcept
        : it{},
          offset{} {}

    constexpr dense_map_local_iterator(It iter, const std::size_t pos) noexcept
        : it{iter},
          offset{pos} {}

    template<typename Other, typename = std::enable_if_t<!std::is_same_v<It, Other> && std::is_constructible_v<It, Other>>>
    constexpr dense_map_local_iterator(const dense_map_local_iterator<Other> &other) noexcept
        : it{other.it},
          offset{other.offset} {}

    constexpr dense_map_local_iterator &operator++() noexcept {
        return offset = it[offset].next, *this;
    }

    constexpr dense_map_local_iterator operator++(int) noexcept {
        dense_map_local_iterator orig = *this;
        return ++(*this), orig;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return operator*();
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return {it[offset].element.first, it[offset].element.second};
    }

    [[nodiscard]] constexpr std::size_t index() const noexcept {
        return offset;
    }

private:
    It it;
    std::size_t offset;
};

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator==(const dense_map_local_iterator<Lhs> &lhs, const dense_map_local_iterator<Rhs> &rhs) noexcept {
    return lhs.index() == rhs.index();
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator!=(const dense_map_local_iterator<Lhs> &lhs, const dense_map_local_iterator<Rhs> &rhs) noexcept {
    return !(lhs == rhs);
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Associative container for key-value pairs with unique keys.
 *
 * Internally, elements are organized into buckets. Which bucket an element is
 * placed into depends entirely on the hash of its key. Keys with the same hash
 * code appear in the same bucket.
 *
 * @tparam Key Key type of the associative container.
 * @tparam Type Mapped type of the associative container.
 * @tparam Hash Type of function to use to hash the keys.
 * @tparam KeyEqual Type of function to use to compare the keys for equality.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Key, typename Type, typename Hash, typename KeyEqual, typename Allocator>
class dense_map {
    static constexpr float default_threshold = 0.875f;
    static constexpr std::size_t minimum_capacity = 8u;

    using node_type = internal::dense_map_node<Key, Type>;
    using alloc_traits = std::allocator_traits<Allocator>;
    static_assert(std::is_same_v<typename alloc_traits::value_type, std::pair<const Key, Type>>, "Invalid value type");
    using sparse_container_type = std::vector<std::size_t, typename alloc_traits::template rebind_alloc<std::size_t>>;
    using packed_container_type = std::vector<node_type, typename alloc_traits::template rebind_alloc<node_type>>;

    template<typename Other>
    [[nodiscard]] std::size_t key_to_bucket(const Other &key) const noexcept {
        return fast_mod(static_cast<size_type>(sparse.second()(key)), bucket_count());
    }

    template<typename Other>
    [[nodiscard]] auto constrained_find(const Other &key, std::size_t bucket) {
        for(auto it = begin(bucket), last = end(bucket); it != last; ++it) {
            if(packed.second()(it->first, key)) {
                return begin() + static_cast<typename iterator::difference_type>(it.index());
            }
        }

        return end();
    }

    template<typename Other>
    [[nodiscard]] auto constrained_find(const Other &key, std::size_t bucket) const {
        for(auto it = cbegin(bucket), last = cend(bucket); it != last; ++it) {
            if(packed.second()(it->first, key)) {
                return cbegin() + static_cast<typename iterator::difference_type>(it.index());
            }
        }

        return cend();
    }

    template<typename Other, typename... Args>
    [[nodiscard]] auto insert_or_do_nothing(Other &&key, Args &&...args) {
        const auto index = key_to_bucket(key);

        if(auto it = constrained_find(key, index); it != end()) {
            return std::make_pair(it, false);
        }

        packed.first().emplace_back(sparse.first()[index], std::piecewise_construct, std::forward_as_tuple(std::forward<Other>(key)), std::forward_as_tuple(std::forward<Args>(args)...));
        sparse.first()[index] = packed.first().size() - 1u;
        rehash_if_required();

        return std::make_pair(--end(), true);
    }

    template<typename Other, typename Arg>
    [[nodiscard]] auto insert_or_overwrite(Other &&key, Arg &&value) {
        const auto index = key_to_bucket(key);

        if(auto it = constrained_find(key, index); it != end()) {
            it->second = std::forward<Arg>(value);
            return std::make_pair(it, false);
        }

        packed.first().emplace_back(sparse.first()[index], std::forward<Other>(key), std::forward<Arg>(value));
        sparse.first()[index] = packed.first().size() - 1u;
        rehash_if_required();

        return std::make_pair(--end(), true);
    }

    void move_and_pop(const std::size_t pos) {
        if(const auto last = size() - 1u; pos != last) {
            size_type *curr = sparse.first().data() + key_to_bucket(packed.first().back().element.first);
            packed.first()[pos] = std::move(packed.first().back());
            for(; *curr != last; curr = &packed.first()[*curr].next) {}
            *curr = pos;
        }

        packed.first().pop_back();
    }

    void rehash_if_required() {
        if(size() > (bucket_count() * max_load_factor())) {
            rehash(bucket_count() * 2u);
        }
    }

public:
    /*! @brief Key type of the container. */
    using key_type = Key;
    /*! @brief Mapped type of the container. */
    using mapped_type = Type;
    /*! @brief Key-value type of the container. */
    using value_type = std::pair<const Key, Type>;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Type of function to use to hash the keys. */
    using hasher = Hash;
    /*! @brief Type of function to use to compare the keys for equality. */
    using key_equal = KeyEqual;
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Input iterator type. */
    using iterator = internal::dense_map_iterator<typename packed_container_type::iterator>;
    /*! @brief Constant input iterator type. */
    using const_iterator = internal::dense_map_iterator<typename packed_container_type::const_iterator>;
    /*! @brief Input iterator type. */
    using local_iterator = internal::dense_map_local_iterator<typename packed_container_type::iterator>;
    /*! @brief Constant input iterator type. */
    using const_local_iterator = internal::dense_map_local_iterator<typename packed_container_type::const_iterator>;

    /*! @brief Default constructor. */
    dense_map()
        : dense_map{minimum_capacity} {}

    /**
     * @brief Constructs an empty container with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit dense_map(const allocator_type &allocator)
        : dense_map{minimum_capacity, hasher{}, key_equal{}, allocator} {}

    /**
     * @brief Constructs an empty container with a given allocator and user
     * supplied minimal number of buckets.
     * @param cnt Minimal number of buckets.
     * @param allocator The allocator to use.
     */
    dense_map(const size_type cnt, const allocator_type &allocator)
        : dense_map{cnt, hasher{}, key_equal{}, allocator} {}

    /**
     * @brief Constructs an empty container with a given allocator, hash
     * function and user supplied minimal number of buckets.
     * @param cnt Minimal number of buckets.
     * @param hash Hash function to use.
     * @param allocator The allocator to use.
     */
    dense_map(const size_type cnt, const hasher &hash, const allocator_type &allocator)
        : dense_map{cnt, hash, key_equal{}, allocator} {}

    /**
     * @brief Constructs an empty container with a given allocator, hash
     * function, compare function and user supplied minimal number of buckets.
     * @param cnt Minimal number of buckets.
     * @param hash Hash function to use.
     * @param equal Compare function to use.
     * @param allocator The allocator to use.
     */
    explicit dense_map(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
        : sparse{allocator, hash},
          packed{allocator, equal},
          threshold{default_threshold} {
        rehash(cnt);
    }

    /*! @brief Default copy constructor. */
    dense_map(const dense_map &) = default;

    /**
     * @brief Allocator-extended copy constructor.
     * @param other The instance to copy from.
     * @param allocator The allocator to use.
     */
    dense_map(const dense_map &other, const allocator_type &allocator)
        : sparse{std::piecewise_construct, std::forward_as_tuple(other.sparse.first(), allocator), std::forward_as_tuple(other.sparse.second())},
          packed{std::piecewise_construct, std::forward_as_tuple(other.packed.first(), allocator), std::forward_as_tuple(other.packed.second())},
          threshold{other.threshold} {}

    /*! @brief Default move constructor. */
    dense_map(dense_map &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;

    /**
     * @brief Allocator-extended move constructor.
     * @param other The instance to move from.
     * @param allocator The allocator to use.
     */
    dense_map(dense_map &&other, const allocator_type &allocator)
        : sparse{std::piecewise_construct, std::forward_as_tuple(std::move(other.sparse.first()), allocator), std::forward_as_tuple(std::move(other.sparse.second()))},
          packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
          threshold{other.threshold} {}

    /**
     * @brief Default copy assignment operator.
     * @return This container.
     */
    dense_map &operator=(const dense_map &) = default;

    /**
     * @brief Default move assignment operator.
     * @return This container.
     */
    dense_map &operator=(dense_map &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;

    /**
     * @brief Returns the associated allocator.
     * @return The associated allocator.
     */
    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return sparse.first().get_allocator();
    }

    /**
     * @brief Returns an iterator to the beginning.
     *
     * If the array is empty, the returned iterator will be equal to `end()`.
     *
     * @return An iterator to the first instance of the internal array.
     */
    [[nodiscard]] const_iterator cbegin() const noexcept {
        return packed.first().begin();
    }

    /*! @copydoc cbegin */
    [[nodiscard]] const_iterator begin() const noexcept {
        return cbegin();
    }

    /*! @copydoc begin */
    [[nodiscard]] iterator begin() noexcept {
        return packed.first().begin();
    }

    /**
     * @brief Returns an iterator to the end.
     * @return An iterator to the element following the last instance of the
     * internal array.
     */
    [[nodiscard]] const_iterator cend() const noexcept {
        return packed.first().end();
    }

    /*! @copydoc cend */
    [[nodiscard]] const_iterator end() const noexcept {
        return cend();
    }

    /*! @copydoc end */
    [[nodiscard]] iterator end() noexcept {
        return packed.first().end();
    }

    /**
     * @brief Checks whether a container is empty.
     * @return True if the container is empty, false otherwise.
     */
    [[nodiscard]] bool empty() const noexcept {
        return packed.first().empty();
    }

    /**
     * @brief Returns the number of elements in a container.
     * @return Number of elements in a container.
     */
    [[nodiscard]] size_type size() const noexcept {
        return packed.first().size();
    }

    /**
     * @brief Returns the maximum possible number of elements.
     * @return Maximum possible number of elements.
     */
    [[nodiscard]] size_type max_size() const noexcept {
        return packed.first().max_size();
    }

    /*! @brief Clears the container. */
    void clear() noexcept {
        sparse.first().clear();
        packed.first().clear();
        rehash(0u);
    }

    /**
     * @brief Inserts an element into the container, if the key does not exist.
     * @param value A key-value pair eventually convertible to the value type.
     * @return A pair consisting of an iterator to the inserted element (or to
     * the element that prevented the insertion) and a bool denoting whether the
     * insertion took place.
     */
    std::pair<iterator, bool> insert(const value_type &value) {
        return insert_or_do_nothing(value.first, value.second);
    }

    /*! @copydoc insert */
    std::pair<iterator, bool> insert(value_type &&value) {
        return insert_or_do_nothing(std::move(value.first), std::move(value.second));
    }

    /**
     * @copydoc insert
     * @tparam Arg Type of the key-value pair to insert into the container.
     */
    template<typename Arg>
    std::enable_if_t<std::is_constructible_v<value_type, Arg &&>, std::pair<iterator, bool>>
    insert(Arg &&value) {
        return insert_or_do_nothing(std::forward<Arg>(value).first, std::forward<Arg>(value).second);
    }

    /**
     * @brief Inserts elements into the container, if their keys do not exist.
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of elements.
     * @param last An iterator past the last element of the range of elements.
     */
    template<typename It>
    void insert(It first, It last) {
        for(; first != last; ++first) {
            insert(*first);
        }
    }

    /**
     * @brief Inserts an element into the container or assigns to the current
     * element if the key already exists.
     * @tparam Arg Type of the value to insert or assign.
     * @param key A key used both to look up and to insert if not found.
     * @param value A value to insert or assign.
     * @return A pair consisting of an iterator to the element and a bool
     * denoting whether the insertion took place.
     */
    template<typename Arg>
    std::pair<iterator, bool> insert_or_assign(const key_type &key, Arg &&value) {
        return insert_or_overwrite(key, std::forward<Arg>(value));
    }

    /*! @copydoc insert_or_assign */
    template<typename Arg>
    std::pair<iterator, bool> insert_or_assign(key_type &&key, Arg &&value) {
        return insert_or_overwrite(std::move(key), std::forward<Arg>(value));
    }

    /**
     * @brief Constructs an element in-place, if the key does not exist.
     *
     * The element is also constructed when the container already has the key,
     * in which case the newly constructed object is destroyed immediately.
     *
     * @tparam Args Types of arguments to forward to the constructor of the
     * element.
     * @param args Arguments to forward to the constructor of the element.
     * @return A pair consisting of an iterator to the inserted element (or to
     * the element that prevented the insertion) and a bool denoting whether the
     * insertion took place.
     */
    template<typename... Args>
    std::pair<iterator, bool> emplace([[maybe_unused]] Args &&...args) {
        if constexpr(sizeof...(Args) == 0u) {
            return insert_or_do_nothing(key_type{});
        } else if constexpr(sizeof...(Args) == 1u) {
            return insert_or_do_nothing(std::forward<Args>(args).first..., std::forward<Args>(args).second...);
        } else if constexpr(sizeof...(Args) == 2u) {
            return insert_or_do_nothing(std::forward<Args>(args)...);
        } else {
            auto &node = packed.first().emplace_back(packed.first().size(), std::forward<Args>(args)...);
            const auto index = key_to_bucket(node.element.first);

            if(auto it = constrained_find(node.element.first, index); it != end()) {
                packed.first().pop_back();
                return std::make_pair(it, false);
            }

            std::swap(node.next, sparse.first()[index]);
            rehash_if_required();

            return std::make_pair(--end(), true);
        }
    }

    /**
     * @brief Inserts in-place if the key does not exist, does nothing if the
     * key exists.
     * @tparam Args Types of arguments to forward to the constructor of the
     * element.
     * @param key A key used both to look up and to insert if not found.
     * @param args Arguments to forward to the constructor of the element.
     * @return A pair consisting of an iterator to the inserted element (or to
     * the element that prevented the insertion) and a bool denoting whether the
     * insertion took place.
     */
    template<typename... Args>
    std::pair<iterator, bool> try_emplace(const key_type &key, Args &&...args) {
        return insert_or_do_nothing(key, std::forward<Args>(args)...);
    }

    /*! @copydoc try_emplace */
    template<typename... Args>
    std::pair<iterator, bool> try_emplace(key_type &&key, Args &&...args) {
        return insert_or_do_nothing(std::move(key), std::forward<Args>(args)...);
    }

    /**
     * @brief Removes an element from a given position.
     * @param pos An iterator to the element to remove.
     * @return An iterator following the removed element.
     */
    iterator erase(const_iterator pos) {
        const auto diff = pos - cbegin();
        erase(pos->first);
        return begin() + diff;
    }

    /**
     * @brief Removes the given elements from a container.
     * @param first An iterator to the first element of the range of elements.
     * @param last An iterator past the last element of the range of elements.
     * @return An iterator following the last removed element.
     */
    iterator erase(const_iterator first, const_iterator last) {
        const auto dist = first - cbegin();

        for(auto from = last - cbegin(); from != dist; --from) {
            erase(packed.first()[from - 1u].element.first);
        }

        return (begin() + dist);
    }

    /**
     * @brief Removes the element associated with a given key.
     * @param key A key value of an element to remove.
     * @return Number of elements removed (either 0 or 1).
     */
    size_type erase(const key_type &key) {
        for(size_type *curr = sparse.first().data() + key_to_bucket(key); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].next) {
            if(packed.second()(packed.first()[*curr].element.first, key)) {
                const auto index = *curr;
                *curr = packed.first()[*curr].next;
                move_and_pop(index);
                return 1u;
            }
        }

        return 0u;
    }

    /**
     * @brief Exchanges the contents with those of a given container.
     * @param other Container to exchange the content with.
     */
    void swap(dense_map &other) {
        using std::swap;
        swap(sparse, other.sparse);
        swap(packed, other.packed);
        swap(threshold, other.threshold);
    }

    /**
     * @brief Accesses a given element with bounds checking.
     * @param key A key of an element to find.
     * @return A reference to the mapped value of the requested element.
     */
    [[nodiscard]] mapped_type &at(const key_type &key) {
        auto it = find(key);
        ENTT_ASSERT(it != end(), "Invalid key");
        return it->second;
    }

    /*! @copydoc at */
    [[nodiscard]] const mapped_type &at(const key_type &key) const {
        auto it = find(key);
        ENTT_ASSERT(it != cend(), "Invalid key");
        return it->second;
    }

    /**
     * @brief Accesses or inserts a given element.
     * @param key A key of an element to find or insert.
     * @return A reference to the mapped value of the requested element.
     */
    [[nodiscard]] mapped_type &operator[](const key_type &key) {
        return insert_or_do_nothing(key).first->second;
    }

    /**
     * @brief Accesses or inserts a given element.
     * @param key A key of an element to find or insert.
     * @return A reference to the mapped value of the requested element.
     */
    [[nodiscard]] mapped_type &operator[](key_type &&key) {
        return insert_or_do_nothing(std::move(key)).first->second;
    }

    /**
     * @brief Returns the number of elements matching a key (either 1 or 0).
     * @param key Key value of an element to search for.
     * @return Number of elements matching the key (either 1 or 0).
     */
    [[nodiscard]] size_type count(const key_type &key) const {
        return find(key) != end();
    }

    /**
     * @brief Returns the number of elements matching a key (either 1 or 0).
     * @tparam Other Type of the key value of an element to search for.
     * @param key Key value of an element to search for.
     * @return Number of elements matching the key (either 1 or 0).
     */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, size_type>>
    count(const Other &key) const {
        return find(key) != end();
    }

    /**
     * @brief Finds an element with a given key.
     * @param key Key value of an element to search for.
     * @return An iterator to an element with the given key. If no such element
     * is found, a past-the-end iterator is returned.
     */
    [[nodiscard]] iterator find(const key_type &key) {
        return constrained_find(key, key_to_bucket(key));
    }

    /*! @copydoc find */
    [[nodiscard]] const_iterator find(const key_type &key) const {
        return constrained_find(key, key_to_bucket(key));
    }

    /**
     * @brief Finds an element with a key that compares _equivalent_ to a given
     * key.
     * @tparam Other Type of the key value of an element to search for.
     * @param key Key value of an element to search for.
     * @return An iterator to an element with the given key. If no such element
     * is found, a past-the-end iterator is returned.
     */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, iterator>>
    find(const Other &key) {
        return constrained_find(key, key_to_bucket(key));
    }

    /*! @copydoc find */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, const_iterator>>
    find(const Other &key) const {
        return constrained_find(key, key_to_bucket(key));
    }

    /**
     * @brief Returns a range containing all elements with a given key.
     * @param key Key value of an element to search for.
     * @return A pair of iterators pointing to the first element and past the
     * last element of the range.
     */
    [[nodiscard]] std::pair<iterator, iterator> equal_range(const key_type &key) {
        const auto it = find(key);
        return {it, it + !(it == end())};
    }

    /*! @copydoc equal_range */
    [[nodiscard]] std::pair<const_iterator, const_iterator> equal_range(const key_type &key) const {
        const auto it = find(key);
        return {it, it + !(it == cend())};
    }

    /**
     * @brief Returns a range containing all elements that compare _equivalent_
     * to a given key.
     * @tparam Other Type of an element to search for.
     * @param key Key value of an element to search for.
     * @return A pair of iterators pointing to the first element and past the
     * last element of the range.
     */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, std::pair<iterator, iterator>>>
    equal_range(const Other &key) {
        const auto it = find(key);
        return {it, it + !(it == end())};
    }

    /*! @copydoc equal_range */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, std::pair<const_iterator, const_iterator>>>
    equal_range(const Other &key) const {
        const auto it = find(key);
        return {it, it + !(it == cend())};
    }

    /**
     * @brief Checks if the container contains an element with a given key.
     * @param key Key value of an element to search for.
     * @return True if there is such an element, false otherwise.
     */
    [[nodiscard]] bool contains(const key_type &key) const {
        return (find(key) != cend());
    }

    /**
     * @brief Checks if the container contains an element with a key that
     * compares _equivalent_ to a given value.
     * @tparam Other Type of the key value of an element to search for.
     * @param key Key value of an element to search for.
     * @return True if there is such an element, false otherwise.
     */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, bool>>
    contains(const Other &key) const {
        return (find(key) != cend());
    }

    /**
     * @brief Returns an iterator to the beginning of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the beginning of the given bucket.
     */
    [[nodiscard]] const_local_iterator cbegin(const size_type index) const {
        return {packed.first().begin(), sparse.first()[index]};
    }

    /**
     * @brief Returns an iterator to the beginning of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the beginning of the given bucket.
     */
    [[nodiscard]] const_local_iterator begin(const size_type index) const {
        return cbegin(index);
    }

    /**
     * @brief Returns an iterator to the beginning of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the beginning of the given bucket.
     */
    [[nodiscard]] local_iterator begin(const size_type index) {
        return {packed.first().begin(), sparse.first()[index]};
    }

    /**
     * @brief Returns an iterator to the end of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the end of the given bucket.
     */
    [[nodiscard]] const_local_iterator cend([[maybe_unused]] const size_type index) const {
        return {packed.first().begin(), (std::numeric_limits<size_type>::max)()};
    }

    /**
     * @brief Returns an iterator to the end of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the end of the given bucket.
     */
    [[nodiscard]] const_local_iterator end(const size_type index) const {
        return cend(index);
    }

    /**
     * @brief Returns an iterator to the end of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the end of the given bucket.
     */
    [[nodiscard]] local_iterator end([[maybe_unused]] const size_type index) {
        return {packed.first().begin(), (std::numeric_limits<size_type>::max)()};
    }

    /**
     * @brief Returns the number of buckets.
     * @return The number of buckets.
     */
    [[nodiscard]] size_type bucket_count() const {
        return sparse.first().size();
    }

    /**
     * @brief Returns the maximum number of buckets.
     * @return The maximum number of buckets.
     */
    [[nodiscard]] size_type max_bucket_count() const {
        return sparse.first().max_size();
    }

    /**
     * @brief Returns the number of elements in a given bucket.
     * @param index The index of the bucket to examine.
     * @return The number of elements in the given bucket.
     */
    [[nodiscard]] size_type bucket_size(const size_type index) const {
        return static_cast<size_type>(std::distance(begin(index), end(index)));
    }

    /**
     * @brief Returns the bucket for a given key.
     * @param key The value of the key to examine.
     * @return The bucket for the given key.
     */
    [[nodiscard]] size_type bucket(const key_type &key) const {
        return key_to_bucket(key);
    }

    /**
     * @brief Returns the average number of elements per bucket.
     * @return The average number of elements per bucket.
     */
    [[nodiscard]] float load_factor() const {
        return size() / static_cast<float>(bucket_count());
    }

    /**
     * @brief Returns the maximum average number of elements per bucket.
     * @return The maximum average number of elements per bucket.
     */
    [[nodiscard]] float max_load_factor() const {
        return threshold;
    }

    /**
     * @brief Sets the desired maximum average number of elements per bucket.
     * @param value A desired maximum average number of elements per bucket.
     */
    void max_load_factor(const float value) {
        ENTT_ASSERT(value > 0.f, "Invalid load factor");
        threshold = value;
        rehash(0u);
    }

    /**
     * @brief Reserves at least the specified number of buckets and regenerates
     * the hash table.
     * @param cnt New number of buckets.
     */
    void rehash(const size_type cnt) {
        auto value = cnt > minimum_capacity ? cnt : minimum_capacity;
        const auto cap = static_cast<size_type>(size() / max_load_factor());
        value = value > cap ? value : cap;

        if(const auto sz = next_power_of_two(value); sz != bucket_count()) {
            sparse.first().resize(sz);

            for(auto &&elem: sparse.first()) {
                elem = std::numeric_limits<size_type>::max();
            }

            for(size_type pos{}, last = size(); pos < last; ++pos) {
                const auto index = key_to_bucket(packed.first()[pos].element.first);
                packed.first()[pos].next = std::exchange(sparse.first()[index], pos);
            }
        }
    }

    /**
     * @brief Reserves space for at least the specified number of elements and
     * regenerates the hash table.
     * @param cnt New number of elements.
     */
    void reserve(const size_type cnt) {
        packed.first().reserve(cnt);
        rehash(static_cast<size_type>(std::ceil(cnt / max_load_factor())));
    }

    /**
     * @brief Returns the function used to hash the keys.
     * @return The function used to hash the keys.
     */
    [[nodiscard]] hasher hash_function() const {
        return sparse.second();
    }

    /**
     * @brief Returns the function used to compare keys for equality.
     * @return The function used to compare keys for equality.
     */
    [[nodiscard]] key_equal key_eq() const {
        return packed.second();
    }

private:
    compressed_pair<sparse_container_type, hasher> sparse;
    compressed_pair<packed_container_type, key_equal> packed;
    float threshold;
};

} // namespace entt

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace std {

template<typename Key, typename Value, typename Allocator>
struct uses_allocator<entt::internal::dense_map_node<Key, Value>, Allocator>
    : std::true_type {};

} // namespace std

/**
 * Internal details not to be documented.
 * @endcond
 */

#endif

///////////////// END OF external/entt/container/dense_map.hpp /////////////////

//////////////// START OF external/entt/container/dense_set.hpp ////////////////

#ifndef ENTT_CONTAINER_DENSE_SET_HPP
#define ENTT_CONTAINER_DENSE_SET_HPP

#include <cmath>
#include <cstddef>
#include <functional>
#include <iterator>
#include <limits>
#include <memory>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename It>
class dense_set_iterator final {
    template<typename>
    friend class dense_set_iterator;

public:
    using value_type = typename It::value_type::second_type;
    using pointer = const value_type *;
    using reference = const value_type &;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::random_access_iterator_tag;

    constexpr dense_set_iterator() noexcept
        : it{} {}

    constexpr dense_set_iterator(const It iter) noexcept
        : it{iter} {}

    template<typename Other, typename = std::enable_if_t<!std::is_same_v<It, Other> && std::is_constructible_v<It, Other>>>
    constexpr dense_set_iterator(const dense_set_iterator<Other> &other) noexcept
        : it{other.it} {}

    constexpr dense_set_iterator &operator++() noexcept {
        return ++it, *this;
    }

    constexpr dense_set_iterator operator++(int) noexcept {
        dense_set_iterator orig = *this;
        return ++(*this), orig;
    }

    constexpr dense_set_iterator &operator--() noexcept {
        return --it, *this;
    }

    constexpr dense_set_iterator operator--(int) noexcept {
        dense_set_iterator orig = *this;
        return operator--(), orig;
    }

    constexpr dense_set_iterator &operator+=(const difference_type value) noexcept {
        it += value;
        return *this;
    }

    constexpr dense_set_iterator operator+(const difference_type value) const noexcept {
        dense_set_iterator copy = *this;
        return (copy += value);
    }

    constexpr dense_set_iterator &operator-=(const difference_type value) noexcept {
        return (*this += -value);
    }

    constexpr dense_set_iterator operator-(const difference_type value) const noexcept {
        return (*this + -value);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
        return it[value].second;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return std::addressof(it->second);
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *operator->();
    }

    template<typename Lhs, typename Rhs>
    friend constexpr std::ptrdiff_t operator-(const dense_set_iterator<Lhs> &, const dense_set_iterator<Rhs> &) noexcept;

    template<typename Lhs, typename Rhs>
    friend constexpr bool operator==(const dense_set_iterator<Lhs> &, const dense_set_iterator<Rhs> &) noexcept;

    template<typename Lhs, typename Rhs>
    friend constexpr bool operator<(const dense_set_iterator<Lhs> &, const dense_set_iterator<Rhs> &) noexcept;

private:
    It it;
};

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr std::ptrdiff_t operator-(const dense_set_iterator<Lhs> &lhs, const dense_set_iterator<Rhs> &rhs) noexcept {
    return lhs.it - rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator==(const dense_set_iterator<Lhs> &lhs, const dense_set_iterator<Rhs> &rhs) noexcept {
    return lhs.it == rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator!=(const dense_set_iterator<Lhs> &lhs, const dense_set_iterator<Rhs> &rhs) noexcept {
    return !(lhs == rhs);
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator<(const dense_set_iterator<Lhs> &lhs, const dense_set_iterator<Rhs> &rhs) noexcept {
    return lhs.it < rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator>(const dense_set_iterator<Lhs> &lhs, const dense_set_iterator<Rhs> &rhs) noexcept {
    return rhs < lhs;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator<=(const dense_set_iterator<Lhs> &lhs, const dense_set_iterator<Rhs> &rhs) noexcept {
    return !(lhs > rhs);
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator>=(const dense_set_iterator<Lhs> &lhs, const dense_set_iterator<Rhs> &rhs) noexcept {
    return !(lhs < rhs);
}

template<typename It>
class dense_set_local_iterator final {
    template<typename>
    friend class dense_set_local_iterator;

public:
    using value_type = typename It::value_type::second_type;
    using pointer = const value_type *;
    using reference = const value_type &;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::forward_iterator_tag;

    constexpr dense_set_local_iterator() noexcept
        : it{},
          offset{} {}

    constexpr dense_set_local_iterator(It iter, const std::size_t pos) noexcept
        : it{iter},
          offset{pos} {}

    template<typename Other, typename = std::enable_if_t<!std::is_same_v<It, Other> && std::is_constructible_v<It, Other>>>
    constexpr dense_set_local_iterator(const dense_set_local_iterator<Other> &other) noexcept
        : it{other.it},
          offset{other.offset} {}

    constexpr dense_set_local_iterator &operator++() noexcept {
        return offset = it[offset].first, *this;
    }

    constexpr dense_set_local_iterator operator++(int) noexcept {
        dense_set_local_iterator orig = *this;
        return ++(*this), orig;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return std::addressof(it[offset].second);
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *operator->();
    }

    [[nodiscard]] constexpr std::size_t index() const noexcept {
        return offset;
    }

private:
    It it;
    std::size_t offset;
};

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator==(const dense_set_local_iterator<Lhs> &lhs, const dense_set_local_iterator<Rhs> &rhs) noexcept {
    return lhs.index() == rhs.index();
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator!=(const dense_set_local_iterator<Lhs> &lhs, const dense_set_local_iterator<Rhs> &rhs) noexcept {
    return !(lhs == rhs);
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Associative container for unique objects of a given type.
 *
 * Internally, elements are organized into buckets. Which bucket an element is
 * placed into depends entirely on its hash. Elements with the same hash code
 * appear in the same bucket.
 *
 * @tparam Type Value type of the associative container.
 * @tparam Hash Type of function to use to hash the values.
 * @tparam KeyEqual Type of function to use to compare the values for equality.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Type, typename Hash, typename KeyEqual, typename Allocator>
class dense_set {
    static constexpr float default_threshold = 0.875f;
    static constexpr std::size_t minimum_capacity = 8u;

    using node_type = std::pair<std::size_t, Type>;
    using alloc_traits = std::allocator_traits<Allocator>;
    static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");
    using sparse_container_type = std::vector<std::size_t, typename alloc_traits::template rebind_alloc<std::size_t>>;
    using packed_container_type = std::vector<node_type, typename alloc_traits::template rebind_alloc<node_type>>;

    template<typename Other>
    [[nodiscard]] std::size_t value_to_bucket(const Other &value) const noexcept {
        return fast_mod(static_cast<size_type>(sparse.second()(value)), bucket_count());
    }

    template<typename Other>
    [[nodiscard]] auto constrained_find(const Other &value, std::size_t bucket) {
        for(auto it = begin(bucket), last = end(bucket); it != last; ++it) {
            if(packed.second()(*it, value)) {
                return begin() + static_cast<typename iterator::difference_type>(it.index());
            }
        }

        return end();
    }

    template<typename Other>
    [[nodiscard]] auto constrained_find(const Other &value, std::size_t bucket) const {
        for(auto it = cbegin(bucket), last = cend(bucket); it != last; ++it) {
            if(packed.second()(*it, value)) {
                return cbegin() + static_cast<typename iterator::difference_type>(it.index());
            }
        }

        return cend();
    }

    template<typename Other>
    [[nodiscard]] auto insert_or_do_nothing(Other &&value) {
        const auto index = value_to_bucket(value);

        if(auto it = constrained_find(value, index); it != end()) {
            return std::make_pair(it, false);
        }

        packed.first().emplace_back(sparse.first()[index], std::forward<Other>(value));
        sparse.first()[index] = packed.first().size() - 1u;
        rehash_if_required();

        return std::make_pair(--end(), true);
    }

    void move_and_pop(const std::size_t pos) {
        if(const auto last = size() - 1u; pos != last) {
            size_type *curr = sparse.first().data() + value_to_bucket(packed.first().back().second);
            packed.first()[pos] = std::move(packed.first().back());
            for(; *curr != last; curr = &packed.first()[*curr].first) {}
            *curr = pos;
        }

        packed.first().pop_back();
    }

    void rehash_if_required() {
        if(size() > (bucket_count() * max_load_factor())) {
            rehash(bucket_count() * 2u);
        }
    }

public:
    /*! @brief Key type of the container. */
    using key_type = Type;
    /*! @brief Value type of the container. */
    using value_type = Type;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Type of function to use to hash the elements. */
    using hasher = Hash;
    /*! @brief Type of function to use to compare the elements for equality. */
    using key_equal = KeyEqual;
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Random access iterator type. */
    using iterator = internal::dense_set_iterator<typename packed_container_type::iterator>;
    /*! @brief Constant random access iterator type. */
    using const_iterator = internal::dense_set_iterator<typename packed_container_type::const_iterator>;
    /*! @brief Forward iterator type. */
    using local_iterator = internal::dense_set_local_iterator<typename packed_container_type::iterator>;
    /*! @brief Constant forward iterator type. */
    using const_local_iterator = internal::dense_set_local_iterator<typename packed_container_type::const_iterator>;

    /*! @brief Default constructor. */
    dense_set()
        : dense_set{minimum_capacity} {}

    /**
     * @brief Constructs an empty container with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit dense_set(const allocator_type &allocator)
        : dense_set{minimum_capacity, hasher{}, key_equal{}, allocator} {}

    /**
     * @brief Constructs an empty container with a given allocator and user
     * supplied minimal number of buckets.
     * @param cnt Minimal number of buckets.
     * @param allocator The allocator to use.
     */
    dense_set(const size_type cnt, const allocator_type &allocator)
        : dense_set{cnt, hasher{}, key_equal{}, allocator} {}

    /**
     * @brief Constructs an empty container with a given allocator, hash
     * function and user supplied minimal number of buckets.
     * @param cnt Minimal number of buckets.
     * @param hash Hash function to use.
     * @param allocator The allocator to use.
     */
    dense_set(const size_type cnt, const hasher &hash, const allocator_type &allocator)
        : dense_set{cnt, hash, key_equal{}, allocator} {}

    /**
     * @brief Constructs an empty container with a given allocator, hash
     * function, compare function and user supplied minimal number of buckets.
     * @param cnt Minimal number of buckets.
     * @param hash Hash function to use.
     * @param equal Compare function to use.
     * @param allocator The allocator to use.
     */
    explicit dense_set(const size_type cnt, const hasher &hash = hasher{}, const key_equal &equal = key_equal{}, const allocator_type &allocator = allocator_type{})
        : sparse{allocator, hash},
          packed{allocator, equal},
          threshold{default_threshold} {
        rehash(cnt);
    }

    /*! @brief Default copy constructor. */
    dense_set(const dense_set &) = default;

    /**
     * @brief Allocator-extended copy constructor.
     * @param other The instance to copy from.
     * @param allocator The allocator to use.
     */
    dense_set(const dense_set &other, const allocator_type &allocator)
        : sparse{std::piecewise_construct, std::forward_as_tuple(other.sparse.first(), allocator), std::forward_as_tuple(other.sparse.second())},
          packed{std::piecewise_construct, std::forward_as_tuple(other.packed.first(), allocator), std::forward_as_tuple(other.packed.second())},
          threshold{other.threshold} {}

    /*! @brief Default move constructor. */
    dense_set(dense_set &&) noexcept(std::is_nothrow_move_constructible_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_constructible_v<compressed_pair<packed_container_type, key_equal>>) = default;

    /**
     * @brief Allocator-extended move constructor.
     * @param other The instance to move from.
     * @param allocator The allocator to use.
     */
    dense_set(dense_set &&other, const allocator_type &allocator)
        : sparse{std::piecewise_construct, std::forward_as_tuple(std::move(other.sparse.first()), allocator), std::forward_as_tuple(std::move(other.sparse.second()))},
          packed{std::piecewise_construct, std::forward_as_tuple(std::move(other.packed.first()), allocator), std::forward_as_tuple(std::move(other.packed.second()))},
          threshold{other.threshold} {}

    /**
     * @brief Default copy assignment operator.
     * @return This container.
     */
    dense_set &operator=(const dense_set &) = default;

    /**
     * @brief Default move assignment operator.
     * @return This container.
     */
    dense_set &operator=(dense_set &&) noexcept(std::is_nothrow_move_assignable_v<compressed_pair<sparse_container_type, hasher>> &&std::is_nothrow_move_assignable_v<compressed_pair<packed_container_type, key_equal>>) = default;

    /**
     * @brief Returns the associated allocator.
     * @return The associated allocator.
     */
    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return sparse.first().get_allocator();
    }

    /**
     * @brief Returns an iterator to the beginning.
     *
     * If the array is empty, the returned iterator will be equal to `end()`.
     *
     * @return An iterator to the first instance of the internal array.
     */
    [[nodiscard]] const_iterator cbegin() const noexcept {
        return packed.first().begin();
    }

    /*! @copydoc cbegin */
    [[nodiscard]] const_iterator begin() const noexcept {
        return cbegin();
    }

    /*! @copydoc begin */
    [[nodiscard]] iterator begin() noexcept {
        return packed.first().begin();
    }

    /**
     * @brief Returns an iterator to the end.
     * @return An iterator to the element following the last instance of the
     * internal array.
     */
    [[nodiscard]] const_iterator cend() const noexcept {
        return packed.first().end();
    }

    /*! @copydoc cend */
    [[nodiscard]] const_iterator end() const noexcept {
        return cend();
    }

    /*! @copydoc end */
    [[nodiscard]] iterator end() noexcept {
        return packed.first().end();
    }

    /**
     * @brief Checks whether a container is empty.
     * @return True if the container is empty, false otherwise.
     */
    [[nodiscard]] bool empty() const noexcept {
        return packed.first().empty();
    }

    /**
     * @brief Returns the number of elements in a container.
     * @return Number of elements in a container.
     */
    [[nodiscard]] size_type size() const noexcept {
        return packed.first().size();
    }

    /**
     * @brief Returns the maximum possible number of elements.
     * @return Maximum possible number of elements.
     */
    [[nodiscard]] size_type max_size() const noexcept {
        return packed.first().max_size();
    }

    /*! @brief Clears the container. */
    void clear() noexcept {
        sparse.first().clear();
        packed.first().clear();
        rehash(0u);
    }

    /**
     * @brief Inserts an element into the container, if it does not exist.
     * @param value An element to insert into the container.
     * @return A pair consisting of an iterator to the inserted element (or to
     * the element that prevented the insertion) and a bool denoting whether the
     * insertion took place.
     */
    std::pair<iterator, bool> insert(const value_type &value) {
        return insert_or_do_nothing(value);
    }

    /*! @copydoc insert */
    std::pair<iterator, bool> insert(value_type &&value) {
        return insert_or_do_nothing(std::move(value));
    }

    /**
     * @brief Inserts elements into the container, if they do not exist.
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of elements.
     * @param last An iterator past the last element of the range of elements.
     */
    template<typename It>
    void insert(It first, It last) {
        for(; first != last; ++first) {
            insert(*first);
        }
    }

    /**
     * @brief Constructs an element in-place, if it does not exist.
     *
     * The element is also constructed when the container already has the key,
     * in which case the newly constructed object is destroyed immediately.
     *
     * @tparam Args Types of arguments to forward to the constructor of the
     * element.
     * @param args Arguments to forward to the constructor of the element.
     * @return A pair consisting of an iterator to the inserted element (or to
     * the element that prevented the insertion) and a bool denoting whether the
     * insertion took place.
     */
    template<typename... Args>
    std::pair<iterator, bool> emplace(Args &&...args) {
        if constexpr(((sizeof...(Args) == 1u) && ... && std::is_same_v<std::decay_t<Args>, value_type>)) {
            return insert_or_do_nothing(std::forward<Args>(args)...);
        } else {
            auto &node = packed.first().emplace_back(std::piecewise_construct, std::make_tuple(packed.first().size()), std::forward_as_tuple(std::forward<Args>(args)...));
            const auto index = value_to_bucket(node.second);

            if(auto it = constrained_find(node.second, index); it != end()) {
                packed.first().pop_back();
                return std::make_pair(it, false);
            }

            std::swap(node.first, sparse.first()[index]);
            rehash_if_required();

            return std::make_pair(--end(), true);
        }
    }

    /**
     * @brief Removes an element from a given position.
     * @param pos An iterator to the element to remove.
     * @return An iterator following the removed element.
     */
    iterator erase(const_iterator pos) {
        const auto diff = pos - cbegin();
        erase(*pos);
        return begin() + diff;
    }

    /**
     * @brief Removes the given elements from a container.
     * @param first An iterator to the first element of the range of elements.
     * @param last An iterator past the last element of the range of elements.
     * @return An iterator following the last removed element.
     */
    iterator erase(const_iterator first, const_iterator last) {
        const auto dist = first - cbegin();

        for(auto from = last - cbegin(); from != dist; --from) {
            erase(packed.first()[from - 1u].second);
        }

        return (begin() + dist);
    }

    /**
     * @brief Removes the element associated with a given value.
     * @param value Value of an element to remove.
     * @return Number of elements removed (either 0 or 1).
     */
    size_type erase(const value_type &value) {
        for(size_type *curr = sparse.first().data() + value_to_bucket(value); *curr != (std::numeric_limits<size_type>::max)(); curr = &packed.first()[*curr].first) {
            if(packed.second()(packed.first()[*curr].second, value)) {
                const auto index = *curr;
                *curr = packed.first()[*curr].first;
                move_and_pop(index);
                return 1u;
            }
        }

        return 0u;
    }

    /**
     * @brief Exchanges the contents with those of a given container.
     * @param other Container to exchange the content with.
     */
    void swap(dense_set &other) {
        using std::swap;
        swap(sparse, other.sparse);
        swap(packed, other.packed);
        swap(threshold, other.threshold);
    }

    /**
     * @brief Returns the number of elements matching a value (either 1 or 0).
     * @param key Key value of an element to search for.
     * @return Number of elements matching the key (either 1 or 0).
     */
    [[nodiscard]] size_type count(const value_type &key) const {
        return find(key) != end();
    }

    /**
     * @brief Returns the number of elements matching a key (either 1 or 0).
     * @tparam Other Type of the key value of an element to search for.
     * @param key Key value of an element to search for.
     * @return Number of elements matching the key (either 1 or 0).
     */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, size_type>>
    count(const Other &key) const {
        return find(key) != end();
    }

    /**
     * @brief Finds an element with a given value.
     * @param value Value of an element to search for.
     * @return An iterator to an element with the given value. If no such
     * element is found, a past-the-end iterator is returned.
     */
    [[nodiscard]] iterator find(const value_type &value) {
        return constrained_find(value, value_to_bucket(value));
    }

    /*! @copydoc find */
    [[nodiscard]] const_iterator find(const value_type &value) const {
        return constrained_find(value, value_to_bucket(value));
    }

    /**
     * @brief Finds an element that compares _equivalent_ to a given value.
     * @tparam Other Type of an element to search for.
     * @param value Value of an element to search for.
     * @return An iterator to an element with the given value. If no such
     * element is found, a past-the-end iterator is returned.
     */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, iterator>>
    find(const Other &value) {
        return constrained_find(value, value_to_bucket(value));
    }

    /*! @copydoc find */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, const_iterator>>
    find(const Other &value) const {
        return constrained_find(value, value_to_bucket(value));
    }

    /**
     * @brief Returns a range containing all elements with a given value.
     * @param value Value of an element to search for.
     * @return A pair of iterators pointing to the first element and past the
     * last element of the range.
     */
    [[nodiscard]] std::pair<iterator, iterator> equal_range(const value_type &value) {
        const auto it = find(value);
        return {it, it + !(it == end())};
    }

    /*! @copydoc equal_range */
    [[nodiscard]] std::pair<const_iterator, const_iterator> equal_range(const value_type &value) const {
        const auto it = find(value);
        return {it, it + !(it == cend())};
    }

    /**
     * @brief Returns a range containing all elements that compare _equivalent_
     * to a given value.
     * @tparam Other Type of an element to search for.
     * @param value Value of an element to search for.
     * @return A pair of iterators pointing to the first element and past the
     * last element of the range.
     */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, std::pair<iterator, iterator>>>
    equal_range(const Other &value) {
        const auto it = find(value);
        return {it, it + !(it == end())};
    }

    /*! @copydoc equal_range */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, std::pair<const_iterator, const_iterator>>>
    equal_range(const Other &value) const {
        const auto it = find(value);
        return {it, it + !(it == cend())};
    }

    /**
     * @brief Checks if the container contains an element with a given value.
     * @param value Value of an element to search for.
     * @return True if there is such an element, false otherwise.
     */
    [[nodiscard]] bool contains(const value_type &value) const {
        return (find(value) != cend());
    }

    /**
     * @brief Checks if the container contains an element that compares
     * _equivalent_ to a given value.
     * @tparam Other Type of an element to search for.
     * @param value Value of an element to search for.
     * @return True if there is such an element, false otherwise.
     */
    template<typename Other>
    [[nodiscard]] std::enable_if_t<is_transparent_v<hasher> && is_transparent_v<key_equal>, std::conditional_t<false, Other, bool>>
    contains(const Other &value) const {
        return (find(value) != cend());
    }

    /**
     * @brief Returns an iterator to the beginning of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the beginning of the given bucket.
     */
    [[nodiscard]] const_local_iterator cbegin(const size_type index) const {
        return {packed.first().begin(), sparse.first()[index]};
    }

    /**
     * @brief Returns an iterator to the beginning of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the beginning of the given bucket.
     */
    [[nodiscard]] const_local_iterator begin(const size_type index) const {
        return cbegin(index);
    }

    /**
     * @brief Returns an iterator to the beginning of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the beginning of the given bucket.
     */
    [[nodiscard]] local_iterator begin(const size_type index) {
        return {packed.first().begin(), sparse.first()[index]};
    }

    /**
     * @brief Returns an iterator to the end of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the end of the given bucket.
     */
    [[nodiscard]] const_local_iterator cend([[maybe_unused]] const size_type index) const {
        return {packed.first().begin(), (std::numeric_limits<size_type>::max)()};
    }

    /**
     * @brief Returns an iterator to the end of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the end of the given bucket.
     */
    [[nodiscard]] const_local_iterator end(const size_type index) const {
        return cend(index);
    }

    /**
     * @brief Returns an iterator to the end of a given bucket.
     * @param index An index of a bucket to access.
     * @return An iterator to the end of the given bucket.
     */
    [[nodiscard]] local_iterator end([[maybe_unused]] const size_type index) {
        return {packed.first().begin(), (std::numeric_limits<size_type>::max)()};
    }

    /**
     * @brief Returns the number of buckets.
     * @return The number of buckets.
     */
    [[nodiscard]] size_type bucket_count() const {
        return sparse.first().size();
    }

    /**
     * @brief Returns the maximum number of buckets.
     * @return The maximum number of buckets.
     */
    [[nodiscard]] size_type max_bucket_count() const {
        return sparse.first().max_size();
    }

    /**
     * @brief Returns the number of elements in a given bucket.
     * @param index The index of the bucket to examine.
     * @return The number of elements in the given bucket.
     */
    [[nodiscard]] size_type bucket_size(const size_type index) const {
        return static_cast<size_type>(std::distance(begin(index), end(index)));
    }

    /**
     * @brief Returns the bucket for a given element.
     * @param value The value of the element to examine.
     * @return The bucket for the given element.
     */
    [[nodiscard]] size_type bucket(const value_type &value) const {
        return value_to_bucket(value);
    }

    /**
     * @brief Returns the average number of elements per bucket.
     * @return The average number of elements per bucket.
     */
    [[nodiscard]] float load_factor() const {
        return size() / static_cast<float>(bucket_count());
    }

    /**
     * @brief Returns the maximum average number of elements per bucket.
     * @return The maximum average number of elements per bucket.
     */
    [[nodiscard]] float max_load_factor() const {
        return threshold;
    }

    /**
     * @brief Sets the desired maximum average number of elements per bucket.
     * @param value A desired maximum average number of elements per bucket.
     */
    void max_load_factor(const float value) {
        ENTT_ASSERT(value > 0.f, "Invalid load factor");
        threshold = value;
        rehash(0u);
    }

    /**
     * @brief Reserves at least the specified number of buckets and regenerates
     * the hash table.
     * @param cnt New number of buckets.
     */
    void rehash(const size_type cnt) {
        auto value = cnt > minimum_capacity ? cnt : minimum_capacity;
        const auto cap = static_cast<size_type>(size() / max_load_factor());
        value = value > cap ? value : cap;

        if(const auto sz = next_power_of_two(value); sz != bucket_count()) {
            sparse.first().resize(sz);

            for(auto &&elem: sparse.first()) {
                elem = std::numeric_limits<size_type>::max();
            }

            for(size_type pos{}, last = size(); pos < last; ++pos) {
                const auto index = value_to_bucket(packed.first()[pos].second);
                packed.first()[pos].first = std::exchange(sparse.first()[index], pos);
            }
        }
    }

    /**
     * @brief Reserves space for at least the specified number of elements and
     * regenerates the hash table.
     * @param cnt New number of elements.
     */
    void reserve(const size_type cnt) {
        packed.first().reserve(cnt);
        rehash(static_cast<size_type>(std::ceil(cnt / max_load_factor())));
    }

    /**
     * @brief Returns the function used to hash the elements.
     * @return The function used to hash the elements.
     */
    [[nodiscard]] hasher hash_function() const {
        return sparse.second();
    }

    /**
     * @brief Returns the function used to compare elements for equality.
     * @return The function used to compare elements for equality.
     */
    [[nodiscard]] key_equal key_eq() const {
        return packed.second();
    }

private:
    compressed_pair<sparse_container_type, hasher> sparse;
    compressed_pair<packed_container_type, key_equal> packed;
    float threshold;
};

} // namespace entt

#endif

///////////////// END OF external/entt/container/dense_set.hpp /////////////////

/////////////////// START OF external/entt/core/utility.hpp ////////////////////

#ifndef ENTT_CORE_UTILITY_HPP
#define ENTT_CORE_UTILITY_HPP

#include <type_traits>
#include <utility>

namespace entt {

/*! @brief Identity function object (waiting for C++20). */
struct identity {
    /*! @brief Indicates that this is a transparent function object. */
    using is_transparent = void;

    /**
     * @brief Returns its argument unchanged.
     * @tparam Type Type of the argument.
     * @param value The actual argument.
     * @return The submitted value as-is.
     */
    template<typename Type>
    [[nodiscard]] constexpr Type &&operator()(Type &&value) const noexcept {
        return std::forward<Type>(value);
    }
};

/**
 * @brief Constant utility to disambiguate overloaded members of a class.
 * @tparam Type Type of the desired overload.
 * @tparam Class Type of class to which the member belongs.
 * @param member A valid pointer to a member.
 * @return Pointer to the member.
 */
template<typename Type, typename Class>
[[nodiscard]] constexpr auto overload(Type Class::*member) noexcept {
    return member;
}

/**
 * @brief Constant utility to disambiguate overloaded functions.
 * @tparam Func Function type of the desired overload.
 * @param func A valid pointer to a function.
 * @return Pointer to the function.
 */
template<typename Func>
[[nodiscard]] constexpr auto overload(Func *func) noexcept {
    return func;
}

/**
 * @brief Helper type for visitors.
 * @tparam Func Types of function objects.
 */
template<typename... Func>
struct overloaded: Func... {
    using Func::operator()...;
};

/**
 * @brief Deduction guide.
 * @tparam Func Types of function objects.
 */
template<typename... Func>
overloaded(Func...) -> overloaded<Func...>;

/**
 * @brief Basic implementation of a y-combinator.
 * @tparam Func Type of a potentially recursive function.
 */
template<typename Func>
struct y_combinator {
    /**
     * @brief Constructs a y-combinator from a given function.
     * @param recursive A potentially recursive function.
     */
    constexpr y_combinator(Func recursive) noexcept(std::is_nothrow_move_constructible_v<Func>)
        : func{std::move(recursive)} {}

    /**
     * @brief Invokes a y-combinator and therefore its underlying function.
     * @tparam Args Types of arguments to use to invoke the underlying function.
     * @param args Parameters to use to invoke the underlying function.
     * @return Return value of the underlying function, if any.
     */
    template<typename... Args>
    constexpr decltype(auto) operator()(Args &&...args) const noexcept(std::is_nothrow_invocable_v<Func, const y_combinator &, Args...>) {
        return func(*this, std::forward<Args>(args)...);
    }

    /*! @copydoc operator()() */
    template<typename... Args>
    constexpr decltype(auto) operator()(Args &&...args) noexcept(std::is_nothrow_invocable_v<Func, y_combinator &, Args...>) {
        return func(*this, std::forward<Args>(args)...);
    }

private:
    Func func;
};

} // namespace entt

#endif

//////////////////// END OF external/entt/core/utility.hpp /////////////////////

////////////////// START OF external/entt/core/algorithm.hpp ///////////////////

#ifndef ENTT_CORE_ALGORITHM_HPP
#define ENTT_CORE_ALGORITHM_HPP

#include <algorithm>
#include <functional>
#include <iterator>
#include <utility>
#include <vector>

namespace entt {

/**
 * @brief Function object to wrap `std::sort` in a class type.
 *
 * Unfortunately, `std::sort` cannot be passed as template argument to a class
 * template or a function template.<br/>
 * This class fills the gap by wrapping some flavors of `std::sort` in a
 * function object.
 */
struct std_sort {
    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given binary comparison function.
     *
     * @tparam It Type of random access iterator.
     * @tparam Compare Type of comparison function object.
     * @tparam Args Types of arguments to forward to the sort function.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param compare A valid comparison function object.
     * @param args Arguments to forward to the sort function, if any.
     */
    template<typename It, typename Compare = std::less<>, typename... Args>
    void operator()(It first, It last, Compare compare = Compare{}, Args &&...args) const {
        std::sort(std::forward<Args>(args)..., std::move(first), std::move(last), std::move(compare));
    }
};

/*! @brief Function object for performing insertion sort. */
struct insertion_sort {
    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given binary comparison function.
     *
     * @tparam It Type of random access iterator.
     * @tparam Compare Type of comparison function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param compare A valid comparison function object.
     */
    template<typename It, typename Compare = std::less<>>
    void operator()(It first, It last, Compare compare = Compare{}) const {
        if(first < last) {
            for(auto it = first + 1; it < last; ++it) {
                auto value = std::move(*it);
                auto pre = it;

                for(; pre > first && compare(value, *(pre - 1)); --pre) {
                    *pre = std::move(*(pre - 1));
                }

                *pre = std::move(value);
            }
        }
    }
};

/**
 * @brief Function object for performing LSD radix sort.
 * @tparam Bit Number of bits processed per pass.
 * @tparam N Maximum number of bits to sort.
 */
template<std::size_t Bit, std::size_t N>
struct radix_sort {
    static_assert((N % Bit) == 0, "The maximum number of bits to sort must be a multiple of the number of bits processed per pass");

    /**
     * @brief Sorts the elements in a range.
     *
     * Sorts the elements in a range using the given _getter_ to access the
     * actual data to be sorted.
     *
     * This implementation is inspired by the online book
     * [Physically Based Rendering](http://www.pbr-book.org/3ed-2018/Primitives_and_Intersection_Acceleration/Bounding_Volume_Hierarchies.html#RadixSort).
     *
     * @tparam It Type of random access iterator.
     * @tparam Getter Type of _getter_ function object.
     * @param first An iterator to the first element of the range to sort.
     * @param last An iterator past the last element of the range to sort.
     * @param getter A valid _getter_ function object.
     */
    template<typename It, typename Getter = identity>
    void operator()(It first, It last, Getter getter = Getter{}) const {
        if(first < last) {
            constexpr auto passes = N / Bit;

            using value_type = typename std::iterator_traits<It>::value_type;
            std::vector<value_type> aux(std::distance(first, last));

            auto part = [getter = std::move(getter)](auto from, auto to, auto out, auto start) {
                constexpr auto mask = (1 << Bit) - 1;
                constexpr auto buckets = 1 << Bit;

                std::size_t index[buckets]{};
                std::size_t count[buckets]{};

                for(auto it = from; it != to; ++it) {
                    ++count[(getter(*it) >> start) & mask];
                }

                for(std::size_t pos{}, end = buckets - 1u; pos < end; ++pos) {
                    index[pos + 1u] = index[pos] + count[pos];
                }

                for(auto it = from; it != to; ++it) {
                    out[index[(getter(*it) >> start) & mask]++] = std::move(*it);
                }
            };

            for(std::size_t pass = 0; pass < (passes & ~1); pass += 2) {
                part(first, last, aux.begin(), pass * Bit);
                part(aux.begin(), aux.end(), first, (pass + 1) * Bit);
            }

            if constexpr(passes & 1) {
                part(first, last, aux.begin(), (passes - 1) * Bit);
                std::move(aux.begin(), aux.end(), first);
            }
        }
    }
};

} // namespace entt

#endif

/////////////////// END OF external/entt/core/algorithm.hpp ////////////////////

/////////////////// START OF external/entt/core/attribute.h ////////////////////

#ifndef ENTT_CORE_ATTRIBUTE_H
#define ENTT_CORE_ATTRIBUTE_H

#ifndef ENTT_EXPORT
#    if defined _WIN32 || defined __CYGWIN__ || defined _MSC_VER
#        define ENTT_EXPORT __declspec(dllexport)
#        define ENTT_IMPORT __declspec(dllimport)
#        define ENTT_HIDDEN
#    elif defined __GNUC__ && __GNUC__ >= 4
#        define ENTT_EXPORT __attribute__((visibility("default")))
#        define ENTT_IMPORT __attribute__((visibility("default")))
#        define ENTT_HIDDEN __attribute__((visibility("hidden")))
#    else /* Unsupported compiler */
#        define ENTT_EXPORT
#        define ENTT_IMPORT
#        define ENTT_HIDDEN
#    endif
#endif

#ifndef ENTT_API
#    if defined ENTT_API_EXPORT
#        define ENTT_API ENTT_EXPORT
#    elif defined ENTT_API_IMPORT
#        define ENTT_API ENTT_IMPORT
#    else /* No API */
#        define ENTT_API
#    endif
#endif

#endif

//////////////////// END OF external/entt/core/attribute.h /////////////////////

//////////////// START OF external/entt/core/hashed_string.hpp /////////////////

#ifndef ENTT_CORE_HASHED_STRING_HPP
#define ENTT_CORE_HASHED_STRING_HPP

#include <cstddef>
#include <cstdint>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename>
struct fnv1a_traits;

template<>
struct fnv1a_traits<std::uint32_t> {
    using type = std::uint32_t;
    static constexpr std::uint32_t offset = 2166136261;
    static constexpr std::uint32_t prime = 16777619;
};

template<>
struct fnv1a_traits<std::uint64_t> {
    using type = std::uint64_t;
    static constexpr std::uint64_t offset = 14695981039346656037ull;
    static constexpr std::uint64_t prime = 1099511628211ull;
};

template<typename Char>
struct basic_hashed_string {
    using value_type = Char;
    using size_type = std::size_t;
    using hash_type = id_type;

    const value_type *repr;
    size_type length;
    hash_type hash;
};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Zero overhead unique identifier.
 *
 * A hashed string is a compile-time tool that allows users to use
 * human-readable identifiers in the codebase while using their numeric
 * counterparts at runtime.<br/>
 * Because of that, a hashed string can also be used in constant expressions if
 * required.
 *
 * @warning
 * This class doesn't take ownership of user-supplied strings nor does it make a
 * copy of them.
 *
 * @tparam Char Character type.
 */
template<typename Char>
class basic_hashed_string: internal::basic_hashed_string<Char> {
    using base_type = internal::basic_hashed_string<Char>;
    using traits_type = internal::fnv1a_traits<id_type>;

    struct const_wrapper {
        // non-explicit constructor on purpose
        constexpr const_wrapper(const Char *str) noexcept
            : repr{str} {}

        const Char *repr;
    };

    // FowlerNollVo hash function v. 1a - the good
    [[nodiscard]] static constexpr auto helper(const Char *str) noexcept {
        base_type base{str, 0u, traits_type::offset};

        for(; str[base.length]; ++base.length) {
            base.hash = (base.hash ^ static_cast<traits_type::type>(str[base.length])) * traits_type::prime;
        }

        return base;
    }

    // FowlerNollVo hash function v. 1a - the good
    [[nodiscard]] static constexpr auto helper(const Char *str, const std::size_t len) noexcept {
        base_type base{str, len, traits_type::offset};

        for(size_type pos{}; pos < len; ++pos) {
            base.hash = (base.hash ^ static_cast<traits_type::type>(str[pos])) * traits_type::prime;
        }

        return base;
    }

public:
    /*! @brief Character type. */
    using value_type = typename base_type::value_type;
    /*! @brief Unsigned integer type. */
    using size_type = typename base_type::size_type;
    /*! @brief Unsigned integer type. */
    using hash_type = typename base_type::hash_type;

    /**
     * @brief Returns directly the numeric representation of a string view.
     * @param str Human-readable identifier.
     * @param len Length of the string to hash.
     * @return The numeric representation of the string.
     */
    [[nodiscard]] static constexpr hash_type value(const value_type *str, const size_type len) noexcept {
        return basic_hashed_string{str, len};
    }

    /**
     * @brief Returns directly the numeric representation of a string.
     * @tparam N Number of characters of the identifier.
     * @param str Human-readable identifier.
     * @return The numeric representation of the string.
     */
    template<std::size_t N>
    [[nodiscard]] static constexpr hash_type value(const value_type (&str)[N]) noexcept {
        return basic_hashed_string{str};
    }

    /**
     * @brief Returns directly the numeric representation of a string.
     * @param wrapper Helps achieving the purpose by relying on overloading.
     * @return The numeric representation of the string.
     */
    [[nodiscard]] static constexpr hash_type value(const_wrapper wrapper) noexcept {
        return basic_hashed_string{wrapper};
    }

    /*! @brief Constructs an empty hashed string. */
    constexpr basic_hashed_string() noexcept
        : base_type{} {}

    /**
     * @brief Constructs a hashed string from a string view.
     * @param str Human-readable identifier.
     * @param len Length of the string to hash.
     */
    constexpr basic_hashed_string(const value_type *str, const size_type len) noexcept
        : base_type{helper(str, len)} {}

    /**
     * @brief Constructs a hashed string from an array of const characters.
     * @tparam N Number of characters of the identifier.
     * @param str Human-readable identifier.
     */
    template<std::size_t N>
    constexpr basic_hashed_string(const value_type (&str)[N]) noexcept
        : base_type{helper(str)} {}

    /**
     * @brief Explicit constructor on purpose to avoid constructing a hashed
     * string directly from a `const value_type *`.
     *
     * @warning
     * The lifetime of the string is not extended nor is it copied.
     *
     * @param wrapper Helps achieving the purpose by relying on overloading.
     */
    explicit constexpr basic_hashed_string(const_wrapper wrapper) noexcept
        : base_type{helper(wrapper.repr)} {}

    /**
     * @brief Returns the size a hashed string.
     * @return The size of the hashed string.
     */
    [[nodiscard]] constexpr size_type size() const noexcept {
        return base_type::length;
    }

    /**
     * @brief Returns the human-readable representation of a hashed string.
     * @return The string used to initialize the hashed string.
     */
    [[nodiscard]] constexpr const value_type *data() const noexcept {
        return base_type::repr;
    }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the hashed string.
     */
    [[nodiscard]] constexpr hash_type value() const noexcept {
        return base_type::hash;
    }

    /*! @copydoc data */
    [[nodiscard]] constexpr operator const value_type *() const noexcept {
        return data();
    }

    /**
     * @brief Returns the numeric representation of a hashed string.
     * @return The numeric representation of the hashed string.
     */
    [[nodiscard]] constexpr operator hash_type() const noexcept {
        return value();
    }
};

/**
 * @brief Deduction guide.
 * @tparam Char Character type.
 * @param str Human-readable identifier.
 * @param len Length of the string to hash.
 */
template<typename Char>
basic_hashed_string(const Char *str, const std::size_t len) -> basic_hashed_string<Char>;

/**
 * @brief Deduction guide.
 * @tparam Char Character type.
 * @tparam N Number of characters of the identifier.
 * @param str Human-readable identifier.
 */
template<typename Char, std::size_t N>
basic_hashed_string(const Char (&str)[N]) -> basic_hashed_string<Char>;

/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the two hashed strings are identical, false otherwise.
 */
template<typename Char>
[[nodiscard]] constexpr bool operator==(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) noexcept {
    return lhs.value() == rhs.value();
}

/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the two hashed strings differ, false otherwise.
 */
template<typename Char>
[[nodiscard]] constexpr bool operator!=(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) noexcept {
    return !(lhs == rhs);
}

/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the first element is less than the second, false otherwise.
 */
template<typename Char>
[[nodiscard]] constexpr bool operator<(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) noexcept {
    return lhs.value() < rhs.value();
}

/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the first element is less than or equal to the second, false
 * otherwise.
 */
template<typename Char>
[[nodiscard]] constexpr bool operator<=(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) noexcept {
    return !(rhs < lhs);
}

/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the first element is greater than the second, false
 * otherwise.
 */
template<typename Char>
[[nodiscard]] constexpr bool operator>(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) noexcept {
    return rhs < lhs;
}

/**
 * @brief Compares two hashed strings.
 * @tparam Char Character type.
 * @param lhs A valid hashed string.
 * @param rhs A valid hashed string.
 * @return True if the first element is greater than or equal to the second,
 * false otherwise.
 */
template<typename Char>
[[nodiscard]] constexpr bool operator>=(const basic_hashed_string<Char> &lhs, const basic_hashed_string<Char> &rhs) noexcept {
    return !(lhs < rhs);
}

/*! @brief Aliases for common character types. */
using hashed_string = basic_hashed_string<char>;

/*! @brief Aliases for common character types. */
using hashed_wstring = basic_hashed_string<wchar_t>;

inline namespace literals {

/**
 * @brief User defined literal for hashed strings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed string.
 */
[[nodiscard]] constexpr hashed_string operator"" _hs(const char *str, std::size_t) noexcept {
    return hashed_string{str};
}

/**
 * @brief User defined literal for hashed wstrings.
 * @param str The literal without its suffix.
 * @return A properly initialized hashed wstring.
 */
[[nodiscard]] constexpr hashed_wstring operator"" _hws(const wchar_t *str, std::size_t) noexcept {
    return hashed_wstring{str};
}

} // namespace literals

} // namespace entt

#endif

///////////////// END OF external/entt/core/hashed_string.hpp //////////////////

////////////////// START OF external/entt/core/type_info.hpp ///////////////////

#ifndef ENTT_CORE_TYPE_INFO_HPP
#define ENTT_CORE_TYPE_INFO_HPP

#include <string_view>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

struct ENTT_API type_index final {
    [[nodiscard]] static id_type next() noexcept {
        static ENTT_MAYBE_ATOMIC(id_type) value{};
        return value++;
    }
};

template<typename Type>
[[nodiscard]] constexpr auto stripped_type_name() noexcept {
#if defined ENTT_PRETTY_FUNCTION
    std::string_view pretty_function{ENTT_PRETTY_FUNCTION};
    auto first = pretty_function.find_first_not_of(' ', pretty_function.find_first_of(ENTT_PRETTY_FUNCTION_PREFIX) + 1);
    auto value = pretty_function.substr(first, pretty_function.find_last_of(ENTT_PRETTY_FUNCTION_SUFFIX) - first);
    return value;
#else
    return std::string_view{""};
#endif
}

template<typename Type, auto = stripped_type_name<Type>().find_first_of('.')>
[[nodiscard]] static constexpr std::string_view type_name(int) noexcept {
    constexpr auto value = stripped_type_name<Type>();
    return value;
}

template<typename Type>
[[nodiscard]] static std::string_view type_name(char) noexcept {
    static const auto value = stripped_type_name<Type>();
    return value;
}

template<typename Type, auto = stripped_type_name<Type>().find_first_of('.')>
[[nodiscard]] static constexpr id_type type_hash(int) noexcept {
    constexpr auto stripped = stripped_type_name<Type>();
    constexpr auto value = hashed_string::value(stripped.data(), stripped.size());
    return value;
}

template<typename Type>
[[nodiscard]] static id_type type_hash(char) noexcept {
    static const auto value = [](const auto stripped) {
        return hashed_string::value(stripped.data(), stripped.size());
    }(stripped_type_name<Type>());
    return value;
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Type sequential identifier.
 * @tparam Type Type for which to generate a sequential identifier.
 */
template<typename Type, typename = void>
struct ENTT_API type_index final {
    /**
     * @brief Returns the sequential identifier of a given type.
     * @return The sequential identifier of a given type.
     */
    [[nodiscard]] static id_type value() noexcept {
        static const id_type value = internal::type_index::next();
        return value;
    }

    /*! @copydoc value */
    [[nodiscard]] constexpr operator id_type() const noexcept {
        return value();
    }
};

/**
 * @brief Type hash.
 * @tparam Type Type for which to generate a hash value.
 */
template<typename Type, typename = void>
struct type_hash final {
    /**
     * @brief Returns the numeric representation of a given type.
     * @return The numeric representation of the given type.
     */
#if defined ENTT_PRETTY_FUNCTION
    [[nodiscard]] static constexpr id_type value() noexcept {
        return internal::type_hash<Type>(0);
#else
    [[nodiscard]] static constexpr id_type value() noexcept {
        return type_index<Type>::value();
#endif
    }

    /*! @copydoc value */
    [[nodiscard]] constexpr operator id_type() const noexcept {
        return value();
    }
};

/**
 * @brief Type name.
 * @tparam Type Type for which to generate a name.
 */
template<typename Type, typename = void>
struct type_name final {
    /**
     * @brief Returns the name of a given type.
     * @return The name of the given type.
     */
    [[nodiscard]] static constexpr std::string_view value() noexcept {
        return internal::type_name<Type>(0);
    }

    /*! @copydoc value */
    [[nodiscard]] constexpr operator std::string_view() const noexcept {
        return value();
    }
};

/*! @brief Implementation specific information about a type. */
struct type_info final {
    /**
     * @brief Constructs a type info object for a given type.
     * @tparam Type Type for which to construct a type info object.
     */
    template<typename Type>
    constexpr type_info(std::in_place_type_t<Type>) noexcept
        : seq{type_index<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
          identifier{type_hash<std::remove_cv_t<std::remove_reference_t<Type>>>::value()},
          alias{type_name<std::remove_cv_t<std::remove_reference_t<Type>>>::value()} {}

    /**
     * @brief Type index.
     * @return Type index.
     */
    [[nodiscard]] constexpr id_type index() const noexcept {
        return seq;
    }

    /**
     * @brief Type hash.
     * @return Type hash.
     */
    [[nodiscard]] constexpr id_type hash() const noexcept {
        return identifier;
    }

    /**
     * @brief Type name.
     * @return Type name.
     */
    [[nodiscard]] constexpr std::string_view name() const noexcept {
        return alias;
    }

private:
    id_type seq;
    id_type identifier;
    std::string_view alias;
};

/**
 * @brief Compares the contents of two type info objects.
 * @param lhs A type info object.
 * @param rhs A type info object.
 * @return True if the two type info objects are identical, false otherwise.
 */
[[nodiscard]] inline constexpr bool operator==(const type_info &lhs, const type_info &rhs) noexcept {
    return lhs.hash() == rhs.hash();
}

/**
 * @brief Compares the contents of two type info objects.
 * @param lhs A type info object.
 * @param rhs A type info object.
 * @return True if the two type info objects differ, false otherwise.
 */
[[nodiscard]] inline constexpr bool operator!=(const type_info &lhs, const type_info &rhs) noexcept {
    return !(lhs == rhs);
}

/**
 * @brief Compares two type info objects.
 * @param lhs A valid type info object.
 * @param rhs A valid type info object.
 * @return True if the first element is less than the second, false otherwise.
 */
[[nodiscard]] constexpr bool operator<(const type_info &lhs, const type_info &rhs) noexcept {
    return lhs.index() < rhs.index();
}

/**
 * @brief Compares two type info objects.
 * @param lhs A valid type info object.
 * @param rhs A valid type info object.
 * @return True if the first element is less than or equal to the second, false
 * otherwise.
 */
[[nodiscard]] constexpr bool operator<=(const type_info &lhs, const type_info &rhs) noexcept {
    return !(rhs < lhs);
}

/**
 * @brief Compares two type info objects.
 * @param lhs A valid type info object.
 * @param rhs A valid type info object.
 * @return True if the first element is greater than the second, false
 * otherwise.
 */
[[nodiscard]] constexpr bool operator>(const type_info &lhs, const type_info &rhs) noexcept {
    return rhs < lhs;
}

/**
 * @brief Compares two type info objects.
 * @param lhs A valid type info object.
 * @param rhs A valid type info object.
 * @return True if the first element is greater than or equal to the second,
 * false otherwise.
 */
[[nodiscard]] constexpr bool operator>=(const type_info &lhs, const type_info &rhs) noexcept {
    return !(lhs < rhs);
}

/**
 * @brief Returns the type info object associated to a given type.
 *
 * The returned element refers to an object with static storage duration.<br/>
 * The type doesn't need to be a complete type. If the type is a reference, the
 * result refers to the referenced type. In all cases, top-level cv-qualifiers
 * are ignored.
 *
 * @tparam Type Type for which to generate a type info object.
 * @return A reference to a properly initialized type info object.
 */
template<typename Type>
[[nodiscard]] const type_info &type_id() noexcept {
    if constexpr(std::is_same_v<Type, std::remove_cv_t<std::remove_reference_t<Type>>>) {
        static type_info instance{std::in_place_type<Type>};
        return instance;
    } else {
        return type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
    }
}

/*! @copydoc type_id */
template<typename Type>
[[nodiscard]] const type_info &type_id(Type &&) noexcept {
    return type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();
}

} // namespace entt

#endif

/////////////////// END OF external/entt/core/type_info.hpp ////////////////////

///////////////////// START OF external/entt/core/any.hpp //////////////////////

#ifndef ENTT_CORE_ANY_HPP
#define ENTT_CORE_ANY_HPP

#include <cstddef>
#include <memory>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

enum class any_operation : std::uint8_t {
    copy,
    move,
    transfer,
    assign,
    destroy,
    compare,
    get
};

enum class any_policy : std::uint8_t {
    owner,
    ref,
    cref
};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief A SBO friendly, type-safe container for single values of any type.
 * @tparam Len Size of the storage reserved for the small buffer optimization.
 * @tparam Align Optional alignment requirement.
 */
template<std::size_t Len, std::size_t Align>
class basic_any {
    using operation = internal::any_operation;
    using policy = internal::any_policy;
    using vtable_type = const void *(const operation, const basic_any &, const void *);

    struct storage_type {
        alignas(Align) std::byte data[Len + !Len];
    };

    template<typename Type>
    static constexpr bool in_situ = Len && alignof(Type) <= Align && sizeof(Type) <= Len && std::is_nothrow_move_constructible_v<Type>;

    template<typename Type>
    static const void *basic_vtable(const operation op, const basic_any &value, const void *other) {
        static_assert(!std::is_same_v<Type, void> && std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, Type>, "Invalid type");
        const Type *element = nullptr;

        if constexpr(in_situ<Type>) {
            element = value.owner() ? reinterpret_cast<const Type *>(&value.storage) : static_cast<const Type *>(value.instance);
        } else {
            element = static_cast<const Type *>(value.instance);
        }

        switch(op) {
        case operation::copy:
            if constexpr(std::is_copy_constructible_v<Type>) {
                static_cast<basic_any *>(const_cast<void *>(other))->initialize<Type>(*element);
            }
            break;
        case operation::move:
            if constexpr(in_situ<Type>) {
                if(value.owner()) {
                    return new(&static_cast<basic_any *>(const_cast<void *>(other))->storage) Type{std::move(*const_cast<Type *>(element))};
                }
            }

            return (static_cast<basic_any *>(const_cast<void *>(other))->instance = std::exchange(const_cast<basic_any &>(value).instance, nullptr));
        case operation::transfer:
            if constexpr(std::is_move_assignable_v<Type>) {
                *const_cast<Type *>(element) = std::move(*static_cast<Type *>(const_cast<void *>(other)));
                return other;
            }
            [[fallthrough]];
        case operation::assign:
            if constexpr(std::is_copy_assignable_v<Type>) {
                *const_cast<Type *>(element) = *static_cast<const Type *>(other);
                return other;
            }
            break;
        case operation::destroy:
            if constexpr(in_situ<Type>) {
                element->~Type();
            } else if constexpr(std::is_array_v<Type>) {
                delete[] element;
            } else {
                delete element;
            }
            break;
        case operation::compare:
            if constexpr(!std::is_function_v<Type> && !std::is_array_v<Type> && is_equality_comparable_v<Type>) {
                return *element == *static_cast<const Type *>(other) ? other : nullptr;
            } else {
                return (element == other) ? other : nullptr;
            }
        case operation::get:
            return element;
        }

        return nullptr;
    }

    template<typename Type, typename... Args>
    void initialize([[maybe_unused]] Args &&...args) {
        info = &type_id<std::remove_cv_t<std::remove_reference_t<Type>>>();

        if constexpr(!std::is_void_v<Type>) {
            vtable = basic_vtable<std::remove_cv_t<std::remove_reference_t<Type>>>;

            if constexpr(std::is_lvalue_reference_v<Type>) {
                static_assert((std::is_lvalue_reference_v<Args> && ...) && (sizeof...(Args) == 1u), "Invalid arguments");
                mode = std::is_const_v<std::remove_reference_t<Type>> ? policy::cref : policy::ref;
                instance = (std::addressof(args), ...);
            } else if constexpr(in_situ<std::remove_cv_t<std::remove_reference_t<Type>>>) {
                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
                } else {
                    new(&storage) std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
                }
            } else {
                if constexpr(std::is_aggregate_v<std::remove_cv_t<std::remove_reference_t<Type>>> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>)) {
                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>{std::forward<Args>(args)...};
                } else {
                    instance = new std::remove_cv_t<std::remove_reference_t<Type>>(std::forward<Args>(args)...);
                }
            }
        }
    }

    basic_any(const basic_any &other, const policy pol) noexcept
        : instance{other.data()},
          info{other.info},
          vtable{other.vtable},
          mode{pol} {}

public:
    /*! @brief Size of the internal storage. */
    static constexpr auto length = Len;
    /*! @brief Alignment requirement. */
    static constexpr auto alignment = Align;

    /*! @brief Default constructor. */
    constexpr basic_any() noexcept
        : basic_any{std::in_place_type<void>} {}

    /**
     * @brief Constructs a wrapper by directly initializing the new object.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @tparam Args Types of arguments to use to construct the new instance.
     * @param args Parameters to use to construct the instance.
     */
    template<typename Type, typename... Args>
    explicit basic_any(std::in_place_type_t<Type>, Args &&...args)
        : instance{},
          info{},
          vtable{},
          mode{policy::owner} {
        initialize<Type>(std::forward<Args>(args)...);
    }

    /**
     * @brief Constructs a wrapper from a given value.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @param value An instance of an object to use to initialize the wrapper.
     */
    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>>>
    basic_any(Type &&value)
        : basic_any{std::in_place_type<std::decay_t<Type>>, std::forward<Type>(value)} {}

    /**
     * @brief Copy constructor.
     * @param other The instance to copy from.
     */
    basic_any(const basic_any &other)
        : basic_any{} {
        if(other.vtable) {
            other.vtable(operation::copy, other, this);
        }
    }

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    basic_any(basic_any &&other) noexcept
        : instance{},
          info{other.info},
          vtable{other.vtable},
          mode{other.mode} {
        if(other.vtable) {
            other.vtable(operation::move, other, this);
        }
    }

    /*! @brief Frees the internal storage, whatever it means. */
    ~basic_any() {
        if(vtable && owner()) {
            vtable(operation::destroy, *this, nullptr);
        }
    }

    /**
     * @brief Copy assignment operator.
     * @param other The instance to copy from.
     * @return This any object.
     */
    basic_any &operator=(const basic_any &other) {
        reset();

        if(other.vtable) {
            other.vtable(operation::copy, other, this);
        }

        return *this;
    }

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This any object.
     */
    basic_any &operator=(basic_any &&other) noexcept {
        reset();

        if(other.vtable) {
            other.vtable(operation::move, other, this);
            info = other.info;
            vtable = other.vtable;
            mode = other.mode;
        }

        return *this;
    }

    /**
     * @brief Value assignment operator.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @param value An instance of an object to use to initialize the wrapper.
     * @return This any object.
     */
    template<typename Type>
    std::enable_if_t<!std::is_same_v<std::decay_t<Type>, basic_any>, basic_any &>
    operator=(Type &&value) {
        emplace<std::decay_t<Type>>(std::forward<Type>(value));
        return *this;
    }

    /**
     * @brief Returns the object type if any, `type_id<void>()` otherwise.
     * @return The object type if any, `type_id<void>()` otherwise.
     */
    [[nodiscard]] const type_info &type() const noexcept {
        return *info;
    }

    /**
     * @brief Returns an opaque pointer to the contained instance.
     * @return An opaque pointer the contained instance, if any.
     */
    [[nodiscard]] const void *data() const noexcept {
        return vtable ? vtable(operation::get, *this, nullptr) : nullptr;
    }

    /**
     * @brief Returns an opaque pointer to the contained instance.
     * @param req Expected type.
     * @return An opaque pointer the contained instance, if any.
     */
    [[nodiscard]] const void *data(const type_info &req) const noexcept {
        return *info == req ? data() : nullptr;
    }

    /**
     * @brief Returns an opaque pointer to the contained instance.
     * @return An opaque pointer the contained instance, if any.
     */
    [[nodiscard]] void *data() noexcept {
        return mode == policy::cref ? nullptr : const_cast<void *>(std::as_const(*this).data());
    }

    /**
     * @brief Returns an opaque pointer to the contained instance.
     * @param req Expected type.
     * @return An opaque pointer the contained instance, if any.
     */
    [[nodiscard]] void *data(const type_info &req) noexcept {
        return mode == policy::cref ? nullptr : const_cast<void *>(std::as_const(*this).data(req));
    }

    /**
     * @brief Replaces the contained object by creating a new instance directly.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @tparam Args Types of arguments to use to construct the new instance.
     * @param args Parameters to use to construct the instance.
     */
    template<typename Type, typename... Args>
    void emplace(Args &&...args) {
        reset();
        initialize<Type>(std::forward<Args>(args)...);
    }

    /**
     * @brief Assigns a value to the contained object without replacing it.
     * @param other The value to assign to the contained object.
     * @return True in case of success, false otherwise.
     */
    bool assign(const basic_any &other) {
        if(vtable && mode != policy::cref && *info == *other.info) {
            return (vtable(operation::assign, *this, other.data()) != nullptr);
        }

        return false;
    }

    /*! @copydoc assign */
    bool assign(basic_any &&other) {
        if(vtable && mode != policy::cref && *info == *other.info) {
            if(auto *val = other.data(); val) {
                return (vtable(operation::transfer, *this, val) != nullptr);
            } else {
                return (vtable(operation::assign, *this, std::as_const(other).data()) != nullptr);
            }
        }

        return false;
    }

    /*! @brief Destroys contained object */
    void reset() {
        if(vtable && owner()) {
            vtable(operation::destroy, *this, nullptr);
        }

        // unnecessary but it helps to detect nasty bugs
        ENTT_ASSERT((instance = nullptr) == nullptr, "");
        info = &type_id<void>();
        vtable = nullptr;
        mode = policy::owner;
    }

    /**
     * @brief Returns false if a wrapper is empty, true otherwise.
     * @return False if the wrapper is empty, true otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return vtable != nullptr;
    }

    /**
     * @brief Checks if two wrappers differ in their content.
     * @param other Wrapper with which to compare.
     * @return False if the two objects differ in their content, true otherwise.
     */
    [[nodiscard]] bool operator==(const basic_any &other) const noexcept {
        if(vtable && *info == *other.info) {
            return (vtable(operation::compare, *this, other.data()) != nullptr);
        }

        return (!vtable && !other.vtable);
    }

    /**
     * @brief Checks if two wrappers differ in their content.
     * @param other Wrapper with which to compare.
     * @return True if the two objects differ in their content, false otherwise.
     */
    [[nodiscard]] bool operator!=(const basic_any &other) const noexcept {
        return !(*this == other);
    }

    /**
     * @brief Aliasing constructor.
     * @return A wrapper that shares a reference to an unmanaged object.
     */
    [[nodiscard]] basic_any as_ref() noexcept {
        return basic_any{*this, (mode == policy::cref ? policy::cref : policy::ref)};
    }

    /*! @copydoc as_ref */
    [[nodiscard]] basic_any as_ref() const noexcept {
        return basic_any{*this, policy::cref};
    }

    /**
     * @brief Returns true if a wrapper owns its object, false otherwise.
     * @return True if the wrapper owns its object, false otherwise.
     */
    [[nodiscard]] bool owner() const noexcept {
        return (mode == policy::owner);
    }

private:
    union {
        const void *instance;
        storage_type storage;
    };
    const type_info *info;
    vtable_type *vtable;
    policy mode;
};

/**
 * @brief Performs type-safe access to the contained object.
 * @tparam Type Type to which conversion is required.
 * @tparam Len Size of the storage reserved for the small buffer optimization.
 * @tparam Align Alignment requirement.
 * @param data Target any object.
 * @return The element converted to the requested type.
 */
template<typename Type, std::size_t Len, std::size_t Align>
[[nodiscard]] Type any_cast(const basic_any<Len, Align> &data) noexcept {
    const auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
    ENTT_ASSERT(instance, "Invalid instance");
    return static_cast<Type>(*instance);
}

/*! @copydoc any_cast */
template<typename Type, std::size_t Len, std::size_t Align>
[[nodiscard]] Type any_cast(basic_any<Len, Align> &data) noexcept {
    // forces const on non-reference types to make them work also with wrappers for const references
    auto *const instance = any_cast<std::remove_reference_t<const Type>>(&data);
    ENTT_ASSERT(instance, "Invalid instance");
    return static_cast<Type>(*instance);
}

/*! @copydoc any_cast */
template<typename Type, std::size_t Len, std::size_t Align>
[[nodiscard]] Type any_cast(basic_any<Len, Align> &&data) noexcept {
    if constexpr(std::is_copy_constructible_v<std::remove_cv_t<std::remove_reference_t<Type>>>) {
        if(auto *const instance = any_cast<std::remove_reference_t<Type>>(&data); instance) {
            return static_cast<Type>(std::move(*instance));
        } else {
            return any_cast<Type>(data);
        }
    } else {
        auto *const instance = any_cast<std::remove_reference_t<Type>>(&data);
        ENTT_ASSERT(instance, "Invalid instance");
        return static_cast<Type>(std::move(*instance));
    }
}

/*! @copydoc any_cast */
template<typename Type, std::size_t Len, std::size_t Align>
[[nodiscard]] const Type *any_cast(const basic_any<Len, Align> *data) noexcept {
    const auto &info = type_id<std::remove_cv_t<Type>>();
    return static_cast<const Type *>(data->data(info));
}

/*! @copydoc any_cast */
template<typename Type, std::size_t Len, std::size_t Align>
[[nodiscard]] Type *any_cast(basic_any<Len, Align> *data) noexcept {
    if constexpr(std::is_const_v<Type>) {
        // last attempt to make wrappers for const references return their values
        return any_cast<Type>(&std::as_const(*data));
    } else {
        const auto &info = type_id<std::remove_cv_t<Type>>();
        return static_cast<Type *>(data->data(info));
    }
}

/**
 * @brief Constructs a wrapper from a given type, passing it all arguments.
 * @tparam Type Type of object to use to initialize the wrapper.
 * @tparam Len Size of the storage reserved for the small buffer optimization.
 * @tparam Align Optional alignment requirement.
 * @tparam Args Types of arguments to use to construct the new instance.
 * @param args Parameters to use to construct the instance.
 * @return A properly initialized wrapper for an object of the given type.
 */
template<typename Type, std::size_t Len = basic_any<>::length, std::size_t Align = basic_any<Len>::alignment, typename... Args>
[[nodiscard]] basic_any<Len, Align> make_any(Args &&...args) {
    return basic_any<Len, Align>{std::in_place_type<Type>, std::forward<Args>(args)...};
}

/**
 * @brief Forwards its argument and avoids copies for lvalue references.
 * @tparam Len Size of the storage reserved for the small buffer optimization.
 * @tparam Align Optional alignment requirement.
 * @tparam Type Type of argument to use to construct the new instance.
 * @param value Parameter to use to construct the instance.
 * @return A properly initialized and not necessarily owning wrapper.
 */
template<std::size_t Len = basic_any<>::length, std::size_t Align = basic_any<Len>::alignment, typename Type>
[[nodiscard]] basic_any<Len, Align> forward_as_any(Type &&value) {
    return basic_any<Len, Align>{std::in_place_type<Type &&>, std::forward<Type>(value)};
}

} // namespace entt

#endif

////////////////////// END OF external/entt/core/any.hpp ///////////////////////

//////////////////// START OF external/entt/entity/fwd.hpp /////////////////////

#ifndef ENTT_ENTITY_FWD_HPP
#define ENTT_ENTITY_FWD_HPP

#include <cstdint>
#include <memory>
#include <type_traits>

namespace entt {

/*! @brief Default entity identifier. */
enum class entity : id_type {};

/*! @brief Storage deletion policy. */
enum class deletion_policy : std::uint8_t {
    /*! @brief Swap-and-pop deletion policy. */
    swap_and_pop = 0u,
    /*! @brief In-place deletion policy. */
    in_place = 1u
};

template<typename Entity = entity, typename = std::allocator<Entity>>
class basic_sparse_set;

template<typename Type, typename = entity, typename = std::allocator<Type>, typename = void>
class basic_storage;

template<typename Type>
class sigh_mixin;

/**
 * @brief Provides a common way to define storage types.
 * @tparam Type Storage value type.
 * @tparam Entity A valid entity type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Type, typename Entity = entity, typename Allocator = std::allocator<Type>, typename = void>
struct storage_type {
    /*! @brief Type-to-storage conversion result. */
    using type = sigh_mixin<basic_storage<Type, Entity, Allocator>>;
};

/**
 * @brief Helper type.
 * @tparam Args Arguments to forward.
 */
template<typename... Args>
using storage_type_t = typename storage_type<Args...>::type;

/**
 * Type-to-storage conversion utility that preserves constness.
 * @tparam Type Storage value type, eventually const.
 * @tparam Entity A valid entity type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Type, typename Entity = entity, typename Allocator = std::allocator<std::remove_const_t<Type>>>
struct storage_for {
    /*! @brief Type-to-storage conversion result. */
    using type = constness_as_t<storage_type_t<std::remove_const_t<Type>, Entity, Allocator>, Type>;
};

/**
 * @brief Helper type.
 * @tparam Args Arguments to forward.
 */
template<typename... Args>
using storage_for_t = typename storage_for<Args...>::type;

template<typename Entity = entity, typename = std::allocator<Entity>>
class basic_registry;

template<typename, typename, typename = void>
class basic_view;

template<typename Type, typename = std::allocator<Type *>>
class basic_runtime_view;

template<typename, typename, typename>
class basic_group;

template<typename, typename Mask = std::uint32_t, typename = std::allocator<Mask>>
class basic_observer;

template<typename>
class basic_organizer;

template<typename, typename...>
struct basic_handle;

template<typename>
class basic_snapshot;

template<typename>
class basic_snapshot_loader;

template<typename>
class basic_continuous_loader;

/**
 * @brief Alias for exclusion lists.
 * @tparam Type List of types.
 */
template<typename... Type>
struct exclude_t final: type_list<Type...> {
    /*! @brief Default constructor. */
    explicit constexpr exclude_t() {}
};

/**
 * @brief Variable template for exclusion lists.
 * @tparam Type List of types.
 */
template<typename... Type>
inline constexpr exclude_t<Type...> exclude{};

/**
 * @brief Alias for lists of observed components.
 * @tparam Type List of types.
 */
template<typename... Type>
struct get_t final: type_list<Type...> {
    /*! @brief Default constructor. */
    explicit constexpr get_t() {}
};

/**
 * @brief Variable template for lists of observed components.
 * @tparam Type List of types.
 */
template<typename... Type>
inline constexpr get_t<Type...> get{};

/**
 * @brief Alias for lists of owned components.
 * @tparam Type List of types.
 */
template<typename... Type>
struct owned_t final: type_list<Type...> {
    /*! @brief Default constructor. */
    explicit constexpr owned_t() {}
};

/**
 * @brief Variable template for lists of owned components.
 * @tparam Type List of types.
 */
template<typename... Type>
inline constexpr owned_t<Type...> owned{};

/**
 * @brief Applies a given _function_ to a get list and generate a new list.
 * @tparam Type Types provided by the get list.
 * @tparam Op Unary operation as template class with a type member named `type`.
 */
template<typename... Type, template<typename...> class Op>
struct type_list_transform<get_t<Type...>, Op> {
    /*! @brief Resulting get list after applying the transform function. */
    using type = get_t<typename Op<Type>::type...>;
};

/**
 * @brief Applies a given _function_ to an exclude list and generate a new list.
 * @tparam Type Types provided by the exclude list.
 * @tparam Op Unary operation as template class with a type member named `type`.
 */
template<typename... Type, template<typename...> class Op>
struct type_list_transform<exclude_t<Type...>, Op> {
    /*! @brief Resulting exclude list after applying the transform function. */
    using type = exclude_t<typename Op<Type>::type...>;
};

/**
 * @brief Applies a given _function_ to an owned list and generate a new list.
 * @tparam Type Types provided by the owned list.
 * @tparam Op Unary operation as template class with a type member named `type`.
 */
template<typename... Type, template<typename...> class Op>
struct type_list_transform<owned_t<Type...>, Op> {
    /*! @brief Resulting owned list after applying the transform function. */
    using type = owned_t<typename Op<Type>::type...>;
};

/*! @brief Alias declaration for the most common use case. */
using sparse_set = basic_sparse_set<>;

/**
 * @brief Alias declaration for the most common use case.
 * @tparam Type Type of objects assigned to the entities.
 */
template<typename Type>
using storage = basic_storage<Type>;

/*! @brief Alias declaration for the most common use case. */
using registry = basic_registry<>;

/*! @brief Alias declaration for the most common use case. */
using observer = basic_observer<registry>;

/*! @brief Alias declaration for the most common use case. */
using organizer = basic_organizer<registry>;

/*! @brief Alias declaration for the most common use case. */
using handle = basic_handle<registry>;

/*! @brief Alias declaration for the most common use case. */
using const_handle = basic_handle<const registry>;

/**
 * @brief Alias declaration for the most common use case.
 * @tparam Args Other template parameters.
 */
template<typename... Args>
using handle_view = basic_handle<registry, Args...>;

/**
 * @brief Alias declaration for the most common use case.
 * @tparam Args Other template parameters.
 */
template<typename... Args>
using const_handle_view = basic_handle<const registry, Args...>;

/*! @brief Alias declaration for the most common use case. */
using snapshot = basic_snapshot<registry>;

/*! @brief Alias declaration for the most common use case. */
using snapshot_loader = basic_snapshot_loader<registry>;

/*! @brief Alias declaration for the most common use case. */
using continuous_loader = basic_continuous_loader<registry>;

/**
 * @brief Alias declaration for the most common use case.
 * @tparam Get Types of storage iterated by the view.
 * @tparam Exclude Types of storage used to filter the view.
 */
template<typename Get, typename Exclude = exclude_t<>>
using view = basic_view<type_list_transform_t<Get, storage_for>, type_list_transform_t<Exclude, storage_for>>;

/*! @brief Alias declaration for the most common use case. */
using runtime_view = basic_runtime_view<sparse_set>;

/*! @brief Alias declaration for the most common use case. */
using const_runtime_view = basic_runtime_view<const sparse_set>;

/**
 * @brief Alias declaration for the most common use case.
 * @tparam Owned Types of storage _owned_ by the group.
 * @tparam Get Types of storage _observed_ by the group.
 * @tparam Exclude Types of storage used to filter the group.
 */
template<typename Owned, typename Get, typename Exclude>
using group = basic_group<type_list_transform_t<Owned, storage_for>, type_list_transform_t<Get, storage_for>, type_list_transform_t<Exclude, storage_for>>;

} // namespace entt

#endif

///////////////////// END OF external/entt/entity/fwd.hpp //////////////////////

/////////////////// START OF external/entt/entity/entity.hpp ///////////////////

#ifndef ENTT_ENTITY_ENTITY_HPP
#define ENTT_ENTITY_ENTITY_HPP

#include <cstddef>
#include <cstdint>
#include <type_traits>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

// waiting for C++20 (and std::popcount)
template<typename Type>
static constexpr int popcount(Type value) noexcept {
    return value ? (int(value & 1) + popcount(value >> 1)) : 0;
}

template<typename, typename = void>
struct entt_traits;

template<typename Type>
struct entt_traits<Type, std::enable_if_t<std::is_enum_v<Type>>>
    : entt_traits<std::underlying_type_t<Type>> {
    using value_type = Type;
};

template<typename Type>
struct entt_traits<Type, std::enable_if_t<std::is_class_v<Type>>>
    : entt_traits<typename Type::entity_type> {
    using value_type = Type;
};

template<>
struct entt_traits<std::uint32_t> {
    using value_type = std::uint32_t;

    using entity_type = std::uint32_t;
    using version_type = std::uint16_t;

    static constexpr entity_type entity_mask = 0xFFFFF;
    static constexpr entity_type version_mask = 0xFFF;
};

template<>
struct entt_traits<std::uint64_t> {
    using value_type = std::uint64_t;

    using entity_type = std::uint64_t;
    using version_type = std::uint32_t;

    static constexpr entity_type entity_mask = 0xFFFFFFFF;
    static constexpr entity_type version_mask = 0xFFFFFFFF;
};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Common basic entity traits implementation.
 * @tparam Traits Actual entity traits to use.
 */
template<typename Traits>
class basic_entt_traits {
    static constexpr auto length = internal::popcount(Traits::entity_mask);

    static_assert(Traits::entity_mask && ((typename Traits::entity_type{1} << length) == (Traits::entity_mask + 1)), "Invalid entity mask");
    static_assert((typename Traits::entity_type{1} << internal::popcount(Traits::version_mask)) == (Traits::version_mask + 1), "Invalid version mask");

public:
    /*! @brief Value type. */
    using value_type = typename Traits::value_type;
    /*! @brief Underlying entity type. */
    using entity_type = typename Traits::entity_type;
    /*! @brief Underlying version type. */
    using version_type = typename Traits::version_type;

    /*! @brief Entity mask size. */
    static constexpr entity_type entity_mask = Traits::entity_mask;
    /*! @brief Version mask size */
    static constexpr entity_type version_mask = Traits::version_mask;

    /**
     * @brief Converts an entity to its underlying type.
     * @param value The value to convert.
     * @return The integral representation of the given value.
     */
    [[nodiscard]] static constexpr entity_type to_integral(const value_type value) noexcept {
        return static_cast<entity_type>(value);
    }

    /**
     * @brief Returns the entity part once converted to the underlying type.
     * @param value The value to convert.
     * @return The integral representation of the entity part.
     */
    [[nodiscard]] static constexpr entity_type to_entity(const value_type value) noexcept {
        return (to_integral(value) & entity_mask);
    }

    /**
     * @brief Returns the version part once converted to the underlying type.
     * @param value The value to convert.
     * @return The integral representation of the version part.
     */
    [[nodiscard]] static constexpr version_type to_version(const value_type value) noexcept {
        return static_cast<version_type>(to_integral(value) >> length);
    }

    /**
     * @brief Returns the successor of a given identifier.
     * @param value The identifier of which to return the successor.
     * @return The successor of the given identifier.
     */
    [[nodiscard]] static constexpr value_type next(const value_type value) noexcept {
        const auto vers = to_version(value) + 1;
        return construct(to_entity(value), static_cast<version_type>(vers + (vers == version_mask)));
    }

    /**
     * @brief Constructs an identifier from its parts.
     *
     * If the version part is not provided, a tombstone is returned.<br/>
     * If the entity part is not provided, a null identifier is returned.
     *
     * @param entity The entity part of the identifier.
     * @param version The version part of the identifier.
     * @return A properly constructed identifier.
     */
    [[nodiscard]] static constexpr value_type construct(const entity_type entity, const version_type version) noexcept {
        return value_type{(entity & entity_mask) | (static_cast<entity_type>(version) << length)};
    }

    /**
     * @brief Combines two identifiers in a single one.
     *
     * The returned identifier is a copy of the first element except for its
     * version, which is taken from the second element.
     *
     * @param lhs The identifier from which to take the entity part.
     * @param rhs The identifier from which to take the version part.
     * @return A properly constructed identifier.
     */
    [[nodiscard]] static constexpr value_type combine(const entity_type lhs, const entity_type rhs) noexcept {
        constexpr auto mask = (version_mask << length);
        return value_type{(lhs & entity_mask) | (rhs & mask)};
    }
};

/**
 * @brief Entity traits.
 * @tparam Type Type of identifier.
 */
template<typename Type>
struct entt_traits: basic_entt_traits<internal::entt_traits<Type>> {
    /*! @brief Base type. */
    using base_type = basic_entt_traits<internal::entt_traits<Type>>;
    /*! @brief Page size, default is `ENTT_SPARSE_PAGE`. */
    static constexpr std::size_t page_size = ENTT_SPARSE_PAGE;
};

/**
 * @copydoc entt_traits<Entity>::to_integral
 * @tparam Entity The value type.
 */
template<typename Entity>
[[nodiscard]] constexpr typename entt_traits<Entity>::entity_type to_integral(const Entity value) noexcept {
    return entt_traits<Entity>::to_integral(value);
}

/**
 * @copydoc entt_traits<Entity>::to_entity
 * @tparam Entity The value type.
 */
template<typename Entity>
[[nodiscard]] constexpr typename entt_traits<Entity>::entity_type to_entity(const Entity value) noexcept {
    return entt_traits<Entity>::to_entity(value);
}

/**
 * @copydoc entt_traits<Entity>::to_version
 * @tparam Entity The value type.
 */
template<typename Entity>
[[nodiscard]] constexpr typename entt_traits<Entity>::version_type to_version(const Entity value) noexcept {
    return entt_traits<Entity>::to_version(value);
}

/*! @brief Null object for all identifiers.  */
struct null_t {
    /**
     * @brief Converts the null object to identifiers of any type.
     * @tparam Entity Type of identifier.
     * @return The null representation for the given type.
     */
    template<typename Entity>
    [[nodiscard]] constexpr operator Entity() const noexcept {
        using traits_type = entt_traits<Entity>;
        constexpr auto value = traits_type::construct(traits_type::entity_mask, traits_type::version_mask);
        return value;
    }

    /**
     * @brief Compares two null objects.
     * @param other A null object.
     * @return True in all cases.
     */
    [[nodiscard]] constexpr bool operator==([[maybe_unused]] const null_t other) const noexcept {
        return true;
    }

    /**
     * @brief Compares two null objects.
     * @param other A null object.
     * @return False in all cases.
     */
    [[nodiscard]] constexpr bool operator!=([[maybe_unused]] const null_t other) const noexcept {
        return false;
    }

    /**
     * @brief Compares a null object and an identifier of any type.
     * @tparam Entity Type of identifier.
     * @param entity Identifier with which to compare.
     * @return False if the two elements differ, true otherwise.
     */
    template<typename Entity>
    [[nodiscard]] constexpr bool operator==(const Entity entity) const noexcept {
        using traits_type = entt_traits<Entity>;
        return traits_type::to_entity(entity) == traits_type::to_entity(*this);
    }

    /**
     * @brief Compares a null object and an identifier of any type.
     * @tparam Entity Type of identifier.
     * @param entity Identifier with which to compare.
     * @return True if the two elements differ, false otherwise.
     */
    template<typename Entity>
    [[nodiscard]] constexpr bool operator!=(const Entity entity) const noexcept {
        return !(entity == *this);
    }
};

/**
 * @brief Compares a null object and an identifier of any type.
 * @tparam Entity Type of identifier.
 * @param entity Identifier with which to compare.
 * @param other A null object yet to be converted.
 * @return False if the two elements differ, true otherwise.
 */
template<typename Entity>
[[nodiscard]] constexpr bool operator==(const Entity entity, const null_t other) noexcept {
    return other.operator==(entity);
}

/**
 * @brief Compares a null object and an identifier of any type.
 * @tparam Entity Type of identifier.
 * @param entity Identifier with which to compare.
 * @param other A null object yet to be converted.
 * @return True if the two elements differ, false otherwise.
 */
template<typename Entity>
[[nodiscard]] constexpr bool operator!=(const Entity entity, const null_t other) noexcept {
    return !(other == entity);
}

/*! @brief Tombstone object for all identifiers.  */
struct tombstone_t {
    /**
     * @brief Converts the tombstone object to identifiers of any type.
     * @tparam Entity Type of identifier.
     * @return The tombstone representation for the given type.
     */
    template<typename Entity>
    [[nodiscard]] constexpr operator Entity() const noexcept {
        using traits_type = entt_traits<Entity>;
        constexpr auto value = traits_type::construct(traits_type::entity_mask, traits_type::version_mask);
        return value;
    }

    /**
     * @brief Compares two tombstone objects.
     * @param other A tombstone object.
     * @return True in all cases.
     */
    [[nodiscard]] constexpr bool operator==([[maybe_unused]] const tombstone_t other) const noexcept {
        return true;
    }

    /**
     * @brief Compares two tombstone objects.
     * @param other A tombstone object.
     * @return False in all cases.
     */
    [[nodiscard]] constexpr bool operator!=([[maybe_unused]] const tombstone_t other) const noexcept {
        return false;
    }

    /**
     * @brief Compares a tombstone object and an identifier of any type.
     * @tparam Entity Type of identifier.
     * @param entity Identifier with which to compare.
     * @return False if the two elements differ, true otherwise.
     */
    template<typename Entity>
    [[nodiscard]] constexpr bool operator==(const Entity entity) const noexcept {
        using traits_type = entt_traits<Entity>;
        return traits_type::to_version(entity) == traits_type::to_version(*this);
    }

    /**
     * @brief Compares a tombstone object and an identifier of any type.
     * @tparam Entity Type of identifier.
     * @param entity Identifier with which to compare.
     * @return True if the two elements differ, false otherwise.
     */
    template<typename Entity>
    [[nodiscard]] constexpr bool operator!=(const Entity entity) const noexcept {
        return !(entity == *this);
    }
};

/**
 * @brief Compares a tombstone object and an identifier of any type.
 * @tparam Entity Type of identifier.
 * @param entity Identifier with which to compare.
 * @param other A tombstone object yet to be converted.
 * @return False if the two elements differ, true otherwise.
 */
template<typename Entity>
[[nodiscard]] constexpr bool operator==(const Entity entity, const tombstone_t other) noexcept {
    return other.operator==(entity);
}

/**
 * @brief Compares a tombstone object and an identifier of any type.
 * @tparam Entity Type of identifier.
 * @param entity Identifier with which to compare.
 * @param other A tombstone object yet to be converted.
 * @return True if the two elements differ, false otherwise.
 */
template<typename Entity>
[[nodiscard]] constexpr bool operator!=(const Entity entity, const tombstone_t other) noexcept {
    return !(other == entity);
}

/**
 * @brief Compile-time constant for null entities.
 *
 * There exist implicit conversions from this variable to identifiers of any
 * allowed type. Similarly, there exist comparison operators between the null
 * entity and any other identifier.
 */
inline constexpr null_t null{};

/**
 * @brief Compile-time constant for tombstone entities.
 *
 * There exist implicit conversions from this variable to identifiers of any
 * allowed type. Similarly, there exist comparison operators between the
 * tombstone entity and any other identifier.
 */
inline constexpr tombstone_t tombstone{};

} // namespace entt

#endif

//////////////////// END OF external/entt/entity/entity.hpp ////////////////////

///////////////// START OF external/entt/entity/sparse_set.hpp /////////////////

#ifndef ENTT_ENTITY_SPARSE_SET_HPP
#define ENTT_ENTITY_SPARSE_SET_HPP

#include <cstddef>
#include <iterator>
#include <memory>
#include <type_traits>
#include <utility>
#include <vector>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Container>
struct sparse_set_iterator final {
    using value_type = typename Container::value_type;
    using pointer = typename Container::const_pointer;
    using reference = typename Container::const_reference;
    using difference_type = typename Container::difference_type;
    using iterator_category = std::random_access_iterator_tag;

    constexpr sparse_set_iterator() noexcept
        : packed{},
          offset{} {}

    constexpr sparse_set_iterator(const Container &ref, const difference_type idx) noexcept
        : packed{std::addressof(ref)},
          offset{idx} {}

    constexpr sparse_set_iterator &operator++() noexcept {
        return --offset, *this;
    }

    constexpr sparse_set_iterator operator++(int) noexcept {
        sparse_set_iterator orig = *this;
        return ++(*this), orig;
    }

    constexpr sparse_set_iterator &operator--() noexcept {
        return ++offset, *this;
    }

    constexpr sparse_set_iterator operator--(int) noexcept {
        sparse_set_iterator orig = *this;
        return operator--(), orig;
    }

    constexpr sparse_set_iterator &operator+=(const difference_type value) noexcept {
        offset -= value;
        return *this;
    }

    constexpr sparse_set_iterator operator+(const difference_type value) const noexcept {
        sparse_set_iterator copy = *this;
        return (copy += value);
    }

    constexpr sparse_set_iterator &operator-=(const difference_type value) noexcept {
        return (*this += -value);
    }

    constexpr sparse_set_iterator operator-(const difference_type value) const noexcept {
        return (*this + -value);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
        return packed->data()[index() - value];
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return packed->data() + index();
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *operator->();
    }

    [[nodiscard]] constexpr pointer data() const noexcept {
        return packed ? packed->data() : nullptr;
    }

    [[nodiscard]] constexpr difference_type index() const noexcept {
        return offset - 1;
    }

private:
    const Container *packed;
    difference_type offset;
};

template<typename Container>
[[nodiscard]] constexpr std::ptrdiff_t operator-(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
    return rhs.index() - lhs.index();
}

template<typename Container>
[[nodiscard]] constexpr bool operator==(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
    return lhs.index() == rhs.index();
}

template<typename Container>
[[nodiscard]] constexpr bool operator!=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
    return !(lhs == rhs);
}

template<typename Container>
[[nodiscard]] constexpr bool operator<(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
    return lhs.index() > rhs.index();
}

template<typename Container>
[[nodiscard]] constexpr bool operator>(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
    return rhs < lhs;
}

template<typename Container>
[[nodiscard]] constexpr bool operator<=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
    return !(lhs > rhs);
}

template<typename Container>
[[nodiscard]] constexpr bool operator>=(const sparse_set_iterator<Container> &lhs, const sparse_set_iterator<Container> &rhs) noexcept {
    return !(lhs < rhs);
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Basic sparse set implementation.
 *
 * Sparse set or packed array or whatever is the name users give it.<br/>
 * Two arrays: an _external_ one and an _internal_ one; a _sparse_ one and a
 * _packed_ one; one used for direct access through contiguous memory, the other
 * one used to get the data through an extra level of indirection.<br/>
 * This type of data structure is widely documented in the literature and on the
 * web. This is nothing more than a customized implementation suitable for the
 * purpose of the framework.
 *
 * @note
 * Internal data structures arrange elements to maximize performance. There are
 * no guarantees that entities are returned in the insertion order when iterate
 * a sparse set. Do not make assumption on the order in any case.
 *
 * @tparam Entity A valid entity type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Entity, typename Allocator>
class basic_sparse_set {
    using alloc_traits = std::allocator_traits<Allocator>;
    static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
    using sparse_container_type = std::vector<typename alloc_traits::pointer, typename alloc_traits::template rebind_alloc<typename alloc_traits::pointer>>;
    using packed_container_type = std::vector<Entity, Allocator>;

    [[nodiscard]] auto sparse_ptr(const Entity entt) const {
        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
        const auto page = pos / traits_type::page_size;
        return (page < sparse.size() && sparse[page]) ? (sparse[page] + fast_mod(pos, traits_type::page_size)) : nullptr;
    }

    [[nodiscard]] auto &sparse_ref(const Entity entt) const {
        ENTT_ASSERT(sparse_ptr(entt), "Invalid element");
        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
        return sparse[pos / traits_type::page_size][fast_mod(pos, traits_type::page_size)];
    }

    [[nodiscard]] auto to_iterator(const Entity entt) const {
        return --(end() - index(entt));
    }

    [[nodiscard]] auto &assure_at_least(const Entity entt) {
        const auto pos = static_cast<size_type>(traits_type::to_entity(entt));
        const auto page = pos / traits_type::page_size;

        if(!(page < sparse.size())) {
            sparse.resize(page + 1u, nullptr);
        }

        if(!sparse[page]) {
            auto page_allocator{packed.get_allocator()};
            sparse[page] = alloc_traits::allocate(page_allocator, traits_type::page_size);
            std::uninitialized_fill(sparse[page], sparse[page] + traits_type::page_size, null);
        }

        auto &elem = sparse[page][fast_mod(pos, traits_type::page_size)];
        ENTT_ASSERT(elem == null, "Slot not available");
        return elem;
    }

    void release_sparse_pages() {
        auto page_allocator{packed.get_allocator()};

        for(auto &&page: sparse) {
            if(page != nullptr) {
                std::destroy(page, page + traits_type::page_size);
                alloc_traits::deallocate(page_allocator, page, traits_type::page_size);
                page = nullptr;
            }
        }
    }

private:
    virtual const void *get_at(const std::size_t) const {
        return nullptr;
    }

    virtual void swap_or_move(const std::size_t, const std::size_t) {}

protected:
    /*! @brief Random access iterator type. */
    using basic_iterator = internal::sparse_set_iterator<packed_container_type>;

    /**
     * @brief Swaps two items at specific locations.
     * @param lhs A position to move from.
     * @param rhs The other position to move from.
     */
    void swap_at(const std::size_t lhs, const std::size_t rhs) {
        const auto entity = static_cast<typename traits_type::entity_type>(lhs);
        const auto other = static_cast<typename traits_type::entity_type>(rhs);

        sparse_ref(packed[lhs]) = traits_type::combine(other, traits_type::to_integral(packed[lhs]));
        sparse_ref(packed[rhs]) = traits_type::combine(entity, traits_type::to_integral(packed[rhs]));

        using std::swap;
        swap(packed[lhs], packed[rhs]);
    }

    /**
     * @brief Erases an entity from a sparse set.
     * @param it An iterator to the element to pop.
     */
    void swap_and_pop(const basic_iterator it) {
        ENTT_ASSERT(mode == deletion_policy::swap_and_pop, "Deletion policy mismatched");
        auto &self = sparse_ref(*it);
        const auto entt = traits_type::to_entity(self);
        sparse_ref(packed.back()) = traits_type::combine(entt, traits_type::to_integral(packed.back()));
        packed[static_cast<size_type>(entt)] = packed.back();
        // unnecessary but it helps to detect nasty bugs
        ENTT_ASSERT((packed.back() = null, true), "");
        // lazy self-assignment guard
        self = null;
        packed.pop_back();
    }

    /**
     * @brief Erases an entity from a sparse set.
     * @param it An iterator to the element to pop.
     */
    void in_place_pop(const basic_iterator it) {
        ENTT_ASSERT(mode == deletion_policy::in_place, "Deletion policy mismatched");
        const auto entt = traits_type::to_entity(std::exchange(sparse_ref(*it), null));
        packed[static_cast<size_type>(entt)] = std::exchange(free_list, traits_type::combine(entt, tombstone));
    }

protected:
    /**
     * @brief Erases entities from a sparse set.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    virtual void pop(basic_iterator first, basic_iterator last) {
        if(mode == deletion_policy::swap_and_pop) {
            for(; first != last; ++first) {
                swap_and_pop(first);
            }
        } else {
            for(; first != last; ++first) {
                in_place_pop(first);
            }
        }
    }

    /*! @brief Erases all entities of a sparse set. */
    virtual void pop_all() {
        if(const auto prev = std::exchange(free_list, tombstone); prev == null) {
            for(auto first = begin(); !(first.index() < 0); ++first) {
                sparse_ref(*first) = null;
            }
        } else {
            for(auto first = begin(); !(first.index() < 0); ++first) {
                if(*first != tombstone) {
                    sparse_ref(*first) = null;
                }
            }
        }

        packed.clear();
    }

    /**
     * @brief Assigns an entity to a sparse set.
     * @param entt A valid identifier.
     * @param force_back Force back insertion.
     * @return Iterator pointing to the emplaced element.
     */
    virtual basic_iterator try_emplace(const Entity entt, const bool force_back, const void * = nullptr) {
        ENTT_ASSERT(!contains(entt), "Set already contains entity");

        if(auto &elem = assure_at_least(entt); free_list == null || force_back) {
            packed.push_back(entt);
            elem = traits_type::combine(static_cast<typename traits_type::entity_type>(packed.size() - 1u), traits_type::to_integral(entt));
            return begin();
        } else {
            const auto pos = static_cast<size_type>(traits_type::to_entity(free_list));
            elem = traits_type::combine(traits_type::to_integral(free_list), traits_type::to_integral(entt));
            free_list = std::exchange(packed[pos], entt);
            return --(end() - pos);
        }
    }

public:
    /*! @brief Entity traits. */
    using traits_type = entt_traits<Entity>;
    /*! @brief Underlying entity identifier. */
    using entity_type = typename traits_type::value_type;
    /*! @brief Underlying version type. */
    using version_type = typename traits_type::version_type;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Pointer type to contained entities. */
    using pointer = typename packed_container_type::const_pointer;
    /*! @brief Random access iterator type. */
    using iterator = basic_iterator;
    /*! @brief Constant random access iterator type. */
    using const_iterator = iterator;
    /*! @brief Reverse iterator type. */
    using reverse_iterator = std::reverse_iterator<iterator>;
    /*! @brief Constant reverse iterator type. */
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    /*! @brief Default constructor. */
    basic_sparse_set()
        : basic_sparse_set{type_id<void>()} {}

    /**
     * @brief Constructs an empty container with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit basic_sparse_set(const allocator_type &allocator)
        : basic_sparse_set{type_id<void>(), deletion_policy::swap_and_pop, allocator} {}

    /**
     * @brief Constructs an empty container with the given policy and allocator.
     * @param pol Type of deletion policy.
     * @param allocator The allocator to use (possibly default-constructed).
     */
    explicit basic_sparse_set(deletion_policy pol, const allocator_type &allocator = {})
        : basic_sparse_set{type_id<void>(), pol, allocator} {}

    /**
     * @brief Constructs an empty container with the given value type, policy
     * and allocator.
     * @param elem Returned value type, if any.
     * @param pol Type of deletion policy.
     * @param allocator The allocator to use (possibly default-constructed).
     */
    explicit basic_sparse_set(const type_info &elem, deletion_policy pol = deletion_policy::swap_and_pop, const allocator_type &allocator = {})
        : sparse{allocator},
          packed{allocator},
          info{&elem},
          free_list{tombstone},
          mode{pol} {}

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    basic_sparse_set(basic_sparse_set &&other) noexcept
        : sparse{std::move(other.sparse)},
          packed{std::move(other.packed)},
          info{other.info},
          free_list{std::exchange(other.free_list, tombstone)},
          mode{other.mode} {}

    /**
     * @brief Allocator-extended move constructor.
     * @param other The instance to move from.
     * @param allocator The allocator to use.
     */
    basic_sparse_set(basic_sparse_set &&other, const allocator_type &allocator) noexcept
        : sparse{std::move(other.sparse), allocator},
          packed{std::move(other.packed), allocator},
          info{other.info},
          free_list{std::exchange(other.free_list, tombstone)},
          mode{other.mode} {
        ENTT_ASSERT(alloc_traits::is_always_equal::value || packed.get_allocator() == other.packed.get_allocator(), "Copying a sparse set is not allowed");
    }

    /*! @brief Default destructor. */
    virtual ~basic_sparse_set() {
        release_sparse_pages();
    }

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This sparse set.
     */
    basic_sparse_set &operator=(basic_sparse_set &&other) noexcept {
        ENTT_ASSERT(alloc_traits::is_always_equal::value || packed.get_allocator() == other.packed.get_allocator(), "Copying a sparse set is not allowed");

        release_sparse_pages();
        sparse = std::move(other.sparse);
        packed = std::move(other.packed);
        info = other.info;
        free_list = std::exchange(other.free_list, tombstone);
        mode = other.mode;
        return *this;
    }

    /**
     * @brief Exchanges the contents with those of a given sparse set.
     * @param other Sparse set to exchange the content with.
     */
    void swap(basic_sparse_set &other) {
        using std::swap;
        swap(sparse, other.sparse);
        swap(packed, other.packed);
        swap(info, other.info);
        swap(free_list, other.free_list);
        swap(mode, other.mode);
    }

    /**
     * @brief Returns the associated allocator.
     * @return The associated allocator.
     */
    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return packed.get_allocator();
    }

    /**
     * @brief Returns the deletion policy of a sparse set.
     * @return The deletion policy of the sparse set.
     */
    [[nodiscard]] deletion_policy policy() const noexcept {
        return mode;
    }

    /**
     * @brief Increases the capacity of a sparse set.
     *
     * If the new capacity is greater than the current capacity, new storage is
     * allocated, otherwise the method does nothing.
     *
     * @param cap Desired capacity.
     */
    virtual void reserve(const size_type cap) {
        packed.reserve(cap);
    }

    /**
     * @brief Returns the number of elements that a sparse set has currently
     * allocated space for.
     * @return Capacity of the sparse set.
     */
    [[nodiscard]] virtual size_type capacity() const noexcept {
        return packed.capacity();
    }

    /*! @brief Requests the removal of unused capacity. */
    virtual void shrink_to_fit() {
        packed.shrink_to_fit();
    }

    /**
     * @brief Returns the extent of a sparse set.
     *
     * The extent of a sparse set is also the size of the internal sparse array.
     * There is no guarantee that the internal packed array has the same size.
     * Usually the size of the internal sparse array is equal or greater than
     * the one of the internal packed array.
     *
     * @return Extent of the sparse set.
     */
    [[nodiscard]] size_type extent() const noexcept {
        return sparse.size() * traits_type::page_size;
    }

    /**
     * @brief Returns the number of elements in a sparse set.
     *
     * The number of elements is also the size of the internal packed array.
     * There is no guarantee that the internal sparse array has the same size.
     * Usually the size of the internal sparse array is equal or greater than
     * the one of the internal packed array.
     *
     * @return Number of elements.
     */
    [[nodiscard]] size_type size() const noexcept {
        return packed.size();
    }

    /**
     * @brief Checks whether a sparse set is empty.
     * @return True if the sparse set is empty, false otherwise.
     */
    [[nodiscard]] bool empty() const noexcept {
        return packed.empty();
    }

    /**
     * @brief Checks whether a sparse set is fully packed.
     * @return True if the sparse set is fully packed, false otherwise.
     */
    [[nodiscard]] bool contiguous() const noexcept {
        return (free_list == null);
    }

    /**
     * @brief Direct access to the internal packed array.
     * @return A pointer to the internal packed array.
     */
    [[nodiscard]] pointer data() const noexcept {
        return packed.data();
    }

    /**
     * @brief Returns an iterator to the beginning.
     *
     * If the sparse set is empty, the returned iterator will be equal to
     * `end()`.
     *
     * @return An iterator to the first entity of the sparse set.
     */
    [[nodiscard]] const_iterator begin() const noexcept {
        const auto pos = static_cast<typename iterator::difference_type>(packed.size());
        return iterator{packed, pos};
    }

    /*! @copydoc begin */
    [[nodiscard]] const_iterator cbegin() const noexcept {
        return begin();
    }

    /**
     * @brief Returns an iterator to the end.
     * @return An iterator to the element following the last entity of a sparse
     * set.
     */
    [[nodiscard]] iterator end() const noexcept {
        return iterator{packed, {}};
    }

    /*! @copydoc end */
    [[nodiscard]] const_iterator cend() const noexcept {
        return end();
    }

    /**
     * @brief Returns a reverse iterator to the beginning.
     *
     * If the sparse set is empty, the returned iterator will be equal to
     * `rend()`.
     *
     * @return An iterator to the first entity of the reversed internal packed
     * array.
     */
    [[nodiscard]] const_reverse_iterator rbegin() const noexcept {
        return std::make_reverse_iterator(end());
    }

    /*! @copydoc rbegin */
    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    /**
     * @brief Returns a reverse iterator to the end.
     * @return An iterator to the element following the last entity of the
     * reversed sparse set.
     */
    [[nodiscard]] reverse_iterator rend() const noexcept {
        return std::make_reverse_iterator(begin());
    }

    /*! @copydoc rend */
    [[nodiscard]] const_reverse_iterator crend() const noexcept {
        return rend();
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
        return contains(entt) ? to_iterator(entt) : end();
    }

    /**
     * @brief Checks if a sparse set contains an entity.
     * @param entt A valid identifier.
     * @return True if the sparse set contains the entity, false otherwise.
     */
    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
        const auto elem = sparse_ptr(entt);
        constexpr auto cap = traits_type::to_entity(null);
        // testing versions permits to avoid accessing the packed array
        return elem && (((~cap & traits_type::to_integral(entt)) ^ traits_type::to_integral(*elem)) < cap);
    }

    /**
     * @brief Returns the contained version for an identifier.
     * @param entt A valid identifier.
     * @return The version for the given identifier if present, the tombstone
     * version otherwise.
     */
    [[nodiscard]] version_type current(const entity_type entt) const noexcept {
        const auto elem = sparse_ptr(entt);
        constexpr auto fallback = traits_type::to_version(tombstone);
        return elem ? traits_type::to_version(*elem) : fallback;
    }

    /**
     * @brief Returns the position of an entity in a sparse set.
     *
     * @warning
     * Attempting to get the position of an entity that doesn't belong to the
     * sparse set results in undefined behavior.
     *
     * @param entt A valid identifier.
     * @return The position of the entity in the sparse set.
     */
    [[nodiscard]] size_type index(const entity_type entt) const noexcept {
        ENTT_ASSERT(contains(entt), "Set does not contain entity");
        return static_cast<size_type>(traits_type::to_entity(sparse_ref(entt)));
    }

    /**
     * @brief Returns the entity at specified location, with bounds checking.
     * @param pos The position for which to return the entity.
     * @return The entity at specified location if any, a null entity otherwise.
     */
    [[nodiscard]] entity_type at(const size_type pos) const noexcept {
        return pos < packed.size() ? packed[pos] : null;
    }

    /**
     * @brief Returns the entity at specified location, without bounds checking.
     * @param pos The position for which to return the entity.
     * @return The entity at specified location.
     */
    [[nodiscard]] entity_type operator[](const size_type pos) const noexcept {
        ENTT_ASSERT(pos < packed.size(), "Position is out of bounds");
        return packed[pos];
    }

    /**
     * @brief Returns the element assigned to an entity, if any.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the sparse set results
     * in undefined behavior.
     *
     * @param entt A valid identifier.
     * @return An opaque pointer to the element assigned to the entity, if any.
     */
    [[nodiscard]] const void *value(const entity_type entt) const noexcept {
        return get_at(index(entt));
    }

    /*! @copydoc value */
    [[nodiscard]] void *value(const entity_type entt) noexcept {
        return const_cast<void *>(std::as_const(*this).value(entt));
    }

    /**
     * @brief Assigns an entity to a sparse set.
     *
     * @warning
     * Attempting to assign an entity that already belongs to the sparse set
     * results in undefined behavior.
     *
     * @param entt A valid identifier.
     * @param elem Optional opaque element to forward to mixins, if any.
     * @return Iterator pointing to the emplaced element in case of success, the
     * `end()` iterator otherwise.
     */
    iterator push(const entity_type entt, const void *elem = nullptr) {
        return try_emplace(entt, false, elem);
    }

    /**
     * @brief Assigns one or more entities to a sparse set.
     *
     * @warning
     * Attempting to assign an entity that already belongs to the sparse set
     * results in undefined behavior.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @return Iterator pointing to the first element inserted in case of
     * success, the `end()` iterator otherwise.
     */
    template<typename It>
    iterator push(It first, It last) {
        for(auto it = first; it != last; ++it) {
            try_emplace(*it, true);
        }

        return first == last ? end() : find(*first);
    }

    /**
     * @brief Bump the version number of an entity.
     *
     * @warning
     * Attempting to bump the version of an entity that doesn't belong to the
     * sparse set results in undefined behavior.
     *
     * @param entt A valid identifier.
     * @return The version of the given identifier.
     */
    version_type bump(const entity_type entt) {
        auto &entity = sparse_ref(entt);
        ENTT_ASSERT(entt != tombstone && entity != null, "Cannot set the required version");
        entity = traits_type::combine(traits_type::to_integral(entity), traits_type::to_integral(entt));
        packed[static_cast<size_type>(traits_type::to_entity(entity))] = entt;
        return traits_type::to_version(entt);
    }

    /**
     * @brief Erases an entity from a sparse set.
     *
     * @warning
     * Attempting to erase an entity that doesn't belong to the sparse set
     * results in undefined behavior.
     *
     * @param entt A valid identifier.
     */
    void erase(const entity_type entt) {
        const auto it = to_iterator(entt);
        pop(it, it + 1u);
    }

    /**
     * @brief Erases entities from a set.
     *
     * @sa erase
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename It>
    void erase(It first, It last) {
        if constexpr(std::is_same_v<It, basic_iterator>) {
            pop(first, last);
        } else {
            for(; first != last; ++first) {
                erase(*first);
            }
        }
    }

    /**
     * @brief Removes an entity from a sparse set if it exists.
     * @param entt A valid identifier.
     * @return True if the entity is actually removed, false otherwise.
     */
    bool remove(const entity_type entt) {
        return contains(entt) && (erase(entt), true);
    }

    /**
     * @brief Removes entities from a sparse set if they exist.
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @return The number of entities actually removed.
     */
    template<typename It>
    size_type remove(It first, It last) {
        size_type count{};

        if constexpr(std::is_same_v<It, basic_iterator>) {
            while(first != last) {
                while(first != last && !contains(*first)) {
                    ++first;
                }

                const auto it = first;

                while(first != last && contains(*first)) {
                    ++first;
                }

                count += std::distance(it, first);
                erase(it, first);
            }
        } else {
            for(; first != last; ++first) {
                count += remove(*first);
            }
        }

        return count;
    }

    /*! @brief Removes all tombstones from a sparse set. */
    void compact() {
        size_type from = packed.size();
        for(; from && packed[from - 1u] == tombstone; --from) {}

        for(auto *it = &free_list; *it != null && from; it = std::addressof(packed[traits_type::to_entity(*it)])) {
            if(const size_type to = traits_type::to_entity(*it); to < from) {
                --from;
                swap_or_move(from, to);

                packed[to] = std::exchange(packed[from], tombstone);
                const auto entity = static_cast<typename traits_type::entity_type>(to);
                sparse_ref(packed[to]) = traits_type::combine(entity, traits_type::to_integral(packed[to]));

                *it = traits_type::combine(static_cast<typename traits_type::entity_type>(from), tombstone);
                for(; from && packed[from - 1u] == tombstone; --from) {}
            }
        }

        free_list = tombstone;
        packed.resize(from);
    }

    /**
     * @brief Swaps two entities in a sparse set.
     *
     * For what it's worth, this function affects both the internal sparse array
     * and the internal packed array. Users should not care of that anyway.
     *
     * @warning
     * Attempting to swap entities that don't belong to the sparse set results
     * in undefined behavior.
     *
     * @param lhs A valid identifier.
     * @param rhs A valid identifier.
     */
    void swap_elements(const entity_type lhs, const entity_type rhs) {
        const auto from = index(lhs);
        const auto to = index(rhs);

        // basic no-leak guarantee if swapping throws
        swap_or_move(from, to);
        swap_at(from, to);
    }

    /**
     * @brief Sort the first count elements according to the given comparison
     * function.
     *
     * The comparison function object must return `true` if the first element
     * is _less_ than the second one, `false` otherwise. The signature of the
     * comparison function should be equivalent to the following:
     *
     * @code{.cpp}
     * bool(const Entity, const Entity);
     * @endcode
     *
     * Moreover, the comparison function object shall induce a
     * _strict weak ordering_ on the values.
     *
     * The sort function object must offer a member function template
     * `operator()` that accepts three arguments:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function to use to compare the elements.
     *
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param length Number of elements to sort.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Compare, typename Sort = std_sort, typename... Args>
    void sort_n(const size_type length, Compare compare, Sort algo = Sort{}, Args &&...args) {
        ENTT_ASSERT(!(length > packed.size()), "Length exceeds the number of elements");
        ENTT_ASSERT(free_list == null, "Partial sorting with tombstones is not supported");

        algo(packed.rend() - length, packed.rend(), std::move(compare), std::forward<Args>(args)...);

        for(size_type pos{}; pos < length; ++pos) {
            auto curr = pos;
            auto next = index(packed[curr]);

            while(curr != next) {
                const auto idx = index(packed[next]);
                const auto entt = packed[curr];

                swap_or_move(next, idx);
                const auto entity = static_cast<typename traits_type::entity_type>(curr);
                sparse_ref(entt) = traits_type::combine(entity, traits_type::to_integral(packed[curr]));
                curr = std::exchange(next, idx);
            }
        }
    }

    /**
     * @brief Sort all elements according to the given comparison function.
     *
     * @sa sort_n
     *
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
        compact();
        sort_n(packed.size(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
    }

    /**
     * @brief Sort entities according to their order in another sparse set.
     *
     * Entities that are part of both the sparse sets are ordered internally
     * according to the order they have in `other`.<br/>
     * All the other entities goes to the end of the list and there are no
     * guarantees on their order.
     *
     * @param other The sparse sets that imposes the order of the entities.
     */
    void sort_as(const basic_sparse_set &other) {
        compact();

        const auto to = other.end();
        auto from = other.begin();

        for(auto it = begin(); it.index() && from != to; ++from) {
            if(const auto curr = *from; contains(curr)) {
                if(const auto entt = *it; entt != curr) {
                    // basic no-leak guarantee (with invalid state) if swapping throws
                    swap_elements(entt, curr);
                }

                ++it;
            }
        }
    }

    /*! @brief Clears a sparse set. */
    void clear() {
        pop_all();
        // sanity check to avoid subtle issues due to storage classes
        ENTT_ASSERT((compact(), size()) == 0u, "Non-empty set");
        free_list = tombstone;
        packed.clear();
    }

    /**
     * @brief Returned value type, if any.
     * @return Returned value type, if any.
     */
    const type_info &type() const noexcept {
        return *info;
    }

    /*! @brief Forwards variables to derived classes, if any. */
    virtual void bind(any) noexcept {}

private:
    sparse_container_type sparse;
    packed_container_type packed;
    const type_info *info;
    entity_type free_list;
    deletion_policy mode;
};

} // namespace entt

#endif

////////////////// END OF external/entt/entity/sparse_set.hpp //////////////////

///////////////// START OF external/entt/entity/component.hpp //////////////////

#ifndef ENTT_ENTITY_COMPONENT_HPP
#define ENTT_ENTITY_COMPONENT_HPP

#include <cstddef>
#include <type_traits>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Type, typename = void>
struct in_place_delete: std::bool_constant<!(std::is_move_constructible_v<Type> && std::is_move_assignable_v<Type>)> {};

template<>
struct in_place_delete<void>: std::false_type {};

template<typename Type>
struct in_place_delete<Type, std::enable_if_t<Type::in_place_delete>>
    : std::true_type {};

template<typename Type, typename = void>
struct page_size: std::integral_constant<std::size_t, !std::is_empty_v<ENTT_ETO_TYPE(Type)> * ENTT_PACKED_PAGE> {};

template<>
struct page_size<void>: std::integral_constant<std::size_t, 0u> {};

template<typename Type>
struct page_size<Type, std::enable_if_t<std::is_convertible_v<decltype(Type::page_size), std::size_t>>>
    : std::integral_constant<std::size_t, Type::page_size> {};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Common way to access various properties of components.
 * @tparam Type Type of component.
 */
template<typename Type, typename = void>
struct component_traits {
    static_assert(std::is_same_v<std::decay_t<Type>, Type>, "Unsupported type");

    /*! @brief Component type. */
    using type = Type;

    /*! @brief Pointer stability, default is `false`. */
    static constexpr bool in_place_delete = internal::in_place_delete<Type>::value;
    /*! @brief Page size, default is `ENTT_PACKED_PAGE` for non-empty types. */
    static constexpr std::size_t page_size = internal::page_size<Type>::value;
};

} // namespace entt

#endif

////////////////// END OF external/entt/entity/component.hpp ///////////////////

////////////////// START OF external/entt/entity/storage.hpp ///////////////////

#ifndef ENTT_ENTITY_STORAGE_HPP
#define ENTT_ENTITY_STORAGE_HPP

#include <cstddef>
#include <iterator>
#include <memory>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Container, std::size_t Size>
class storage_iterator final {
    friend storage_iterator<const Container, Size>;

    using container_type = std::remove_const_t<Container>;
    using alloc_traits = std::allocator_traits<typename container_type::allocator_type>;

    using iterator_traits = std::iterator_traits<std::conditional_t<
        std::is_const_v<Container>,
        typename alloc_traits::template rebind_traits<typename std::pointer_traits<typename container_type::value_type>::element_type>::const_pointer,
        typename alloc_traits::template rebind_traits<typename std::pointer_traits<typename container_type::value_type>::element_type>::pointer>>;

public:
    using value_type = typename iterator_traits::value_type;
    using pointer = typename iterator_traits::pointer;
    using reference = typename iterator_traits::reference;
    using difference_type = typename iterator_traits::difference_type;
    using iterator_category = std::random_access_iterator_tag;

    constexpr storage_iterator() noexcept = default;

    constexpr storage_iterator(Container *ref, const difference_type idx) noexcept
        : payload{ref},
          offset{idx} {}

    template<bool Const = std::is_const_v<Container>, typename = std::enable_if_t<Const>>
    constexpr storage_iterator(const storage_iterator<std::remove_const_t<Container>, Size> &other) noexcept
        : storage_iterator{other.payload, other.offset} {}

    constexpr storage_iterator &operator++() noexcept {
        return --offset, *this;
    }

    constexpr storage_iterator operator++(int) noexcept {
        storage_iterator orig = *this;
        return ++(*this), orig;
    }

    constexpr storage_iterator &operator--() noexcept {
        return ++offset, *this;
    }

    constexpr storage_iterator operator--(int) noexcept {
        storage_iterator orig = *this;
        return operator--(), orig;
    }

    constexpr storage_iterator &operator+=(const difference_type value) noexcept {
        offset -= value;
        return *this;
    }

    constexpr storage_iterator operator+(const difference_type value) const noexcept {
        storage_iterator copy = *this;
        return (copy += value);
    }

    constexpr storage_iterator &operator-=(const difference_type value) noexcept {
        return (*this += -value);
    }

    constexpr storage_iterator operator-(const difference_type value) const noexcept {
        return (*this + -value);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
        const auto pos = index() - value;
        return (*payload)[pos / Size][fast_mod(pos, Size)];
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        const auto pos = index();
        return (*payload)[pos / Size] + fast_mod(pos, Size);
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *operator->();
    }

    [[nodiscard]] constexpr difference_type index() const noexcept {
        return offset - 1;
    }

private:
    Container *payload;
    difference_type offset;
};

template<typename Lhs, typename Rhs, std::size_t Size>
[[nodiscard]] constexpr std::ptrdiff_t operator-(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
    return rhs.index() - lhs.index();
}

template<typename Lhs, typename Rhs, std::size_t Size>
[[nodiscard]] constexpr bool operator==(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
    return lhs.index() == rhs.index();
}

template<typename Lhs, typename Rhs, std::size_t Size>
[[nodiscard]] constexpr bool operator!=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
    return !(lhs == rhs);
}

template<typename Lhs, typename Rhs, std::size_t Size>
[[nodiscard]] constexpr bool operator<(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
    return lhs.index() > rhs.index();
}

template<typename Lhs, typename Rhs, std::size_t Size>
[[nodiscard]] constexpr bool operator>(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
    return rhs < lhs;
}

template<typename Lhs, typename Rhs, std::size_t Size>
[[nodiscard]] constexpr bool operator<=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
    return !(lhs > rhs);
}

template<typename Lhs, typename Rhs, std::size_t Size>
[[nodiscard]] constexpr bool operator>=(const storage_iterator<Lhs, Size> &lhs, const storage_iterator<Rhs, Size> &rhs) noexcept {
    return !(lhs < rhs);
}

template<typename It, typename... Other>
class extended_storage_iterator final {
    template<typename Iter, typename... Args>
    friend class extended_storage_iterator;

public:
    using iterator_type = It;
    using difference_type = std::ptrdiff_t;
    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::forward_as_tuple(*std::declval<Other>()...)));
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using iterator_category = std::input_iterator_tag;

    constexpr extended_storage_iterator()
        : it{} {}

    constexpr extended_storage_iterator(It base, Other... other)
        : it{base, other...} {}

    template<typename... Args, typename = std::enable_if_t<(!std::is_same_v<Other, Args> && ...) && (std::is_constructible_v<Other, Args> && ...)>>
    constexpr extended_storage_iterator(const extended_storage_iterator<It, Args...> &other)
        : it{other.it} {}

    constexpr extended_storage_iterator &operator++() noexcept {
        return ++std::get<It>(it), (++std::get<Other>(it), ...), *this;
    }

    constexpr extended_storage_iterator operator++(int) noexcept {
        extended_storage_iterator orig = *this;
        return ++(*this), orig;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return operator*();
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return {*std::get<It>(it), *std::get<Other>(it)...};
    }

    [[nodiscard]] constexpr iterator_type base() const noexcept {
        return std::get<It>(it);
    }

    template<typename... Lhs, typename... Rhs>
    friend constexpr bool operator==(const extended_storage_iterator<Lhs...> &, const extended_storage_iterator<Rhs...> &) noexcept;

private:
    std::tuple<It, Other...> it;
};

template<typename... Lhs, typename... Rhs>
[[nodiscard]] constexpr bool operator==(const extended_storage_iterator<Lhs...> &lhs, const extended_storage_iterator<Rhs...> &rhs) noexcept {
    return std::get<0>(lhs.it) == std::get<0>(rhs.it);
}

template<typename... Lhs, typename... Rhs>
[[nodiscard]] constexpr bool operator!=(const extended_storage_iterator<Lhs...> &lhs, const extended_storage_iterator<Rhs...> &rhs) noexcept {
    return !(lhs == rhs);
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Basic storage implementation.
 *
 * Internal data structures arrange elements to maximize performance. There are
 * no guarantees that objects are returned in the insertion order when iterate
 * a storage. Do not make assumption on the order in any case.
 *
 * @warning
 * Empty types aren't explicitly instantiated. Therefore, many of the functions
 * normally available for non-empty types will not be available for empty ones.
 *
 * @tparam Type Type of objects assigned to the entities.
 * @tparam Entity A valid entity type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Type, typename Entity, typename Allocator, typename>
class basic_storage: public basic_sparse_set<Entity, typename std::allocator_traits<Allocator>::template rebind_alloc<Entity>> {
    using alloc_traits = std::allocator_traits<Allocator>;
    static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");
    using container_type = std::vector<typename alloc_traits::pointer, typename alloc_traits::template rebind_alloc<typename alloc_traits::pointer>>;
    using underlying_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
    using underlying_iterator = typename underlying_type::basic_iterator;

    static constexpr bool is_pinned_type_v = !(std::is_move_constructible_v<Type> && std::is_move_assignable_v<Type>);

    [[nodiscard]] auto &element_at(const std::size_t pos) const {
        return payload[pos / traits_type::page_size][fast_mod(pos, traits_type::page_size)];
    }

    auto assure_at_least(const std::size_t pos) {
        const auto idx = pos / traits_type::page_size;

        if(!(idx < payload.size())) {
            auto curr = payload.size();
            allocator_type allocator{get_allocator()};
            payload.resize(idx + 1u, nullptr);

            ENTT_TRY {
                for(const auto last = payload.size(); curr < last; ++curr) {
                    payload[curr] = alloc_traits::allocate(allocator, traits_type::page_size);
                }
            }
            ENTT_CATCH {
                payload.resize(curr);
                ENTT_THROW;
            }
        }

        return payload[idx] + fast_mod(pos, traits_type::page_size);
    }

    template<typename... Args>
    auto emplace_element(const Entity entt, const bool force_back, Args &&...args) {
        const auto it = base_type::try_emplace(entt, force_back);

        ENTT_TRY {
            auto elem = assure_at_least(static_cast<size_type>(it.index()));
            entt::uninitialized_construct_using_allocator(to_address(elem), get_allocator(), std::forward<Args>(args)...);
        }
        ENTT_CATCH {
            base_type::pop(it, it + 1u);
            ENTT_THROW;
        }

        return it;
    }

    void shrink_to_size(const std::size_t sz) {
        const auto from = (sz + traits_type::page_size - 1u) / traits_type::page_size;
        allocator_type allocator{get_allocator()};

        for(auto pos = sz, length = base_type::size(); pos < length; ++pos) {
            if constexpr(traits_type::in_place_delete) {
                if(base_type::at(pos) != tombstone) {
                    alloc_traits::destroy(allocator, std::addressof(element_at(pos)));
                }
            } else {
                alloc_traits::destroy(allocator, std::addressof(element_at(pos)));
            }
        }

        for(auto pos = from, last = payload.size(); pos < last; ++pos) {
            alloc_traits::deallocate(allocator, payload[pos], traits_type::page_size);
        }

        payload.resize(from);
    }

private:
    const void *get_at(const std::size_t pos) const final {
        return std::addressof(element_at(pos));
    }

    void swap_or_move([[maybe_unused]] const std::size_t from, [[maybe_unused]] const std::size_t to) override {
        // use a runtime value to avoid compile-time suppression that drives the code coverage tool crazy
        ENTT_ASSERT((from + 1u) && !is_pinned_type_v, "Pinned type");

        if constexpr(!is_pinned_type_v) {
            auto &elem = element_at(from);

            if constexpr(traits_type::in_place_delete) {
                if(base_type::operator[](to) == tombstone) {
                    allocator_type allocator{get_allocator()};
                    entt::uninitialized_construct_using_allocator(to_address(assure_at_least(to)), allocator, std::move(elem));
                    alloc_traits::destroy(allocator, std::addressof(elem));
                    return;
                }
            }

            using std::swap;
            swap(elem, element_at(to));
        }
    }

protected:
    /**
     * @brief Erases entities from a storage.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    void pop(underlying_iterator first, underlying_iterator last) override {
        for(allocator_type allocator{get_allocator()}; first != last; ++first) {
            // cannot use first.index() because it would break with cross iterators
            auto &elem = element_at(base_type::index(*first));

            if constexpr(traits_type::in_place_delete) {
                base_type::in_place_pop(first);
                alloc_traits::destroy(allocator, std::addressof(elem));
            } else {
                auto &other = element_at(base_type::size() - 1u);
                // destroying on exit allows reentrant destructors
                [[maybe_unused]] auto unused = std::exchange(elem, std::move(other));
                alloc_traits::destroy(allocator, std::addressof(other));
                base_type::swap_and_pop(first);
            }
        }
    }

    /*! @brief Erases all entities of a storage. */
    void pop_all() override {
        allocator_type allocator{get_allocator()};

        for(auto first = base_type::begin(); !(first.index() < 0); ++first) {
            if constexpr(traits_type::in_place_delete) {
                if(*first != tombstone) {
                    base_type::in_place_pop(first);
                    alloc_traits::destroy(allocator, std::addressof(element_at(static_cast<size_type>(first.index()))));
                }
            } else {
                base_type::swap_and_pop(first);
                alloc_traits::destroy(allocator, std::addressof(element_at(static_cast<size_type>(first.index()))));
            }
        }
    }

    /**
     * @brief Assigns an entity to a storage.
     * @param entt A valid identifier.
     * @param value Optional opaque value.
     * @param force_back Force back insertion.
     * @return Iterator pointing to the emplaced element.
     */
    underlying_iterator try_emplace([[maybe_unused]] const Entity entt, [[maybe_unused]] const bool force_back, const void *value) override {
        if(value) {
            if constexpr(std::is_copy_constructible_v<value_type>) {
                return emplace_element(entt, force_back, *static_cast<const value_type *>(value));
            } else {
                return base_type::end();
            }
        } else {
            if constexpr(std::is_default_constructible_v<value_type>) {
                return emplace_element(entt, force_back);
            } else {
                return base_type::end();
            }
        }
    }

public:
    /*! @brief Base type. */
    using base_type = underlying_type;
    /*! @brief Type of the objects assigned to entities. */
    using value_type = Type;
    /*! @brief Component traits. */
    using traits_type = component_traits<value_type>;
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Pointer type to contained elements. */
    using pointer = typename container_type::pointer;
    /*! @brief Constant pointer type to contained elements. */
    using const_pointer = typename alloc_traits::template rebind_traits<typename alloc_traits::const_pointer>::const_pointer;
    /*! @brief Random access iterator type. */
    using iterator = internal::storage_iterator<container_type, traits_type::page_size>;
    /*! @brief Constant random access iterator type. */
    using const_iterator = internal::storage_iterator<const container_type, traits_type::page_size>;
    /*! @brief Reverse iterator type. */
    using reverse_iterator = std::reverse_iterator<iterator>;
    /*! @brief Constant reverse iterator type. */
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    /*! @brief Extended iterable storage proxy. */
    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator, iterator>>;
    /*! @brief Constant extended iterable storage proxy. */
    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator, const_iterator>>;
    /*! @brief Extended reverse iterable storage proxy. */
    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator, reverse_iterator>>;
    /*! @brief Constant extended reverse iterable storage proxy. */
    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator, const_reverse_iterator>>;

    /*! @brief Default constructor. */
    basic_storage()
        : basic_storage{allocator_type{}} {}

    /**
     * @brief Constructs an empty storage with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit basic_storage(const allocator_type &allocator)
        : base_type{type_id<value_type>(), deletion_policy{traits_type::in_place_delete}, allocator},
          payload{allocator} {}

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    basic_storage(basic_storage &&other) noexcept
        : base_type{std::move(other)},
          payload{std::move(other.payload)} {}

    /**
     * @brief Allocator-extended move constructor.
     * @param other The instance to move from.
     * @param allocator The allocator to use.
     */
    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
        : base_type{std::move(other), allocator},
          payload{std::move(other.payload), allocator} {
        ENTT_ASSERT(alloc_traits::is_always_equal::value || payload.get_allocator() == other.payload.get_allocator(), "Copying a storage is not allowed");
    }

    /*! @brief Default destructor. */
    ~basic_storage() override {
        shrink_to_size(0u);
    }

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This storage.
     */
    basic_storage &operator=(basic_storage &&other) noexcept {
        ENTT_ASSERT(alloc_traits::is_always_equal::value || payload.get_allocator() == other.payload.get_allocator(), "Copying a storage is not allowed");

        shrink_to_size(0u);
        base_type::operator=(std::move(other));
        payload = std::move(other.payload);
        return *this;
    }

    /**
     * @brief Exchanges the contents with those of a given storage.
     * @param other Storage to exchange the content with.
     */
    void swap(basic_storage &other) {
        using std::swap;
        base_type::swap(other);
        swap(payload, other.payload);
    }

    /**
     * @brief Returns the associated allocator.
     * @return The associated allocator.
     */
    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return payload.get_allocator();
    }

    /**
     * @brief Increases the capacity of a storage.
     *
     * If the new capacity is greater than the current capacity, new storage is
     * allocated, otherwise the method does nothing.
     *
     * @param cap Desired capacity.
     */
    void reserve(const size_type cap) override {
        if(cap != 0u) {
            base_type::reserve(cap);
            assure_at_least(cap - 1u);
        }
    }

    /**
     * @brief Returns the number of elements that a storage has currently
     * allocated space for.
     * @return Capacity of the storage.
     */
    [[nodiscard]] size_type capacity() const noexcept override {
        return payload.size() * traits_type::page_size;
    }

    /*! @brief Requests the removal of unused capacity. */
    void shrink_to_fit() override {
        base_type::shrink_to_fit();
        shrink_to_size(base_type::size());
    }

    /**
     * @brief Direct access to the array of objects.
     * @return A pointer to the array of objects.
     */
    [[nodiscard]] const_pointer raw() const noexcept {
        return payload.data();
    }

    /*! @copydoc raw */
    [[nodiscard]] pointer raw() noexcept {
        return payload.data();
    }

    /**
     * @brief Returns an iterator to the beginning.
     *
     * If the storage is empty, the returned iterator will be equal to `end()`.
     *
     * @return An iterator to the first instance of the internal array.
     */
    [[nodiscard]] const_iterator cbegin() const noexcept {
        const auto pos = static_cast<typename iterator::difference_type>(base_type::size());
        return const_iterator{&payload, pos};
    }

    /*! @copydoc cbegin */
    [[nodiscard]] const_iterator begin() const noexcept {
        return cbegin();
    }

    /*! @copydoc begin */
    [[nodiscard]] iterator begin() noexcept {
        const auto pos = static_cast<typename iterator::difference_type>(base_type::size());
        return iterator{&payload, pos};
    }

    /**
     * @brief Returns an iterator to the end.
     * @return An iterator to the element following the last instance of the
     * internal array.
     */
    [[nodiscard]] const_iterator cend() const noexcept {
        return const_iterator{&payload, {}};
    }

    /*! @copydoc cend */
    [[nodiscard]] const_iterator end() const noexcept {
        return cend();
    }

    /*! @copydoc end */
    [[nodiscard]] iterator end() noexcept {
        return iterator{&payload, {}};
    }

    /**
     * @brief Returns a reverse iterator to the beginning.
     *
     * If the storage is empty, the returned iterator will be equal to `rend()`.
     *
     * @return An iterator to the first instance of the reversed internal array.
     */
    [[nodiscard]] const_reverse_iterator crbegin() const noexcept {
        return std::make_reverse_iterator(cend());
    }

    /*! @copydoc crbegin */
    [[nodiscard]] const_reverse_iterator rbegin() const noexcept {
        return crbegin();
    }

    /*! @copydoc rbegin */
    [[nodiscard]] reverse_iterator rbegin() noexcept {
        return std::make_reverse_iterator(end());
    }

    /**
     * @brief Returns a reverse iterator to the end.
     * @return An iterator to the element following the last instance of the
     * reversed internal array.
     */
    [[nodiscard]] const_reverse_iterator crend() const noexcept {
        return std::make_reverse_iterator(cbegin());
    }

    /*! @copydoc crend */
    [[nodiscard]] const_reverse_iterator rend() const noexcept {
        return crend();
    }

    /*! @copydoc rend */
    [[nodiscard]] reverse_iterator rend() noexcept {
        return std::make_reverse_iterator(begin());
    }

    /**
     * @brief Returns the object assigned to an entity.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the storage results in
     * undefined behavior.
     *
     * @param entt A valid identifier.
     * @return The object assigned to the entity.
     */
    [[nodiscard]] const value_type &get(const entity_type entt) const noexcept {
        return element_at(base_type::index(entt));
    }

    /*! @copydoc get */
    [[nodiscard]] value_type &get(const entity_type entt) noexcept {
        return const_cast<value_type &>(std::as_const(*this).get(entt));
    }

    /**
     * @brief Returns the object assigned to an entity as a tuple.
     * @param entt A valid identifier.
     * @return The object assigned to the entity as a tuple.
     */
    [[nodiscard]] std::tuple<const value_type &> get_as_tuple(const entity_type entt) const noexcept {
        return std::forward_as_tuple(get(entt));
    }

    /*! @copydoc get_as_tuple */
    [[nodiscard]] std::tuple<value_type &> get_as_tuple(const entity_type entt) noexcept {
        return std::forward_as_tuple(get(entt));
    }

    /**
     * @brief Assigns an entity to a storage and constructs its object.
     *
     * @warning
     * Attempting to use an entity that already belongs to the storage results
     * in undefined behavior.
     *
     * @tparam Args Types of arguments to use to construct the object.
     * @param entt A valid identifier.
     * @param args Parameters to use to construct an object for the entity.
     * @return A reference to the newly created object.
     */
    template<typename... Args>
    value_type &emplace(const entity_type entt, Args &&...args) {
        if constexpr(std::is_aggregate_v<value_type> && (sizeof...(Args) != 0u || !std::is_default_constructible_v<value_type>)) {
            const auto it = emplace_element(entt, false, Type{std::forward<Args>(args)...});
            return element_at(static_cast<size_type>(it.index()));
        } else {
            const auto it = emplace_element(entt, false, std::forward<Args>(args)...);
            return element_at(static_cast<size_type>(it.index()));
        }
    }

    /**
     * @brief Updates the instance assigned to a given entity in-place.
     * @tparam Func Types of the function objects to invoke.
     * @param entt A valid identifier.
     * @param func Valid function objects.
     * @return A reference to the updated instance.
     */
    template<typename... Func>
    value_type &patch(const entity_type entt, Func &&...func) {
        const auto idx = base_type::index(entt);
        auto &elem = element_at(idx);
        (std::forward<Func>(func)(elem), ...);
        return elem;
    }

    /**
     * @brief Assigns one or more entities to a storage and constructs their
     * objects from a given instance.
     *
     * @warning
     * Attempting to assign an entity that already belongs to the storage
     * results in undefined behavior.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param value An instance of the object to construct.
     * @return Iterator pointing to the last element inserted, if any.
     */
    template<typename It>
    iterator insert(It first, It last, const value_type &value = {}) {
        for(; first != last; ++first) {
            emplace_element(*first, true, value);
        }

        return begin();
    }

    /**
     * @brief Assigns one or more entities to a storage and constructs their
     * objects from a given range.
     *
     * @sa construct
     *
     * @tparam EIt Type of input iterator.
     * @tparam CIt Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param from An iterator to the first element of the range of objects.
     * @return Iterator pointing to the first element inserted, if any.
     */
    template<typename EIt, typename CIt, typename = std::enable_if_t<std::is_same_v<typename std::iterator_traits<CIt>::value_type, value_type>>>
    iterator insert(EIt first, EIt last, CIt from) {
        for(; first != last; ++first, ++from) {
            emplace_element(*first, true, *from);
        }

        return begin();
    }

    /**
     * @brief Returns an iterable object to use to _visit_ a storage.
     *
     * The iterable object returns a tuple that contains the current entity and
     * a reference to its component.
     *
     * @return An iterable object to use to _visit_ the storage.
     */
    [[nodiscard]] iterable each() noexcept {
        return {internal::extended_storage_iterator{base_type::begin(), begin()}, internal::extended_storage_iterator{base_type::end(), end()}};
    }

    /*! @copydoc each */
    [[nodiscard]] const_iterable each() const noexcept {
        return {internal::extended_storage_iterator{base_type::cbegin(), cbegin()}, internal::extended_storage_iterator{base_type::cend(), cend()}};
    }

    /**
     * @brief Returns a reverse iterable object to use to _visit_ a storage.
     *
     * @sa each
     *
     * @return A reverse iterable object to use to _visit_ the storage.
     */
    [[nodiscard]] reverse_iterable reach() noexcept {
        return {internal::extended_storage_iterator{base_type::rbegin(), rbegin()}, internal::extended_storage_iterator{base_type::rend(), rend()}};
    }

    /*! @copydoc reach */
    [[nodiscard]] const_reverse_iterable reach() const noexcept {
        return {internal::extended_storage_iterator{base_type::crbegin(), crbegin()}, internal::extended_storage_iterator{base_type::crend(), crend()}};
    }

private:
    container_type payload;
};

/*! @copydoc basic_storage */
template<typename Type, typename Entity, typename Allocator>
class basic_storage<Type, Entity, Allocator, std::enable_if_t<component_traits<Type>::page_size == 0u>>
    : public basic_sparse_set<Entity, typename std::allocator_traits<Allocator>::template rebind_alloc<Entity>> {
    using alloc_traits = std::allocator_traits<Allocator>;
    static_assert(std::is_same_v<typename alloc_traits::value_type, Type>, "Invalid value type");

public:
    /*! @brief Base type. */
    using base_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
    /*! @brief Type of the objects assigned to entities. */
    using value_type = Type;
    /*! @brief Component traits. */
    using traits_type = component_traits<value_type>;
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Extended iterable storage proxy. */
    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator>>;
    /*! @brief Constant extended iterable storage proxy. */
    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator>>;
    /*! @brief Extended reverse iterable storage proxy. */
    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator>>;
    /*! @brief Constant extended reverse iterable storage proxy. */
    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator>>;

    /*! @brief Default constructor. */
    basic_storage()
        : basic_storage{allocator_type{}} {}

    /**
     * @brief Constructs an empty container with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit basic_storage(const allocator_type &allocator)
        : base_type{type_id<value_type>(), deletion_policy{traits_type::in_place_delete}, allocator} {}

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    basic_storage(basic_storage &&other) noexcept = default;

    /**
     * @brief Allocator-extended move constructor.
     * @param other The instance to move from.
     * @param allocator The allocator to use.
     */
    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
        : base_type{std::move(other), allocator} {}

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This storage.
     */
    basic_storage &operator=(basic_storage &&other) noexcept = default;

    /**
     * @brief Returns the associated allocator.
     * @return The associated allocator.
     */
    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return allocator_type{base_type::get_allocator()};
    }

    /**
     * @brief Returns the object assigned to an entity, that is `void`.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the storage results in
     * undefined behavior.
     *
     * @param entt A valid identifier.
     */
    void get([[maybe_unused]] const entity_type entt) const noexcept {
        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
    }

    /**
     * @brief Returns an empty tuple.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the storage results in
     * undefined behavior.
     *
     * @param entt A valid identifier.
     * @return Returns an empty tuple.
     */
    [[nodiscard]] std::tuple<> get_as_tuple([[maybe_unused]] const entity_type entt) const noexcept {
        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
        return std::tuple{};
    }

    /**
     * @brief Assigns an entity to a storage and constructs its object.
     *
     * @warning
     * Attempting to use an entity that already belongs to the storage results
     * in undefined behavior.
     *
     * @tparam Args Types of arguments to use to construct the object.
     * @param entt A valid identifier.
     */
    template<typename... Args>
    void emplace(const entity_type entt, Args &&...) {
        base_type::try_emplace(entt, false);
    }

    /**
     * @brief Updates the instance assigned to a given entity in-place.
     * @tparam Func Types of the function objects to invoke.
     * @param entt A valid identifier.
     * @param func Valid function objects.
     */
    template<typename... Func>
    void patch([[maybe_unused]] const entity_type entt, Func &&...func) {
        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
        (std::forward<Func>(func)(), ...);
    }

    /**
     * @brief Assigns entities to a storage.
     * @tparam It Type of input iterator.
     * @tparam Args Types of optional arguments.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename It, typename... Args>
    void insert(It first, It last, Args &&...) {
        for(; first != last; ++first) {
            base_type::try_emplace(*first, true);
        }
    }

    /**
     * @brief Returns an iterable object to use to _visit_ a storage.
     *
     * The iterable object returns a tuple that contains the current entity.
     *
     * @return An iterable object to use to _visit_ the storage.
     */
    [[nodiscard]] iterable each() noexcept {
        return {internal::extended_storage_iterator{base_type::begin()}, internal::extended_storage_iterator{base_type::end()}};
    }

    /*! @copydoc each */
    [[nodiscard]] const_iterable each() const noexcept {
        return {internal::extended_storage_iterator{base_type::cbegin()}, internal::extended_storage_iterator{base_type::cend()}};
    }

    /**
     * @brief Returns a reverse iterable object to use to _visit_ a storage.
     *
     * @sa each
     *
     * @return A reverse iterable object to use to _visit_ the storage.
     */
    [[nodiscard]] reverse_iterable reach() noexcept {
        return {internal::extended_storage_iterator{base_type::rbegin()}, internal::extended_storage_iterator{base_type::rend()}};
    }

    /*! @copydoc reach */
    [[nodiscard]] const_reverse_iterable reach() const noexcept {
        return {internal::extended_storage_iterator{base_type::crbegin()}, internal::extended_storage_iterator{base_type::crend()}};
    }
};

/**
 * @brief Swap-only entity storage specialization.
 * @tparam Entity A valid entity type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Entity, typename Allocator>
class basic_storage<Entity, Entity, Allocator>
    : public basic_sparse_set<Entity, Allocator> {
    using alloc_traits = std::allocator_traits<Allocator>;
    static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");
    using underlying_type = basic_sparse_set<Entity, typename alloc_traits::template rebind_alloc<Entity>>;
    using underlying_iterator = typename underlying_type::basic_iterator;
    using local_traits_type = entt_traits<Entity>;

    auto entity_at(const std::size_t pos) const noexcept {
        ENTT_ASSERT(pos < local_traits_type::to_entity(null), "Invalid element");
        return local_traits_type::combine(static_cast<typename local_traits_type::entity_type>(pos), {});
    }

private:
    void swap_or_move([[maybe_unused]] const std::size_t lhs, [[maybe_unused]] const std::size_t rhs) override {
        ENTT_ASSERT(((lhs < length) + (rhs < length)) != 1u, "Cross swapping is not supported");
    }

protected:
    /**
     * @brief Erases entities from a storage.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    void pop(underlying_iterator first, underlying_iterator last) override {
        for(; first != last; ++first) {
            if(const auto pos = base_type::index(*first); pos < length) {
                base_type::bump(local_traits_type::next(*first));

                if(pos != --length) {
                    base_type::swap_at(pos, length);
                }
            }
        }
    }

    /*! @brief Erases all entities of a sparse set. */
    void pop_all() override {
        length = 0u;
        base_type::pop_all();
    }

    /**
     * @brief Assigns an entity to a storage.
     * @param hint A valid identifier.
     * @return Iterator pointing to the emplaced element.
     */
    underlying_iterator try_emplace(const Entity hint, const bool, const void *) override {
        return base_type::find(emplace(hint));
    }

public:
    /*! @brief Base type. */
    using base_type = basic_sparse_set<Entity, Allocator>;
    /*! @brief Type of the objects assigned to entities. */
    using value_type = Entity;
    /*! @brief Component traits. */
    using traits_type = component_traits<value_type>;
    /*! @brief Underlying entity identifier. */
    using entity_type = Entity;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Extended iterable storage proxy. */
    using iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::iterator>>;
    /*! @brief Constant extended iterable storage proxy. */
    using const_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_iterator>>;
    /*! @brief Extended reverse iterable storage proxy. */
    using reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::reverse_iterator>>;
    /*! @brief Constant extended reverse iterable storage proxy. */
    using const_reverse_iterable = iterable_adaptor<internal::extended_storage_iterator<typename base_type::const_reverse_iterator>>;

    /*! @brief Default constructor. */
    basic_storage()
        : basic_storage{allocator_type{}} {
    }

    /**
     * @brief Constructs an empty container with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit basic_storage(const allocator_type &allocator)
        : base_type{type_id<value_type>(), deletion_policy::swap_and_pop, allocator},
          length{} {}

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    basic_storage(basic_storage &&other) noexcept
        : base_type{std::move(other)},
          length{std::exchange(other.length, size_type{})} {}

    /**
     * @brief Allocator-extended move constructor.
     * @param other The instance to move from.
     * @param allocator The allocator to use.
     */
    basic_storage(basic_storage &&other, const allocator_type &allocator) noexcept
        : base_type{std::move(other), allocator},
          length{std::exchange(other.length, size_type{})} {}

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This storage.
     */
    basic_storage &operator=(basic_storage &&other) noexcept {
        base_type::operator=(std::move(other));
        length = std::exchange(other.length, size_type{});
        return *this;
    }

    /**
     * @brief Returns the object assigned to an entity, that is `void`.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the storage results in
     * undefined behavior.
     *
     * @param entt A valid identifier.
     */
    void get([[maybe_unused]] const entity_type entt) const noexcept {
        ENTT_ASSERT(base_type::index(entt) < length, "The requested entity is not a live one");
    }

    /**
     * @brief Returns an empty tuple.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the storage results in
     * undefined behavior.
     *
     * @param entt A valid identifier.
     * @return Returns an empty tuple.
     */
    [[nodiscard]] std::tuple<> get_as_tuple([[maybe_unused]] const entity_type entt) const noexcept {
        ENTT_ASSERT(base_type::index(entt) < length, "The requested entity is not a live one");
        return std::tuple{};
    }

    /**
     * @brief Exchanges the contents with those of a given storage.
     * @param other Storage to exchange the content with.
     */
    void swap(basic_storage &other) {
        using std::swap;
        base_type::swap(other);
        swap(length, other.length);
    }

    /**
     * @brief Creates a new identifier or recycles a destroyed one.
     * @return A valid identifier.
     */
    entity_type emplace() {
        if(length == base_type::size()) {
            return *base_type::try_emplace(entity_at(length++), true);
        }

        return base_type::operator[](length++);
    }

    /**
     * @brief Creates a new identifier or recycles a destroyed one.
     *
     * If the requested identifier isn't in use, the suggested one is used.
     * Otherwise, a new identifier is returned.
     *
     * @param hint Required identifier.
     * @return A valid identifier.
     */
    entity_type emplace(const entity_type hint) {
        if(hint == null || hint == tombstone) {
            return emplace();
        } else if(const auto curr = local_traits_type::construct(local_traits_type::to_entity(hint), base_type::current(hint)); curr == tombstone) {
            const auto pos = static_cast<size_type>(local_traits_type::to_entity(hint));

            while(!(pos < base_type::size())) {
                base_type::try_emplace(entity_at(base_type::size()), true);
            }

            base_type::swap_at(pos, length++);
        } else if(const auto idx = base_type::index(curr); idx < length) {
            return emplace();
        } else {
            base_type::swap_at(idx, length++);
        }

        base_type::bump(hint);

        return hint;
    }

    /**
     * @brief Updates a given identifier.
     * @tparam Func Types of the function objects to invoke.
     * @param entt A valid identifier.
     * @param func Valid function objects.
     */
    template<typename... Func>
    void patch([[maybe_unused]] const entity_type entt, Func &&...func) {
        ENTT_ASSERT(base_type::contains(entt), "Storage does not contain entity");
        (std::forward<Func>(func)(), ...);
    }

    /**
     * @brief Assigns each element in a range an identifier.
     * @tparam It Type of mutable forward iterator.
     * @param first An iterator to the first element of the range to generate.
     * @param last An iterator past the last element of the range to generate.
     */
    template<typename It>
    void insert(It first, It last) {
        for(const auto sz = base_type::size(); first != last && length != sz; ++first, ++length) {
            *first = base_type::operator[](length);
        }

        for(; first != last; ++first) {
            *first = *base_type::try_emplace(entity_at(length++), true);
        }
    }

    /**
     * @brief Makes all elements in a range contiguous.
     * @tparam It Type of forward iterator.
     * @param first An iterator to the first element of the range to pack.
     * @param last An iterator past the last element of the range to pack.
     * @return The number of elements within the newly created range.
     */
    template<typename It>
    size_type pack(It first, It last) {
        size_type len = length;

        for(; first != last; ++first, --len) {
            const auto pos = base_type::index(*first);
            ENTT_ASSERT(pos < length, "Invalid element");
            base_type::swap_at(pos, static_cast<size_type>(len - 1u));
        }

        return (length - len);
    }

    /**
     * @brief Returns the number of elements considered still in use.
     * @return The number of elements considered still in use.
     */
    [[nodiscard]] size_type in_use() const noexcept {
        return length;
    }

    /**
     * @brief Sets the number of elements considered still in use.
     * @param len The number of elements considered still in use.
     */
    void in_use(const size_type len) noexcept {
        ENTT_ASSERT(!(len > base_type::size()), "Invalid length");
        length = len;
    }

    /**
     * @brief Returns an iterable object to use to _visit_ a storage.
     *
     * The iterable object returns a tuple that contains the current entity.
     *
     * @return An iterable object to use to _visit_ the storage.
     */
    [[nodiscard]] iterable each() noexcept {
        return {internal::extended_storage_iterator{base_type::end() - length}, internal::extended_storage_iterator{base_type::end()}};
    }

    /*! @copydoc each */
    [[nodiscard]] const_iterable each() const noexcept {
        return {internal::extended_storage_iterator{base_type::cend() - length}, internal::extended_storage_iterator{base_type::cend()}};
    }

    /**
     * @brief Returns a reverse iterable object to use to _visit_ a storage.
     *
     * @sa each
     *
     * @return A reverse iterable object to use to _visit_ the storage.
     */
    [[nodiscard]] reverse_iterable reach() noexcept {
        return {internal::extended_storage_iterator{base_type::rbegin()}, internal::extended_storage_iterator{base_type::rbegin() + length}};
    }

    /*! @copydoc reach */
    [[nodiscard]] const_reverse_iterable reach() const noexcept {
        return {internal::extended_storage_iterator{base_type::crbegin()}, internal::extended_storage_iterator{base_type::crbegin() + length}};
    }

private:
    size_type length;
};

} // namespace entt

#endif

/////////////////// END OF external/entt/entity/storage.hpp ////////////////////

/////////////////// START OF external/entt/entity/group.hpp ////////////////////

#ifndef ENTT_ENTITY_GROUP_HPP
#define ENTT_ENTITY_GROUP_HPP

#include <tuple>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename, typename, typename>
class extended_group_iterator;

template<typename It, typename... Owned, typename... Get>
class extended_group_iterator<It, owned_t<Owned...>, get_t<Get...>> {
    template<typename Type>
    auto index_to_element([[maybe_unused]] Type &cpool) const {
        if constexpr(Type::traits_type::page_size == 0u) {
            return std::make_tuple();
        } else {
            return std::forward_as_tuple(cpool.rbegin()[it.index()]);
        }
    }

public:
    using iterator_type = It;
    using difference_type = std::ptrdiff_t;
    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Owned>().get_as_tuple({})..., std::declval<Get>().get_as_tuple({})...));
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using iterator_category = std::input_iterator_tag;

    constexpr extended_group_iterator()
        : it{},
          pools{} {}

    extended_group_iterator(It from, const std::tuple<Owned *..., Get *...> &cpools)
        : it{from},
          pools{cpools} {}

    extended_group_iterator &operator++() noexcept {
        return ++it, *this;
    }

    extended_group_iterator operator++(int) noexcept {
        extended_group_iterator orig = *this;
        return ++(*this), orig;
    }

    [[nodiscard]] reference operator*() const noexcept {
        return std::tuple_cat(std::make_tuple(*it), index_to_element(*std::get<Owned *>(pools))..., std::get<Get *>(pools)->get_as_tuple(*it)...);
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return operator*();
    }

    [[nodiscard]] constexpr iterator_type base() const noexcept {
        return it;
    }

    template<typename... Lhs, typename... Rhs>
    friend constexpr bool operator==(const extended_group_iterator<Lhs...> &, const extended_group_iterator<Rhs...> &) noexcept;

private:
    It it;
    std::tuple<Owned *..., Get *...> pools;
};

template<typename... Lhs, typename... Rhs>
[[nodiscard]] constexpr bool operator==(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
    return lhs.it == rhs.it;
}

template<typename... Lhs, typename... Rhs>
[[nodiscard]] constexpr bool operator!=(const extended_group_iterator<Lhs...> &lhs, const extended_group_iterator<Rhs...> &rhs) noexcept {
    return !(lhs == rhs);
}

struct group_descriptor {
    using size_type = std::size_t;
    virtual ~group_descriptor() = default;
    virtual size_type owned(const id_type *, const size_type) const noexcept {
        return 0u;
    }
};

template<typename, typename, typename>
class group_handler;

template<typename... Owned, typename... Get, typename... Exclude>
class group_handler<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> final: public group_descriptor {
    // nasty workaround for an issue with the toolset v141 that doesn't accept a fold expression here
    static_assert(!std::disjunction_v<std::bool_constant<Owned::traits_type::in_place_delete>...>, "Groups do not support in-place delete");
    static_assert(!std::disjunction_v<std::is_const<Owned>..., std::is_const<Get>..., std::is_const<Exclude>...>, "Const storage type not allowed");

    using base_type = std::common_type_t<typename Owned::base_type..., typename Get::base_type..., typename Exclude::base_type...>;
    using entity_type = typename base_type::entity_type;

    void swap_elements(const std::size_t pos, const entity_type entt) {
        std::apply([pos, entt](auto *...cpool) { (cpool->swap_elements(cpool->data()[pos], entt), ...); }, pools);
    }

    void push_on_construct(const entity_type entt) {
        if(std::apply([entt, len = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < len) && (other->contains(entt) && ...); }, pools)
           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
            swap_elements(len++, entt);
        }
    }

    void push_on_destroy(const entity_type entt) {
        if(std::apply([entt, len = len](auto *cpool, auto *...other) { return cpool->contains(entt) && !(cpool->index(entt) < len) && (other->contains(entt) && ...); }, pools)
           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
            swap_elements(len++, entt);
        }
    }

    void remove_if(const entity_type entt) {
        if(std::get<0>(pools)->contains(entt) && (std::get<0>(pools)->index(entt) < len)) {
            swap_elements(--len, entt);
        }
    }

public:
    using size_type = typename base_type::size_type;

    group_handler(Owned &...opool, Get &...gpool, Exclude &...epool)
        : pools{&opool..., &gpool...},
          filter{&epool...},
          len{} {
        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::push_on_construct>(*this), cpool->on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, pools);
        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::remove_if>(*this), cpool->on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, filter);

        // we cannot iterate backwards because we want to leave behind valid entities in case of owned types
        for(auto *first = std::get<0>(pools)->data(), *last = first + std::get<0>(pools)->size(); first != last; ++first) {
            push_on_construct(*first);
        }
    }

    size_type owned(const id_type *elem, const size_type length) const noexcept final {
        size_type cnt = 0u;

        for(auto pos = 0u; pos < length; ++pos) {
            cnt += ((elem[pos] == entt::type_hash<typename Owned::value_type>::value()) || ...);
        }

        return cnt;
    }

    [[nodiscard]] size_type length() const noexcept {
        return len;
    }

    template<typename Type>
    Type pools_as() const noexcept {
        return pools;
    }

    template<typename Type>
    Type filter_as() const noexcept {
        return filter;
    }

private:
    std::tuple<Owned *..., Get *...> pools;
    std::tuple<Exclude *...> filter;
    std::size_t len;
};

template<typename... Get, typename... Exclude>
class group_handler<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> final: public group_descriptor {
    // nasty workaround for an issue with the toolset v141 that doesn't accept a fold expression here
    static_assert(!std::disjunction_v<std::is_const<Get>..., std::is_const<Exclude>...>, "Const storage type not allowed");

    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
    using entity_type = typename base_type::entity_type;

    void push_on_construct(const entity_type entt) {
        if(!elem.contains(entt)
           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
           && std::apply([entt](auto *...cpool) { return (!cpool->contains(entt) && ...); }, filter)) {
            elem.push(entt);
        }
    }

    void push_on_destroy(const entity_type entt) {
        if(!elem.contains(entt)
           && std::apply([entt](auto *...cpool) { return (cpool->contains(entt) && ...); }, pools)
           && std::apply([entt](auto *...cpool) { return (0u + ... + cpool->contains(entt)) == 1u; }, filter)) {
            elem.push(entt);
        }
    }

    void remove_if(const entity_type entt) {
        elem.remove(entt);
    }

public:
    using common_type = base_type;

    template<typename Alloc>
    group_handler(const Alloc &alloc, Get &...gpool, Exclude &...epool)
        : pools{&gpool...},
          filter{&epool...},
          elem{alloc} {
        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::push_on_construct>(*this), cpool->on_destroy().template connect<&group_handler::remove_if>(*this)), ...); }, pools);
        std::apply([this](auto *...cpool) { ((cpool->on_construct().template connect<&group_handler::remove_if>(*this), cpool->on_destroy().template connect<&group_handler::push_on_destroy>(*this)), ...); }, filter);

        for(const auto entity: static_cast<base_type &>(*std::get<0>(pools))) {
            push_on_construct(entity);
        }
    }

    common_type &handle() noexcept {
        return elem;
    }

    const common_type &handle() const noexcept {
        return elem;
    }

    template<typename Type>
    Type pools_as() const noexcept {
        return pools;
    }

    template<typename Type>
    Type filter_as() const noexcept {
        return filter;
    }

private:
    std::tuple<Get *...> pools;
    std::tuple<Exclude *...> filter;
    base_type elem;
};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Group.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error, but for a few reasonable cases.
 */
template<typename, typename, typename>
class basic_group;

/**
 * @brief Non-owning group.
 *
 * A non-owning group returns all entities and only the entities that are at
 * least in the given storage. Moreover, it's guaranteed that the entity list is
 * tightly packed in memory for fast iterations.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New elements are added to the storage.
 * * The entity currently pointed is modified (for example, components are added
 *   or removed from it).
 * * The entity currently pointed is destroyed.
 *
 * In all other cases, modifying the pools iterated by the group in any way
 * invalidates all the iterators.
 *
 * @tparam Get Types of storage _observed_ by the group.
 * @tparam Exclude Types of storage used to filter the group.
 */
template<typename... Get, typename... Exclude>
class basic_group<owned_t<>, get_t<Get...>, exclude_t<Exclude...>> {
    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
    using underlying_type = typename base_type::entity_type;

    template<typename Type>
    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::value_type..., typename Exclude::value_type...>>;

    auto pools() const noexcept {
        using return_type = std::tuple<Get *...>;
        return descriptor ? descriptor->template pools_as<return_type>() : return_type{};
    }

    auto filter() const noexcept {
        using return_type = std::tuple<Exclude *...>;
        return descriptor ? descriptor->template filter_as<return_type>() : return_type{};
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = underlying_type;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Common type among all storage types. */
    using common_type = base_type;
    /*! @brief Random access iterator type. */
    using iterator = typename common_type::iterator;
    /*! @brief Reversed iterator type. */
    using reverse_iterator = typename common_type::reverse_iterator;
    /*! @brief Iterable group type. */
    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<>, get_t<Get...>>>;
    /*! @brief Group handler type. */
    using handler = internal::group_handler<owned_t<>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>;

    /*! @brief Default constructor to use to create empty, invalid groups. */
    basic_group() noexcept
        : descriptor{} {}

    /**
     * @brief Constructs a group from a set of storage classes.
     * @param ref A reference to a group handler.
     */
    basic_group(handler &ref) noexcept
        : descriptor{&ref} {}

    /**
     * @brief Returns the leading storage of a group.
     * @return The leading storage of the group.
     */
    [[nodiscard]] const common_type &handle() const noexcept {
        return descriptor->handle();
    }

    /**
     * @brief Returns the storage for a given component type, if any.
     * @tparam Type Type of component of which to return the storage.
     * @return The storage for the given component type.
     */
    template<typename Type>
    [[nodiscard]] auto *storage() const noexcept {
        return storage<index_of<Type>>();
    }

    /**
     * @brief Returns the storage for a given index, if any.
     * @tparam Index Index of the storage to return.
     * @return The storage for the given index.
     */
    template<std::size_t Index>
    [[nodiscard]] auto *storage() const noexcept {
        constexpr auto offset = sizeof...(Get);

        if constexpr(Index < offset) {
            return std::get<Index>(pools());
        } else {
            return std::get<Index - offset>(filter());
        }
    }

    /**
     * @brief Returns the number of entities that are part of the group.
     * @return Number of entities that are part of the group.
     */
    [[nodiscard]] size_type size() const noexcept {
        return *this ? handle().size() : size_type{};
    }

    /**
     * @brief Returns the number of elements that a group has currently
     * allocated space for.
     * @return Capacity of the group.
     */
    [[nodiscard]] size_type capacity() const noexcept {
        return *this ? handle().capacity() : size_type{};
    }

    /*! @brief Requests the removal of unused capacity. */
    void shrink_to_fit() {
        if(*this) {
            descriptor->handle().shrink_to_fit();
        }
    }

    /**
     * @brief Checks whether a group is empty.
     * @return True if the group is empty, false otherwise.
     */
    [[nodiscard]] bool empty() const noexcept {
        return !*this || handle().empty();
    }

    /**
     * @brief Returns an iterator to the first entity of the group.
     *
     * If the group is empty, the returned iterator will be equal to `end()`.
     *
     * @return An iterator to the first entity of the group.
     */
    [[nodiscard]] iterator begin() const noexcept {
        return *this ? handle().begin() : iterator{};
    }

    /**
     * @brief Returns an iterator that is past the last entity of the group.
     * @return An iterator to the entity following the last entity of the
     * group.
     */
    [[nodiscard]] iterator end() const noexcept {
        return *this ? handle().end() : iterator{};
    }

    /**
     * @brief Returns an iterator to the first entity of the reversed group.
     *
     * If the group is empty, the returned iterator will be equal to `rend()`.
     *
     * @return An iterator to the first entity of the reversed group.
     */
    [[nodiscard]] reverse_iterator rbegin() const noexcept {
        return *this ? handle().rbegin() : reverse_iterator{};
    }

    /**
     * @brief Returns an iterator that is past the last entity of the reversed
     * group.
     * @return An iterator to the entity following the last entity of the
     * reversed group.
     */
    [[nodiscard]] reverse_iterator rend() const noexcept {
        return *this ? handle().rend() : reverse_iterator{};
    }

    /**
     * @brief Returns the first entity of the group, if any.
     * @return The first entity of the group if one exists, the null entity
     * otherwise.
     */
    [[nodiscard]] entity_type front() const noexcept {
        const auto it = begin();
        return it != end() ? *it : null;
    }

    /**
     * @brief Returns the last entity of the group, if any.
     * @return The last entity of the group if one exists, the null entity
     * otherwise.
     */
    [[nodiscard]] entity_type back() const noexcept {
        const auto it = rbegin();
        return it != rend() ? *it : null;
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
        return *this ? handle().find(entt) : iterator{};
    }

    /**
     * @brief Returns the identifier that occupies the given position.
     * @param pos Position of the element to return.
     * @return The identifier that occupies the given position.
     */
    [[nodiscard]] entity_type operator[](const size_type pos) const {
        return begin()[pos];
    }

    /**
     * @brief Checks if a group is properly initialized.
     * @return True if the group is properly initialized, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return descriptor != nullptr;
    }

    /**
     * @brief Checks if a group contains an entity.
     * @param entt A valid identifier.
     * @return True if the group contains the given entity, false otherwise.
     */
    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
        return *this && handle().contains(entt);
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the group results in
     * undefined behavior.
     *
     * @tparam Type Type of the component to get.
     * @tparam Other Other types of components to get.
     * @param entt A valid identifier.
     * @return The components assigned to the entity.
     */
    template<typename Type, typename... Other>
    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
        return get<index_of<Type>, index_of<Other>...>(entt);
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the groups results in
     * undefined behavior.
     *
     * @tparam Index Indexes of the components to get.
     * @param entt A valid identifier.
     * @return The components assigned to the entity.
     */
    template<std::size_t... Index>
    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
        const auto cpools = pools();

        if constexpr(sizeof...(Index) == 0) {
            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
        } else if constexpr(sizeof...(Index) == 1) {
            return (std::get<Index>(cpools)->get(entt), ...);
        } else {
            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
        }
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        for(const auto entt: *this) {
            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
                std::apply(func, std::tuple_cat(std::make_tuple(entt), get(entt)));
            } else {
                std::apply(func, get(entt));
            }
        }
    }

    /**
     * @brief Returns an iterable object to use to _visit_ a group.
     *
     * The iterable object returns tuples that contain the current entity and a
     * set of references to its non-empty components. The _constness_ of the
     * components is as requested.
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @return An iterable object to use to _visit_ the group.
     */
    [[nodiscard]] iterable each() const noexcept {
        const auto cpools = pools();
        return iterable{{begin(), cpools}, {end(), cpools}};
    }

    /**
     * @brief Sort a group according to the given comparison function.
     *
     * The comparison function object must return `true` if the first element
     * is _less_ than the second one, `false` otherwise. The signature of the
     * comparison function should be equivalent to one of the following:
     *
     * @code{.cpp}
     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
     * bool(const Type &..., const Type &...);
     * bool(const Entity, const Entity);
     * @endcode
     *
     * Where `Type` are such that they are iterated by the group.<br/>
     * Moreover, the comparison function object shall induce a
     * _strict weak ordering_ on the values.
     *
     * The sort function object must offer a member function template
     * `operator()` that accepts three arguments:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function to use to compare the elements.
     *
     * @tparam Type Optional type of component to compare.
     * @tparam Other Other optional types of components to compare.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
    }

    /**
     * @brief Sort a group according to the given comparison function.
     *
     * @sa sort
     *
     * @tparam Index Optional indexes of components to compare.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
        if(*this) {
            if constexpr(sizeof...(Index) == 0) {
                static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
                descriptor->handle().sort(std::move(compare), std::move(algo), std::forward<Args>(args)...);
            } else {
                auto comp = [&compare, cpools = pools()](const entity_type lhs, const entity_type rhs) {
                    if constexpr(sizeof...(Index) == 1) {
                        return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
                    } else {
                        return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
                    }
                };

                descriptor->handle().sort(std::move(comp), std::move(algo), std::forward<Args>(args)...);
            }
        }
    }

    /**
     * @brief Sort the shared pool of entities according to a given storage.
     *
     * The shared pool of entities and thus its order is affected by the changes
     * to each and every pool that it tracks.
     *
     * @param other The storage to use to impose the order.
     */
    void sort_as(const common_type &other) const {
        if(*this) {
            descriptor->handle().sort_as(other);
        }
    }

private:
    handler *descriptor;
};

/**
 * @brief Owning group.
 *
 * Owning groups returns all entities and only the entities that are at
 * least in the given storage. Moreover:
 *
 * * It's guaranteed that the entity list is tightly packed in memory for fast
 *   iterations.
 * * It's guaranteed that all components in the owned storage are tightly packed
 *   in memory for even faster iterations and to allow direct access.
 * * They stay true to the order of the owned storage and all instances have the
 *   same order in memory.
 *
 * The more types of storage are owned, the faster it is to iterate a group.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New elements are added to the storage.
 * * The entity currently pointed is modified (for example, components are added
 *   or removed from it).
 * * The entity currently pointed is destroyed.
 *
 * In all other cases, modifying the pools iterated by the group in any way
 * invalidates all the iterators.
 *
 * @tparam Owned Types of storage _owned_ by the group.
 * @tparam Get Types of storage _observed_ by the group.
 * @tparam Exclude Types of storage used to filter the group.
 */
template<typename... Owned, typename... Get, typename... Exclude>
class basic_group<owned_t<Owned...>, get_t<Get...>, exclude_t<Exclude...>> {
    using base_type = std::common_type_t<typename Owned::base_type..., typename Get::base_type..., typename Exclude::base_type...>;
    using underlying_type = typename base_type::entity_type;

    template<typename Type>
    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Owned::value_type..., typename Get::value_type..., typename Exclude::value_type...>>;

    auto pools() const noexcept {
        using return_type = std::tuple<Owned *..., Get *...>;
        return descriptor ? descriptor->template pools_as<return_type>() : return_type{};
    }

    auto filter() const noexcept {
        using return_type = std::tuple<Exclude *...>;
        return descriptor ? descriptor->template filter_as<return_type>() : return_type{};
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = underlying_type;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Common type among all storage types. */
    using common_type = base_type;
    /*! @brief Random access iterator type. */
    using iterator = typename common_type::iterator;
    /*! @brief Reversed iterator type. */
    using reverse_iterator = typename common_type::reverse_iterator;
    /*! @brief Iterable group type. */
    using iterable = iterable_adaptor<internal::extended_group_iterator<iterator, owned_t<Owned...>, get_t<Get...>>>;
    /*! @brief Group handler type. */
    using handler = internal::group_handler<owned_t<std::remove_const_t<Owned>...>, get_t<std::remove_const_t<Get>...>, exclude_t<std::remove_const_t<Exclude>...>>;

    /*! @brief Default constructor to use to create empty, invalid groups. */
    basic_group() noexcept
        : descriptor{} {}

    /**
     * @brief Constructs a group from a set of storage classes.
     * @param ref A reference to a group handler.
     */
    basic_group(handler &ref) noexcept
        : descriptor{&ref} {}

    /**
     * @brief Returns the leading storage of a group.
     * @return The leading storage of the group.
     */
    [[nodiscard]] const common_type &handle() const noexcept {
        return *storage<0>();
    }

    /**
     * @brief Returns the storage for a given component type, if any.
     * @tparam Type Type of component of which to return the storage.
     * @return The storage for the given component type.
     */
    template<typename Type>
    [[nodiscard]] auto *storage() const noexcept {
        return storage<index_of<Type>>();
    }

    /**
     * @brief Returns the storage for a given index, if any.
     * @tparam Index Index of the storage to return.
     * @return The storage for the given index.
     */
    template<std::size_t Index>
    [[nodiscard]] auto *storage() const noexcept {
        constexpr auto offset = sizeof...(Owned) + sizeof...(Get);

        if constexpr(Index < offset) {
            return std::get<Index>(pools());
        } else {
            return std::get<Index - offset>(filter());
        }
    }

    /**
     * @brief Returns the number of entities that that are part of the group.
     * @return Number of entities that that are part of the group.
     */
    [[nodiscard]] size_type size() const noexcept {
        return *this ? descriptor->length() : size_type{};
    }

    /**
     * @brief Checks whether a group is empty.
     * @return True if the group is empty, false otherwise.
     */
    [[nodiscard]] bool empty() const noexcept {
        return !*this || !descriptor->length();
    }

    /**
     * @brief Returns an iterator to the first entity of the group.
     *
     * If the group is empty, the returned iterator will be equal to `end()`.
     *
     * @return An iterator to the first entity of the group.
     */
    [[nodiscard]] iterator begin() const noexcept {
        return *this ? (handle().end() - descriptor->length()) : iterator{};
    }

    /**
     * @brief Returns an iterator that is past the last entity of the group.
     * @return An iterator to the entity following the last entity of the
     * group.
     */
    [[nodiscard]] iterator end() const noexcept {
        return *this ? handle().end() : iterator{};
    }

    /**
     * @brief Returns an iterator to the first entity of the reversed group.
     *
     * If the group is empty, the returned iterator will be equal to `rend()`.
     *
     * @return An iterator to the first entity of the reversed group.
     */
    [[nodiscard]] reverse_iterator rbegin() const noexcept {
        return *this ? handle().rbegin() : reverse_iterator{};
    }

    /**
     * @brief Returns an iterator that is past the last entity of the reversed
     * group.
     * @return An iterator to the entity following the last entity of the
     * reversed group.
     */
    [[nodiscard]] reverse_iterator rend() const noexcept {
        return *this ? (handle().rbegin() + descriptor->length()) : reverse_iterator{};
    }

    /**
     * @brief Returns the first entity of the group, if any.
     * @return The first entity of the group if one exists, the null entity
     * otherwise.
     */
    [[nodiscard]] entity_type front() const noexcept {
        const auto it = begin();
        return it != end() ? *it : null;
    }

    /**
     * @brief Returns the last entity of the group, if any.
     * @return The last entity of the group if one exists, the null entity
     * otherwise.
     */
    [[nodiscard]] entity_type back() const noexcept {
        const auto it = rbegin();
        return it != rend() ? *it : null;
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
        const auto it = *this ? handle().find(entt) : iterator{};
        return it >= begin() ? it : iterator{};
    }

    /**
     * @brief Returns the identifier that occupies the given position.
     * @param pos Position of the element to return.
     * @return The identifier that occupies the given position.
     */
    [[nodiscard]] entity_type operator[](const size_type pos) const {
        return begin()[pos];
    }

    /**
     * @brief Checks if a group is properly initialized.
     * @return True if the group is properly initialized, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return descriptor != nullptr;
    }

    /**
     * @brief Checks if a group contains an entity.
     * @param entt A valid identifier.
     * @return True if the group contains the given entity, false otherwise.
     */
    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
        return *this && handle().contains(entt) && (handle().index(entt) < (descriptor->length()));
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the group results in
     * undefined behavior.
     *
     * @tparam Type Type of the component to get.
     * @tparam Other Other types of components to get.
     * @param entt A valid identifier.
     * @return The components assigned to the entity.
     */
    template<typename Type, typename... Other>
    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
        return get<index_of<Type>, index_of<Other>...>(entt);
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the groups results in
     * undefined behavior.
     *
     * @tparam Index Indexes of the components to get.
     * @param entt A valid identifier.
     * @return The components assigned to the entity.
     */
    template<std::size_t... Index>
    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
        const auto cpools = pools();

        if constexpr(sizeof...(Index) == 0) {
            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, cpools);
        } else if constexpr(sizeof...(Index) == 1) {
            return (std::get<Index>(cpools)->get(entt), ...);
        } else {
            return std::tuple_cat(std::get<Index>(cpools)->get_as_tuple(entt)...);
        }
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        for(auto args: each()) {
            if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_group>().get({})))>) {
                std::apply(func, args);
            } else {
                std::apply([&func](auto, auto &&...less) { func(std::forward<decltype(less)>(less)...); }, args);
            }
        }
    }

    /**
     * @brief Returns an iterable object to use to _visit_ a group.
     *
     * The iterable object returns tuples that contain the current entity and a
     * set of references to its non-empty components. The _constness_ of the
     * components is as requested.
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @return An iterable object to use to _visit_ the group.
     */
    [[nodiscard]] iterable each() const noexcept {
        const auto cpools = pools();
        return {{begin(), cpools}, {end(), cpools}};
    }

    /**
     * @brief Sort a group according to the given comparison function.
     *
     * The comparison function object must return `true` if the first element
     * is _less_ than the second one, `false` otherwise. The signature of the
     * comparison function should be equivalent to one of the following:
     *
     * @code{.cpp}
     * bool(std::tuple<Type &...>, std::tuple<Type &...>);
     * bool(const Type &, const Type &);
     * bool(const Entity, const Entity);
     * @endcode
     *
     * Where `Type` are either owned types or not but still such that they are
     * iterated by the group.<br/>
     * Moreover, the comparison function object shall induce a
     * _strict weak ordering_ on the values.
     *
     * The sort function object must offer a member function template
     * `operator()` that accepts three arguments:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function to use to compare the elements.
     *
     * @tparam Type Optional type of component to compare.
     * @tparam Other Other optional types of components to compare.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Type, typename... Other, typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
        sort<index_of<Type>, index_of<Other>...>(std::move(compare), std::move(algo), std::forward<Args>(args)...);
    }

    /**
     * @brief Sort a group according to the given comparison function.
     *
     * @sa sort
     *
     * @tparam Index Optional indexes of components to compare.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<std::size_t... Index, typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) const {
        const auto cpools = pools();

        if constexpr(sizeof...(Index) == 0) {
            static_assert(std::is_invocable_v<Compare, const entity_type, const entity_type>, "Invalid comparison function");
            storage<0>()->sort_n(descriptor->length(), std::move(compare), std::move(algo), std::forward<Args>(args)...);
        } else {
            auto comp = [&compare, &cpools](const entity_type lhs, const entity_type rhs) {
                if constexpr(sizeof...(Index) == 1) {
                    return compare((std::get<Index>(cpools)->get(lhs), ...), (std::get<Index>(cpools)->get(rhs), ...));
                } else {
                    return compare(std::forward_as_tuple(std::get<Index>(cpools)->get(lhs)...), std::forward_as_tuple(std::get<Index>(cpools)->get(rhs)...));
                }
            };

            storage<0>()->sort_n(descriptor->length(), std::move(comp), std::move(algo), std::forward<Args>(args)...);
        }

        auto cb = [this](auto *head, auto *...other) {
            for(auto next = descriptor->length(); next; --next) {
                const auto pos = next - 1;
                [[maybe_unused]] const auto entt = head->data()[pos];
                (other->swap_elements(other->data()[pos], entt), ...);
            }
        };

        std::apply(cb, cpools);
    }

private:
    handler *descriptor;
};

} // namespace entt

#endif

//////////////////// END OF external/entt/entity/group.hpp /////////////////////

//////////////////// START OF external/entt/signal/fwd.hpp /////////////////////

#ifndef ENTT_SIGNAL_FWD_HPP
#define ENTT_SIGNAL_FWD_HPP

#include <memory>

namespace entt {

template<typename>
class delegate;

template<typename = std::allocator<void>>
class basic_dispatcher;

template<typename, typename = std::allocator<void>>
class emitter;

class connection;

struct scoped_connection;

template<typename>
class sink;

template<typename Type, typename = std::allocator<void>>
class sigh;

/*! @brief Alias declaration for the most common use case. */
using dispatcher = basic_dispatcher<>;

/*! @brief Disambiguation tag for constructors and the like. */
template<auto>
struct connect_arg_t {
    /*! @brief Default constructor. */
    explicit connect_arg_t() = default;
};

/**
 * @brief Constant of type connect_arg_t used to disambiguate calls.
 * @tparam Candidate Element to connect (likely a free or member function).
 */
template<auto Candidate>
inline constexpr connect_arg_t<Candidate> connect_arg{};

} // namespace entt

#endif

///////////////////// END OF external/entt/signal/fwd.hpp //////////////////////

////////////////// START OF external/entt/signal/delegate.hpp //////////////////

#ifndef ENTT_SIGNAL_DELEGATE_HPP
#define ENTT_SIGNAL_DELEGATE_HPP

#include <cstddef>
#include <functional>
#include <tuple>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Ret, typename... Args>
constexpr auto function_pointer(Ret (*)(Args...)) -> Ret (*)(Args...);

template<typename Ret, typename Type, typename... Args, typename Other>
constexpr auto function_pointer(Ret (*)(Type, Args...), Other &&) -> Ret (*)(Args...);

template<typename Class, typename Ret, typename... Args, typename... Other>
constexpr auto function_pointer(Ret (Class::*)(Args...), Other &&...) -> Ret (*)(Args...);

template<typename Class, typename Ret, typename... Args, typename... Other>
constexpr auto function_pointer(Ret (Class::*)(Args...) const, Other &&...) -> Ret (*)(Args...);

template<typename Class, typename Type, typename... Other>
constexpr auto function_pointer(Type Class::*, Other &&...) -> Type (*)();

template<typename... Type>
using function_pointer_t = decltype(function_pointer(std::declval<Type>()...));

template<typename... Class, typename Ret, typename... Args>
[[nodiscard]] constexpr auto index_sequence_for(Ret (*)(Args...)) {
    return std::index_sequence_for<Class..., Args...>{};
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Basic delegate implementation.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 */
template<typename>
class delegate;

/**
 * @brief Utility class to use to send around functions and members.
 *
 * Unmanaged delegate for function pointers and members. Users of this class are
 * in charge of disconnecting instances before deleting them.
 *
 * A delegate can be used as a general purpose invoker without memory overhead
 * for free functions possibly with payloads and bound or unbound members.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
class delegate<Ret(Args...)> {
    template<auto Candidate, std::size_t... Index>
    [[nodiscard]] auto wrap(std::index_sequence<Index...>) noexcept {
        return [](const void *, Args... args) -> Ret {
            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);

            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), type_list_element_t<Index, type_list<Args...>>...>) {
                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
            } else {
                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
                return static_cast<Ret>(std::invoke(Candidate, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
            }
        };
    }

    template<auto Candidate, typename Type, std::size_t... Index>
    [[nodiscard]] auto wrap(Type &, std::index_sequence<Index...>) noexcept {
        return [](const void *payload, Args... args) -> Ret {
            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
            Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));

            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, type_list_element_t<Index, type_list<Args...>>...>) {
                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
            } else {
                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
                return static_cast<Ret>(std::invoke(Candidate, *curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
            }
        };
    }

    template<auto Candidate, typename Type, std::size_t... Index>
    [[nodiscard]] auto wrap(Type *, std::index_sequence<Index...>) noexcept {
        return [](const void *payload, Args... args) -> Ret {
            [[maybe_unused]] const auto arguments = std::forward_as_tuple(std::forward<Args>(args)...);
            Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));

            if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, type_list_element_t<Index, type_list<Args...>>...>) {
                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index, type_list<Args...>>>(std::get<Index>(arguments))...));
            } else {
                constexpr auto offset = sizeof...(Args) - sizeof...(Index);
                return static_cast<Ret>(std::invoke(Candidate, curr, std::forward<type_list_element_t<Index + offset, type_list<Args...>>>(std::get<Index + offset>(arguments))...));
            }
        };
    }

public:
    /*! @brief Function type of the contained target. */
    using function_type = Ret(const void *, Args...);
    /*! @brief Function type of the delegate. */
    using type = Ret(Args...);
    /*! @brief Return type of the delegate. */
    using result_type = Ret;

    /*! @brief Default constructor. */
    delegate() noexcept
        : instance{nullptr},
          fn{nullptr} {}

    /**
     * @brief Constructs a delegate with a given object or payload, if any.
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload, if any.
     * @param value_or_instance Optional valid object that fits the purpose.
     */
    template<auto Candidate, typename... Type>
    delegate(connect_arg_t<Candidate>, Type &&...value_or_instance) noexcept {
        connect<Candidate>(std::forward<Type>(value_or_instance)...);
    }

    /**
     * @brief Constructs a delegate and connects an user defined function with
     * optional payload.
     * @param function Function to connect to the delegate.
     * @param payload User defined arbitrary data.
     */
    delegate(function_type *function, const void *payload = nullptr) noexcept {
        connect(function, payload);
    }

    /**
     * @brief Connects a free function or an unbound member to a delegate.
     * @tparam Candidate Function or member to connect to the delegate.
     */
    template<auto Candidate>
    void connect() noexcept {
        instance = nullptr;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Args...>) {
            fn = [](const void *, Args... args) -> Ret {
                return Ret(std::invoke(Candidate, std::forward<Args>(args)...));
            };
        } else if constexpr(std::is_member_pointer_v<decltype(Candidate)>) {
            fn = wrap<Candidate>(internal::index_sequence_for<type_list_element_t<0, type_list<Args...>>>(internal::function_pointer_t<decltype(Candidate)>{}));
        } else {
            fn = wrap<Candidate>(internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate)>{}));
        }
    }

    /**
     * @brief Connects a free function with payload or a bound member to a
     * delegate.
     *
     * The delegate isn't responsible for the connected object or the payload.
     * Users must always guarantee that the lifetime of the instance overcomes
     * the one of the delegate.<br/>
     * When used to connect a free function with payload, its signature must be
     * such that the instance is the first argument before the ones used to
     * define the delegate itself.
     *
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid reference that fits the purpose.
     */
    template<auto Candidate, typename Type>
    void connect(Type &value_or_instance) noexcept {
        instance = &value_or_instance;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type &, Args...>) {
            fn = [](const void *payload, Args... args) -> Ret {
                Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
                return Ret(std::invoke(Candidate, *curr, std::forward<Args>(args)...));
            };
        } else {
            fn = wrap<Candidate>(value_or_instance, internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate), Type>{}));
        }
    }

    /**
     * @brief Connects a free function with payload or a bound member to a
     * delegate.
     *
     * @sa connect(Type &)
     *
     * @tparam Candidate Function or member to connect to the delegate.
     * @tparam Type Type of class or type of payload.
     * @param value_or_instance A valid pointer that fits the purpose.
     */
    template<auto Candidate, typename Type>
    void connect(Type *value_or_instance) noexcept {
        instance = value_or_instance;

        if constexpr(std::is_invocable_r_v<Ret, decltype(Candidate), Type *, Args...>) {
            fn = [](const void *payload, Args... args) -> Ret {
                Type *curr = static_cast<Type *>(const_cast<constness_as_t<void, Type> *>(payload));
                return Ret(std::invoke(Candidate, curr, std::forward<Args>(args)...));
            };
        } else {
            fn = wrap<Candidate>(value_or_instance, internal::index_sequence_for(internal::function_pointer_t<decltype(Candidate), Type>{}));
        }
    }

    /**
     * @brief Connects an user defined function with optional payload to a
     * delegate.
     *
     * The delegate isn't responsible for the connected object or the payload.
     * Users must always guarantee that the lifetime of an instance overcomes
     * the one of the delegate.<br/>
     * The payload is returned as the first argument to the target function in
     * all cases.
     *
     * @param function Function to connect to the delegate.
     * @param payload User defined arbitrary data.
     */
    void connect(function_type *function, const void *payload = nullptr) noexcept {
        ENTT_ASSERT(function != nullptr, "Uninitialized function pointer");
        instance = payload;
        fn = function;
    }

    /**
     * @brief Resets a delegate.
     *
     * After a reset, a delegate cannot be invoked anymore.
     */
    void reset() noexcept {
        instance = nullptr;
        fn = nullptr;
    }

    /**
     * @brief Returns a pointer to the stored callable function target, if any.
     * @return An opaque pointer to the stored callable function target.
     */
    [[nodiscard]] function_type *target() const noexcept {
        return fn;
    }

    /**
     * @brief Returns the instance or the payload linked to a delegate, if any.
     * @return An opaque pointer to the underlying data.
     */
    [[nodiscard]] const void *data() const noexcept {
        return instance;
    }

    /**
     * @brief Triggers a delegate.
     *
     * The delegate invokes the underlying function and returns the result.
     *
     * @warning
     * Attempting to trigger an invalid delegate results in undefined
     * behavior.
     *
     * @param args Arguments to use to invoke the underlying function.
     * @return The value returned by the underlying function.
     */
    Ret operator()(Args... args) const {
        ENTT_ASSERT(static_cast<bool>(*this), "Uninitialized delegate");
        return fn(instance, std::forward<Args>(args)...);
    }

    /**
     * @brief Checks whether a delegate actually stores a listener.
     * @return False if the delegate is empty, true otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        // no need to also test instance
        return !(fn == nullptr);
    }

    /**
     * @brief Compares the contents of two delegates.
     * @param other Delegate with which to compare.
     * @return False if the two contents differ, true otherwise.
     */
    [[nodiscard]] bool operator==(const delegate<Ret(Args...)> &other) const noexcept {
        return fn == other.fn && instance == other.instance;
    }

private:
    const void *instance;
    function_type *fn;
};

/**
 * @brief Compares the contents of two delegates.
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 * @param lhs A valid delegate object.
 * @param rhs A valid delegate object.
 * @return True if the two contents differ, false otherwise.
 */
template<typename Ret, typename... Args>
[[nodiscard]] bool operator!=(const delegate<Ret(Args...)> &lhs, const delegate<Ret(Args...)> &rhs) noexcept {
    return !(lhs == rhs);
}

/**
 * @brief Deduction guide.
 * @tparam Candidate Function or member to connect to the delegate.
 */
template<auto Candidate>
delegate(connect_arg_t<Candidate>) -> delegate<std::remove_pointer_t<internal::function_pointer_t<decltype(Candidate)>>>;

/**
 * @brief Deduction guide.
 * @tparam Candidate Function or member to connect to the delegate.
 * @tparam Type Type of class or type of payload.
 */
template<auto Candidate, typename Type>
delegate(connect_arg_t<Candidate>, Type &&) -> delegate<std::remove_pointer_t<internal::function_pointer_t<decltype(Candidate), Type>>>;

/**
 * @brief Deduction guide.
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 */
template<typename Ret, typename... Args>
delegate(Ret (*)(const void *, Args...), const void * = nullptr) -> delegate<Ret(Args...)>;

} // namespace entt

#endif

/////////////////// END OF external/entt/signal/delegate.hpp ///////////////////

//////////////////// START OF external/entt/signal/sigh.hpp ////////////////////

#ifndef ENTT_SIGNAL_SIGH_HPP
#define ENTT_SIGNAL_SIGH_HPP

#include <cstddef>
#include <memory>
#include <type_traits>
#include <utility>
#include <vector>

namespace entt {

/**
 * @brief Sink class.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 *
 * @tparam Type A valid signal handler type.
 */
template<typename Type>
class sink;

/**
 * @brief Unmanaged signal handler.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error unless the template parameter is a function type.
 *
 * @tparam Type A valid function type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Type, typename Allocator>
class sigh;

/**
 * @brief Unmanaged signal handler.
 *
 * It works directly with references to classes and pointers to member functions
 * as well as pointers to free functions. Users of this class are in charge of
 * disconnecting instances before deleting them.
 *
 * This class serves mainly two purposes:
 *
 * * Creating signals to use later to notify a bunch of listeners.
 * * Collecting results from a set of functions like in a voting system.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Ret, typename... Args, typename Allocator>
class sigh<Ret(Args...), Allocator> {
    /*! @brief A sink is allowed to modify a signal. */
    friend class sink<sigh<Ret(Args...), Allocator>>;

    using alloc_traits = std::allocator_traits<Allocator>;
    using delegate_type = delegate<Ret(Args...)>;
    using container_type = std::vector<delegate_type, typename alloc_traits::template rebind_alloc<delegate_type>>;

public:
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Sink type. */
    using sink_type = sink<sigh<Ret(Args...), Allocator>>;

    /*! @brief Default constructor. */
    sigh() noexcept(std::is_nothrow_default_constructible_v<allocator_type> &&std::is_nothrow_constructible_v<container_type, const allocator_type &>)
        : sigh{allocator_type{}} {}

    /**
     * @brief Constructs a signal handler with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit sigh(const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, const allocator_type &>)
        : calls{allocator} {}

    /**
     * @brief Copy constructor.
     * @param other The instance to copy from.
     */
    sigh(const sigh &other) noexcept(std::is_nothrow_copy_constructible_v<container_type>)
        : calls{other.calls} {}

    /**
     * @brief Allocator-extended copy constructor.
     * @param other The instance to copy from.
     * @param allocator The allocator to use.
     */
    sigh(const sigh &other, const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, const container_type &, const allocator_type &>)
        : calls{other.calls, allocator} {}

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    sigh(sigh &&other) noexcept(std::is_nothrow_move_constructible_v<container_type>)
        : calls{std::move(other.calls)} {}

    /**
     * @brief Allocator-extended move constructor.
     * @param other The instance to move from.
     * @param allocator The allocator to use.
     */
    sigh(sigh &&other, const allocator_type &allocator) noexcept(std::is_nothrow_constructible_v<container_type, container_type &&, const allocator_type &>)
        : calls{std::move(other.calls), allocator} {}

    /**
     * @brief Copy assignment operator.
     * @param other The instance to copy from.
     * @return This signal handler.
     */
    sigh &operator=(const sigh &other) noexcept(std::is_nothrow_copy_assignable_v<container_type>) {
        calls = other.calls;
        return *this;
    }

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This signal handler.
     */
    sigh &operator=(sigh &&other) noexcept(std::is_nothrow_move_assignable_v<container_type>) {
        calls = std::move(other.calls);
        return *this;
    }

    /**
     * @brief Exchanges the contents with those of a given signal handler.
     * @param other Signal handler to exchange the content with.
     */
    void swap(sigh &other) noexcept(std::is_nothrow_swappable_v<container_type>) {
        using std::swap;
        swap(calls, other.calls);
    }

    /**
     * @brief Returns the associated allocator.
     * @return The associated allocator.
     */
    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return calls.get_allocator();
    }

    /**
     * @brief Number of listeners connected to the signal.
     * @return Number of listeners currently connected.
     */
    [[nodiscard]] size_type size() const noexcept {
        return calls.size();
    }

    /**
     * @brief Returns false if at least a listener is connected to the signal.
     * @return True if the signal has no listeners connected, false otherwise.
     */
    [[nodiscard]] bool empty() const noexcept {
        return calls.empty();
    }

    /**
     * @brief Triggers a signal.
     *
     * All the listeners are notified. Order isn't guaranteed.
     *
     * @param args Arguments to use to invoke listeners.
     */
    void publish(Args... args) const {
        for(auto pos = calls.size(); pos; --pos) {
            calls[pos - 1u](args...);
        }
    }

    /**
     * @brief Collects return values from the listeners.
     *
     * The collector must expose a call operator with the following properties:
     *
     * * The return type is either `void` or such that it's convertible to
     *   `bool`. In the second case, a true value will stop the iteration.
     * * The list of parameters is empty if `Ret` is `void`, otherwise it
     *   contains a single element such that `Ret` is convertible to it.
     *
     * @tparam Func Type of collector to use, if any.
     * @param func A valid function object.
     * @param args Arguments to use to invoke listeners.
     */
    template<typename Func>
    void collect(Func func, Args... args) const {
        for(auto pos = calls.size(); pos; --pos) {
            if constexpr(std::is_void_v<Ret> || !std::is_invocable_v<Func, Ret>) {
                calls[pos - 1u](args...);

                if constexpr(std::is_invocable_r_v<bool, Func>) {
                    if(func()) {
                        break;
                    }
                } else {
                    func();
                }
            } else {
                if constexpr(std::is_invocable_r_v<bool, Func, Ret>) {
                    if(func(calls[pos - 1u](args...))) {
                        break;
                    }
                } else {
                    func(calls[pos - 1u](args...));
                }
            }
        }
    }

private:
    container_type calls;
};

/**
 * @brief Connection class.
 *
 * Opaque object the aim of which is to allow users to release an already
 * estabilished connection without having to keep a reference to the signal or
 * the sink that generated it.
 */
class connection {
    /*! @brief A sink is allowed to create connection objects. */
    template<typename>
    friend class sink;

    connection(delegate<void(void *)> fn, void *ref)
        : disconnect{fn}, signal{ref} {}

public:
    /*! @brief Default constructor. */
    connection()
        : disconnect{},
          signal{} {}

    /**
     * @brief Checks whether a connection is properly initialized.
     * @return True if the connection is properly initialized, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return static_cast<bool>(disconnect);
    }

    /*! @brief Breaks the connection. */
    void release() {
        if(disconnect) {
            disconnect(signal);
            disconnect.reset();
        }
    }

private:
    delegate<void(void *)> disconnect;
    void *signal;
};

/**
 * @brief Scoped connection class.
 *
 * Opaque object the aim of which is to allow users to release an already
 * estabilished connection without having to keep a reference to the signal or
 * the sink that generated it.<br/>
 * A scoped connection automatically breaks the link between the two objects
 * when it goes out of scope.
 */
struct scoped_connection {
    /*! @brief Default constructor. */
    scoped_connection() = default;

    /**
     * @brief Constructs a scoped connection from a basic connection.
     * @param other A valid connection object.
     */
    scoped_connection(const connection &other)
        : conn{other} {}

    /*! @brief Default copy constructor, deleted on purpose. */
    scoped_connection(const scoped_connection &) = delete;

    /**
     * @brief Move constructor.
     * @param other The scoped connection to move from.
     */
    scoped_connection(scoped_connection &&other) noexcept
        : conn{std::exchange(other.conn, {})} {}

    /*! @brief Automatically breaks the link on destruction. */
    ~scoped_connection() {
        conn.release();
    }

    /**
     * @brief Default copy assignment operator, deleted on purpose.
     * @return This scoped connection.
     */
    scoped_connection &operator=(const scoped_connection &) = delete;

    /**
     * @brief Move assignment operator.
     * @param other The scoped connection to move from.
     * @return This scoped connection.
     */
    scoped_connection &operator=(scoped_connection &&other) noexcept {
        conn = std::exchange(other.conn, {});
        return *this;
    }

    /**
     * @brief Acquires a connection.
     * @param other The connection object to acquire.
     * @return This scoped connection.
     */
    scoped_connection &operator=(connection other) {
        conn = std::move(other);
        return *this;
    }

    /**
     * @brief Checks whether a scoped connection is properly initialized.
     * @return True if the connection is properly initialized, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return static_cast<bool>(conn);
    }

    /*! @brief Breaks the connection. */
    void release() {
        conn.release();
    }

private:
    connection conn;
};

/**
 * @brief Sink class.
 *
 * A sink is used to connect listeners to signals and to disconnect them.<br/>
 * The function type for a listener is the one of the signal to which it
 * belongs.
 *
 * The clear separation between a signal and a sink permits to store the former
 * as private data member without exposing the publish functionality to the
 * users of the class.
 *
 * @warning
 * Lifetime of a sink must not overcome that of the signal to which it refers.
 * In any other case, attempting to use a sink results in undefined behavior.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Ret, typename... Args, typename Allocator>
class sink<sigh<Ret(Args...), Allocator>> {
    using signal_type = sigh<Ret(Args...), Allocator>;
    using delegate_type = typename signal_type::delegate_type;
    using difference_type = typename signal_type::container_type::difference_type;

    template<auto Candidate, typename Type>
    static void release(Type value_or_instance, void *signal) {
        sink{*static_cast<signal_type *>(signal)}.disconnect<Candidate>(value_or_instance);
    }

    template<auto Candidate>
    static void release(void *signal) {
        sink{*static_cast<signal_type *>(signal)}.disconnect<Candidate>();
    }

    template<typename Func>
    void disconnect_if(Func callback) {
        for(auto pos = signal->calls.size(); pos; --pos) {
            if(auto &elem = signal->calls[pos - 1u]; callback(elem)) {
                elem = std::move(signal->calls.back());
                signal->calls.pop_back();
            }
        }
    }

public:
    /**
     * @brief Constructs a sink that is allowed to modify a given signal.
     * @param ref A valid reference to a signal object.
     */
    sink(sigh<Ret(Args...), Allocator> &ref) noexcept
        : signal{&ref} {}

    /**
     * @brief Returns false if at least a listener is connected to the sink.
     * @return True if the sink has no listeners connected, false otherwise.
     */
    [[nodiscard]] bool empty() const noexcept {
        return signal->calls.empty();
    }

    /**
     * @brief Connects a free function (with or without payload), a bound or an
     * unbound member to a signal.
     * @tparam Candidate Function or member to connect to the signal.
     * @tparam Type Type of class or type of payload, if any.
     * @param value_or_instance A valid object that fits the purpose, if any.
     * @return A properly initialized connection object.
     */
    template<auto Candidate, typename... Type>
    connection connect(Type &&...value_or_instance) {
        disconnect<Candidate>(value_or_instance...);

        delegate_type call{};
        call.template connect<Candidate>(value_or_instance...);
        signal->calls.push_back(std::move(call));

        delegate<void(void *)> conn{};
        conn.template connect<&release<Candidate, Type...>>(value_or_instance...);
        return {std::move(conn), signal};
    }

    /**
     * @brief Disconnects a free function (with or without payload), a bound or
     * an unbound member from a signal.
     * @tparam Candidate Function or member to disconnect from the signal.
     * @tparam Type Type of class or type of payload, if any.
     * @param value_or_instance A valid object that fits the purpose, if any.
     */
    template<auto Candidate, typename... Type>
    void disconnect(Type &&...value_or_instance) {
        delegate_type call{};
        call.template connect<Candidate>(value_or_instance...);
        disconnect_if([&call](const auto &elem) { return elem == call; });
    }

    /**
     * @brief Disconnects free functions with payload or bound members from a
     * signal.
     * @param value_or_instance A valid object that fits the purpose.
     */
    void disconnect(const void *value_or_instance) {
        if(value_or_instance) {
            disconnect_if([value_or_instance](const auto &elem) { return elem.data() == value_or_instance; });
        }
    }

    /*! @brief Disconnects all the listeners from a signal. */
    void disconnect() {
        signal->calls.clear();
    }

private:
    signal_type *signal;
};

/**
 * @brief Deduction guide.
 *
 * It allows to deduce the signal handler type of a sink directly from the
 * signal it refers to.
 *
 * @tparam Ret Return type of a function type.
 * @tparam Args Types of arguments of a function type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Ret, typename... Args, typename Allocator>
sink(sigh<Ret(Args...), Allocator> &) -> sink<sigh<Ret(Args...), Allocator>>;

} // namespace entt

#endif

///////////////////// END OF external/entt/signal/sigh.hpp /////////////////////

/////////////////// START OF external/entt/entity/mixin.hpp ////////////////////

#ifndef ENTT_ENTITY_MIXIN_HPP
#define ENTT_ENTITY_MIXIN_HPP

#include <type_traits>
#include <utility>

namespace entt {

/**
 * @brief Mixin type used to add signal support to storage types.
 *
 * The function type of a listener is equivalent to:
 *
 * @code{.cpp}
 * void(basic_registry<entity_type> &, entity_type);
 * @endcode
 *
 * This applies to all signals made available.
 *
 * @tparam Type The type of the underlying storage.
 */
template<typename Type>
class sigh_mixin final: public Type {
    using underlying_type = Type;
    using basic_registry_type = basic_registry<typename underlying_type::entity_type, typename underlying_type::base_type::allocator_type>;
    using sigh_type = sigh<void(basic_registry_type &, const typename underlying_type::entity_type), typename underlying_type::allocator_type>;
    using underlying_iterator = typename underlying_type::base_type::basic_iterator;

    basic_registry_type &owner_or_assert() const noexcept {
        ENTT_ASSERT(owner != nullptr, "Invalid pointer to registry");
        return *owner;
    }

    void pop(underlying_iterator first, underlying_iterator last) final {
        if(auto &reg = owner_or_assert(); destruction.empty()) {
            underlying_type::pop(first, last);
        } else {
            for(; first != last; ++first) {
                const auto entt = *first;
                destruction.publish(reg, entt);
                const auto it = underlying_type::find(entt);
                underlying_type::pop(it, it + 1u);
            }
        }
    }

    void pop_all() final {
        if(auto &reg = owner_or_assert(); !destruction.empty()) {
            for(auto pos = underlying_type::each().begin().base().index(); !(pos < 0); --pos) {
                if constexpr(underlying_type::traits_type::in_place_delete) {
                    if(const auto entt = underlying_type::operator[](static_cast<typename underlying_type::size_type>(pos)); entt != tombstone) {
                        destruction.publish(reg, entt);
                    }
                } else {
                    destruction.publish(reg, underlying_type::operator[](static_cast<typename underlying_type::size_type>(pos)));
                }
            }
        }

        underlying_type::pop_all();
    }

    underlying_iterator try_emplace(const typename underlying_type::entity_type entt, const bool force_back, const void *value) final {
        const auto it = underlying_type::try_emplace(entt, force_back, value);

        if(auto &reg = owner_or_assert(); it != underlying_type::base_type::end()) {
            construction.publish(reg, *it);
        }

        return it;
    }

public:
    /*! @brief Allocator type. */
    using allocator_type = typename underlying_type::allocator_type;
    /*! @brief Underlying entity identifier. */
    using entity_type = typename underlying_type::entity_type;
    /*! @brief Expected registry type. */
    using registry_type = basic_registry_type;

    /*! @brief Default constructor. */
    sigh_mixin()
        : sigh_mixin{allocator_type{}} {}

    /**
     * @brief Constructs an empty storage with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit sigh_mixin(const allocator_type &allocator)
        : underlying_type{allocator},
          owner{},
          construction{allocator},
          destruction{allocator},
          update{allocator} {}

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    sigh_mixin(sigh_mixin &&other) noexcept
        : underlying_type{std::move(other)},
          owner{other.owner},
          construction{std::move(other.construction)},
          destruction{std::move(other.destruction)},
          update{std::move(other.update)} {}

    /**
     * @brief Allocator-extended move constructor.
     * @param other The instance to move from.
     * @param allocator The allocator to use.
     */
    sigh_mixin(sigh_mixin &&other, const allocator_type &allocator) noexcept
        : underlying_type{std::move(other), allocator},
          owner{other.owner},
          construction{std::move(other.construction), allocator},
          destruction{std::move(other.destruction), allocator},
          update{std::move(other.update), allocator} {}

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This storage.
     */
    sigh_mixin &operator=(sigh_mixin &&other) noexcept {
        underlying_type::operator=(std::move(other));
        owner = other.owner;
        construction = std::move(other.construction);
        destruction = std::move(other.destruction);
        update = std::move(other.update);
        return *this;
    }

    /**
     * @brief Exchanges the contents with those of a given storage.
     * @param other Storage to exchange the content with.
     */
    void swap(sigh_mixin &other) {
        using std::swap;
        underlying_type::swap(other);
        swap(owner, other.owner);
        swap(construction, other.construction);
        swap(destruction, other.destruction);
        swap(update, other.update);
    }

    /**
     * @brief Returns a sink object.
     *
     * The sink returned by this function can be used to receive notifications
     * whenever a new instance is created and assigned to an entity.<br/>
     * Listeners are invoked after the object has been assigned to the entity.
     *
     * @sa sink
     *
     * @return A temporary sink object.
     */
    [[nodiscard]] auto on_construct() noexcept {
        return sink{construction};
    }

    /**
     * @brief Returns a sink object.
     *
     * The sink returned by this function can be used to receive notifications
     * whenever an instance is explicitly updated.<br/>
     * Listeners are invoked after the object has been updated.
     *
     * @sa sink
     *
     * @return A temporary sink object.
     */
    [[nodiscard]] auto on_update() noexcept {
        return sink{update};
    }

    /**
     * @brief Returns a sink object.
     *
     * The sink returned by this function can be used to receive notifications
     * whenever an instance is removed from an entity and thus destroyed.<br/>
     * Listeners are invoked before the object has been removed from the entity.
     *
     * @sa sink
     *
     * @return A temporary sink object.
     */
    [[nodiscard]] auto on_destroy() noexcept {
        return sink{destruction};
    }

    /**
     * @brief Emplace elements into a storage.
     *
     * The behavior of this operation depends on the underlying storage type
     * (for example, components vs entities).<br/>
     * Refer to the specific documentation for more details.
     *
     * @return A return value as returned by the underlying storage.
     */
    auto emplace() {
        const auto entt = underlying_type::emplace();
        construction.publish(owner_or_assert(), entt);
        return entt;
    }

    /**
     * @brief Emplace elements into a storage.
     *
     * The behavior of this operation depends on the underlying storage type
     * (for example, components vs entities).<br/>
     * Refer to the specific documentation for more details.
     *
     * @tparam Args Types of arguments to forward to the underlying storage.
     * @param hint A valid identifier.
     * @param args Parameters to forward to the underlying storage.
     * @return A return value as returned by the underlying storage.
     */
    template<typename... Args>
    decltype(auto) emplace(const entity_type hint, Args &&...args) {
        if constexpr(std::is_same_v<typename underlying_type::value_type, typename underlying_type::entity_type>) {
            const auto entt = underlying_type::emplace(hint, std::forward<Args>(args)...);
            construction.publish(owner_or_assert(), entt);
            return entt;
        } else {
            underlying_type::emplace(hint, std::forward<Args>(args)...);
            construction.publish(owner_or_assert(), hint);
            return this->get(hint);
        }
    }

    /**
     * @brief Patches the given instance for an entity.
     * @tparam Func Types of the function objects to invoke.
     * @param entt A valid identifier.
     * @param func Valid function objects.
     * @return A reference to the patched instance.
     */
    template<typename... Func>
    decltype(auto) patch(const entity_type entt, Func &&...func) {
        underlying_type::patch(entt, std::forward<Func>(func)...);
        update.publish(owner_or_assert(), entt);
        return this->get(entt);
    }

    /**
     * @brief Emplace elements into a storage.
     *
     * The behavior of this operation depends on the underlying storage type
     * (for example, components vs entities).<br/>
     * Refer to the specific documentation for more details.
     *
     * @tparam It Iterator type (as required by the underlying storage type).
     * @tparam Args Types of arguments to forward to the underlying storage.
     * @param first An iterator to the first element of the range.
     * @param last An iterator past the last element of the range.
     * @param args Parameters to use to forward to the underlying storage.
     */
    template<typename It, typename... Args>
    void insert(It first, It last, Args &&...args) {
        underlying_type::insert(first, last, std::forward<Args>(args)...);

        if(auto &reg = owner_or_assert(); !construction.empty()) {
            for(; first != last; ++first) {
                construction.publish(reg, *first);
            }
        }
    }

    /**
     * @brief Forwards variables to derived classes, if any.
     * @param value A variable wrapped in an opaque container.
     */
    void bind(any value) noexcept final {
        auto *reg = any_cast<basic_registry_type>(&value);
        owner = reg ? reg : owner;
        underlying_type::bind(std::move(value));
    }

private:
    basic_registry_type *owner;
    sigh_type construction;
    sigh_type destruction;
    sigh_type update;
};

} // namespace entt

#endif

//////////////////// END OF external/entt/entity/mixin.hpp /////////////////////

//////////////////// START OF external/entt/entity/view.hpp ////////////////////

#ifndef ENTT_ENTITY_VIEW_HPP
#define ENTT_ENTITY_VIEW_HPP

#include <array>
#include <iterator>
#include <tuple>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename... Args, typename Type, std::size_t N>
[[nodiscard]] auto filter_as_tuple(const std::array<const Type *, N> &filter) noexcept {
    return std::apply([](const auto *...curr) { return std::make_tuple(static_cast<Args *>(const_cast<constness_as_t<Type, Args> *>(curr))...); }, filter);
}

template<typename Type, std::size_t N>
[[nodiscard]] auto none_of(const std::array<const Type *, N> &filter, const typename Type::entity_type entt) noexcept {
    return std::apply([entt](const auto *...curr) { return (!(curr && curr->contains(entt)) && ...); }, filter);
}

template<typename... Get, typename... Exclude, std::size_t... Index>
[[nodiscard]] auto view_pack(const std::tuple<Get *...> value, const std::tuple<Exclude *...> excl, std::index_sequence<Index...>) {
    const auto pools = std::tuple_cat(value, excl);
    basic_view<get_t<Get...>, exclude_t<Exclude...>> elem{};
    (((std::get<Index>(pools) != nullptr) ? elem.template storage<Index>(*std::get<Index>(pools)) : void()), ...);
    return elem;
}

template<typename Type, std::size_t Get, std::size_t Exclude>
class view_iterator final {
    using iterator_type = typename Type::const_iterator;

    [[nodiscard]] bool valid() const noexcept {
        return ((Get != 0u) || (*it != tombstone))
               && std::apply([entt = *it](const auto *...curr) { return (curr->contains(entt) && ...); }, pools)
               && none_of(filter, *it);
    }

public:
    using value_type = typename iterator_type::value_type;
    using pointer = typename iterator_type::pointer;
    using reference = typename iterator_type::reference;
    using difference_type = typename iterator_type::difference_type;
    using iterator_category = std::forward_iterator_tag;

    constexpr view_iterator() noexcept
        : it{},
          last{},
          pools{},
          filter{} {}

    view_iterator(iterator_type curr, iterator_type to, std::array<const Type *, Get> value, std::array<const Type *, Exclude> excl) noexcept
        : it{curr},
          last{to},
          pools{value},
          filter{excl} {
        while(it != last && !valid()) {
            ++it;
        }
    }

    view_iterator &operator++() noexcept {
        while(++it != last && !valid()) {}
        return *this;
    }

    view_iterator operator++(int) noexcept {
        view_iterator orig = *this;
        return ++(*this), orig;
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return &*it;
    }

    [[nodiscard]] reference operator*() const noexcept {
        return *operator->();
    }

    template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
    friend constexpr bool operator==(const view_iterator<LhsType, LhsArgs...> &, const view_iterator<RhsType, RhsArgs...> &) noexcept;

private:
    iterator_type it;
    iterator_type last;
    std::array<const Type *, Get> pools;
    std::array<const Type *, Exclude> filter;
};

template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
[[nodiscard]] constexpr bool operator==(const view_iterator<LhsType, LhsArgs...> &lhs, const view_iterator<RhsType, RhsArgs...> &rhs) noexcept {
    return lhs.it == rhs.it;
}

template<typename LhsType, auto... LhsArgs, typename RhsType, auto... RhsArgs>
[[nodiscard]] constexpr bool operator!=(const view_iterator<LhsType, LhsArgs...> &lhs, const view_iterator<RhsType, RhsArgs...> &rhs) noexcept {
    return !(lhs == rhs);
}

template<typename It, typename... Type>
struct extended_view_iterator final {
    using iterator_type = It;
    using difference_type = std::ptrdiff_t;
    using value_type = decltype(std::tuple_cat(std::make_tuple(*std::declval<It>()), std::declval<Type>().get_as_tuple({})...));
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using iterator_category = std::input_iterator_tag;

    constexpr extended_view_iterator()
        : it{},
          pools{} {}

    extended_view_iterator(It from, std::tuple<Type *...> value)
        : it{from},
          pools{value} {}

    extended_view_iterator &operator++() noexcept {
        return ++it, *this;
    }

    extended_view_iterator operator++(int) noexcept {
        extended_view_iterator orig = *this;
        return ++(*this), orig;
    }

    [[nodiscard]] reference operator*() const noexcept {
        return std::apply([entt = *it](auto *...curr) { return std::tuple_cat(std::make_tuple(entt), curr->get_as_tuple(entt)...); }, pools);
    }

    [[nodiscard]] pointer operator->() const noexcept {
        return operator*();
    }

    [[nodiscard]] constexpr iterator_type base() const noexcept {
        return it;
    }

    template<typename... Lhs, typename... Rhs>
    friend bool constexpr operator==(const extended_view_iterator<Lhs...> &, const extended_view_iterator<Rhs...> &) noexcept;

private:
    It it;
    std::tuple<Type *...> pools;
};

template<typename... Lhs, typename... Rhs>
[[nodiscard]] constexpr bool operator==(const extended_view_iterator<Lhs...> &lhs, const extended_view_iterator<Rhs...> &rhs) noexcept {
    return lhs.it == rhs.it;
}

template<typename... Lhs, typename... Rhs>
[[nodiscard]] constexpr bool operator!=(const extended_view_iterator<Lhs...> &lhs, const extended_view_iterator<Rhs...> &rhs) noexcept {
    return !(lhs == rhs);
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief View implementation.
 *
 * Primary template isn't defined on purpose. All the specializations give a
 * compile-time error, but for a few reasonable cases.
 */
template<typename, typename, typename>
class basic_view;

/**
 * @brief Multi component view.
 *
 * Multi component views iterate over those entities that are at least in the
 * given storage. During initialization, a multi component view looks at the
 * number of entities available for each component and uses the smallest set in
 * order to get a performance boost when iterating.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New elements are added to the storage.
 * * The entity currently pointed is modified (for example, components are added
 *   or removed from it).
 * * The entity currently pointed is destroyed.
 *
 * In all other cases, modifying the storage iterated by the view in any way
 * invalidates all the iterators.
 *
 * @tparam Get Types of storage iterated by the view.
 * @tparam Exclude Types of storage used to filter the view.
 */
template<typename... Get, typename... Exclude>
class basic_view<get_t<Get...>, exclude_t<Exclude...>> {
    static constexpr auto offset = sizeof...(Get);
    using base_type = std::common_type_t<typename Get::base_type..., typename Exclude::base_type...>;
    using underlying_type = typename base_type::entity_type;

    template<typename, typename, typename>
    friend class basic_view;

    template<typename Type>
    static constexpr std::size_t index_of = type_list_index_v<std::remove_const_t<Type>, type_list<typename Get::value_type..., typename Exclude::value_type...>>;

    [[nodiscard]] auto opaque_check_set() const noexcept {
        std::array<const common_type *, sizeof...(Get) - 1u> other{};
        std::apply([&other, pos = 0u, view = view](const auto *...curr) mutable { ((curr == view ? void() : void(other[pos++] = curr)), ...); }, pools);
        return other;
    }

    void unchecked_refresh() noexcept {
        view = std::get<0>(pools);
        std::apply([this](auto *, auto *...other) { ((this->view = other->size() < this->view->size() ? other : this->view), ...); }, pools);
    }

    template<std::size_t Curr, std::size_t Other, typename... Args>
    [[nodiscard]] auto dispatch_get(const std::tuple<underlying_type, Args...> &curr) const {
        if constexpr(Curr == Other) {
            return std::forward_as_tuple(std::get<Args>(curr)...);
        } else {
            return std::get<Other>(pools)->get_as_tuple(std::get<0>(curr));
        }
    }

    template<std::size_t Curr, typename Func, std::size_t... Index>
    void each(Func &func, std::index_sequence<Index...>) const {
        for(const auto curr: std::get<Curr>(pools)->each()) {
            if(const auto entt = std::get<0>(curr); ((sizeof...(Get) != 1u) || (entt != tombstone)) && ((Curr == Index || std::get<Index>(pools)->contains(entt)) && ...) && internal::none_of(filter, entt)) {
                if constexpr(is_applicable_v<Func, decltype(std::tuple_cat(std::tuple<entity_type>{}, std::declval<basic_view>().get({})))>) {
                    std::apply(func, std::tuple_cat(std::make_tuple(entt), dispatch_get<Curr, Index>(curr)...));
                } else {
                    std::apply(func, std::tuple_cat(dispatch_get<Curr, Index>(curr)...));
                }
            }
        }
    }

    template<typename Func, std::size_t... Index>
    void pick_and_each(Func &func, std::index_sequence<Index...> seq) const {
        ((std::get<Index>(pools) == view ? each<Index>(func, seq) : void()), ...);
    }

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = underlying_type;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Common type among all storage types. */
    using common_type = base_type;
    /*! @brief Bidirectional iterator type. */
    using iterator = internal::view_iterator<common_type, sizeof...(Get) - 1u, sizeof...(Exclude)>;
    /*! @brief Iterable view type. */
    using iterable = iterable_adaptor<internal::extended_view_iterator<iterator, Get...>>;

    /*! @brief Default constructor to use to create empty, invalid views. */
    basic_view() noexcept
        : pools{},
          filter{},
          view{} {}

    /**
     * @brief Constructs a multi-type view from a set of storage classes.
     * @param value The storage for the types to iterate.
     * @param excl The storage for the types used to filter the view.
     */
    basic_view(Get &...value, Exclude &...excl) noexcept
        : pools{&value...},
          filter{&excl...},
          view{} {
        unchecked_refresh();
    }

    /**
     * @brief Constructs a multi-type view from a set of storage classes.
     * @param value The storage for the types to iterate.
     * @param excl The storage for the types used to filter the view.
     */
    basic_view(std::tuple<Get &...> value, std::tuple<Exclude &...> excl = {}) noexcept
        : basic_view{std::make_from_tuple<basic_view>(std::tuple_cat(value, excl))} {}

    /**
     * @brief Forces a view to use a given component to drive iterations
     * @tparam Type Type of component to use to drive iterations.
     */
    template<typename Type>
    void use() noexcept {
        use<index_of<Type>>();
    }

    /**
     * @brief Forces a view to use a given component to drive iterations
     * @tparam Index Index of the component to use to drive iterations.
     */
    template<std::size_t Index>
    void use() noexcept {
        if(view) {
            view = std::get<Index>(pools);
        }
    }

    /*! @brief Updates the internal leading view if required. */
    void refresh() noexcept {
        if(view || std::apply([](const auto *...curr) { return ((curr != nullptr) && ...); }, pools)) {
            unchecked_refresh();
        }
    }

    /**
     * @brief Returns the leading storage of a view, if any.
     * @return The leading storage of the view.
     */
    [[nodiscard]] const common_type *handle() const noexcept {
        return view;
    }

    /**
     * @brief Returns the storage for a given component type, if any.
     * @tparam Type Type of component of which to return the storage.
     * @return The storage for the given component type.
     */
    template<typename Type>
    [[nodiscard]] auto *storage() const noexcept {
        return storage<index_of<Type>>();
    }

    /**
     * @brief Returns the storage for a given index, if any.
     * @tparam Index Index of the storage to return.
     * @return The storage for the given index.
     */
    template<std::size_t Index>
    [[nodiscard]] auto *storage() const noexcept {
        if constexpr(Index < offset) {
            return std::get<Index>(pools);
        } else {
            return std::get<Index - offset>(internal::filter_as_tuple<Exclude...>(filter));
        }
    }

    /**
     * @brief Assigns a storage to a view.
     * @tparam Type Type of storage to assign to the view.
     * @param elem A storage to assign to the view.
     */
    template<typename Type>
    void storage(Type &elem) noexcept {
        storage<index_of<typename Type::value_type>>(elem);
    }

    /**
     * @brief Assigns a storage to a view.
     * @tparam Index Index of the storage to assign to the view.
     * @tparam Type Type of storage to assign to the view.
     * @param elem A storage to assign to the view.
     */
    template<std::size_t Index, typename Type>
    void storage(Type &elem) noexcept {
        if constexpr(Index < offset) {
            std::get<Index>(pools) = &elem;
            refresh();
        } else {
            std::get<Index - offset>(filter) = &elem;
        }
    }

    /**
     * @brief Estimates the number of entities iterated by the view.
     * @return Estimated number of entities iterated by the view.
     */
    [[nodiscard]] size_type size_hint() const noexcept {
        return view ? view->size() : size_type{};
    }

    /**
     * @brief Returns an iterator to the first entity of the view.
     *
     * If the view is empty, the returned iterator will be equal to `end()`.
     *
     * @return An iterator to the first entity of the view.
     */
    [[nodiscard]] iterator begin() const noexcept {
        return view ? iterator{view->begin(), view->end(), opaque_check_set(), filter} : iterator{};
    }

    /**
     * @brief Returns an iterator that is past the last entity of the view.
     * @return An iterator to the entity following the last entity of the view.
     */
    [[nodiscard]] iterator end() const noexcept {
        return view ? iterator{view->end(), view->end(), opaque_check_set(), filter} : iterator{};
    }

    /**
     * @brief Returns the first entity of the view, if any.
     * @return The first entity of the view if one exists, the null entity
     * otherwise.
     */
    [[nodiscard]] entity_type front() const noexcept {
        const auto it = begin();
        return it != end() ? *it : null;
    }

    /**
     * @brief Returns the last entity of the view, if any.
     * @return The last entity of the view if one exists, the null entity
     * otherwise.
     */
    [[nodiscard]] entity_type back() const noexcept {
        if(view) {
            auto it = view->rbegin();
            for(const auto last = view->rend(); it != last && !contains(*it); ++it) {}
            return it == view->rend() ? null : *it;
        }

        return null;
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
        return contains(entt) ? iterator{view->find(entt), view->end(), opaque_check_set(), filter} : end();
    }

    /**
     * @brief Returns the components assigned to the given entity.
     * @param entt A valid identifier.
     * @return The components assigned to the given entity.
     */
    [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
        return get(entt);
    }

    /**
     * @brief Checks if a view is fully initialized.
     * @return True if the view is fully initialized, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return std::apply([](const auto *...curr) { return ((curr != nullptr) && ...); }, pools)
               && std::apply([](const auto *...curr) { return ((curr != nullptr) && ...); }, filter);
    }

    /**
     * @brief Checks if a view contains an entity.
     * @param entt A valid identifier.
     * @return True if the view contains the given entity, false otherwise.
     */
    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
        return view && std::apply([entt](const auto *...curr) { return (curr->contains(entt) && ...); }, pools) && internal::none_of(filter, entt);
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the view results in
     * undefined behavior.
     *
     * @tparam Type Type of the component to get.
     * @tparam Other Other types of components to get.
     * @param entt A valid identifier.
     * @return The components assigned to the entity.
     */
    template<typename Type, typename... Other>
    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
        return get<index_of<Type>, index_of<Other>...>(entt);
    }

    /**
     * @brief Returns the components assigned to the given entity.
     *
     * @sa get
     *
     * @tparam Index Indexes of the components to get.
     * @param entt A valid identifier.
     * @return The components assigned to the entity.
     */
    template<std::size_t... Index>
    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
        if constexpr(sizeof...(Index) == 0) {
            return std::apply([entt](auto *...curr) { return std::tuple_cat(curr->get_as_tuple(entt)...); }, pools);
        } else if constexpr(sizeof...(Index) == 1) {
            return (std::get<Index>(pools)->get(entt), ...);
        } else {
            return std::tuple_cat(std::get<Index>(pools)->get_as_tuple(entt)...);
        }
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a set of references to non-empty components. The
     * _constness_ of the components is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &...);
     * void(Type &...);
     * @endcode
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        view ? pick_and_each(func, std::index_sequence_for<Get...>{}) : void();
    }

    /**
     * @brief Returns an iterable object to use to _visit_ a view.
     *
     * The iterable object returns a tuple that contains the current entity and
     * a set of references to its non-empty components. The _constness_ of the
     * components is as requested.
     *
     * @return An iterable object to use to _visit_ the view.
     */
    [[nodiscard]] iterable each() const noexcept {
        return {internal::extended_view_iterator{begin(), pools}, internal::extended_view_iterator{end(), pools}};
    }

    /**
     * @brief Combines two views in a _more specific_ one (friend function).
     * @tparam OGet Component list of the view to combine with.
     * @tparam OExclude Filter list of the view to combine with.
     * @param other The view to combine with.
     * @return A more specific view.
     */
    template<typename... OGet, typename... OExclude>
    [[nodiscard]] auto operator|(const basic_view<get_t<OGet...>, exclude_t<OExclude...>> &other) const noexcept {
        return internal::view_pack(
            std::tuple_cat(pools, other.pools),
            std::tuple_cat(internal::filter_as_tuple<Exclude...>(filter), internal::filter_as_tuple<OExclude...>(other.filter)),
            std::index_sequence_for<Get..., OGet..., Exclude..., OExclude...>{});
    }

private:
    std::tuple<Get *...> pools;
    std::array<const common_type *, sizeof...(Exclude)> filter;
    const common_type *view;
};

/**
 * @brief Single component view specialization.
 *
 * Single component views are specialized in order to get a boost in terms of
 * performance. This kind of views can access the underlying data structure
 * directly and avoid superfluous checks.
 *
 * @b Important
 *
 * Iterators aren't invalidated if:
 *
 * * New elements are added to the storage.
 * * The entity currently pointed is modified (for example, components are added
 *   or removed from it).
 * * The entity currently pointed is destroyed.
 *
 * In all other cases, modifying the storage iterated by the view in any way
 * invalidates all the iterators.
 *
 * @tparam Get Type of storage iterated by the view.
 */
template<typename Get>
class basic_view<get_t<Get>, exclude_t<>, std::void_t<std::enable_if_t<!Get::traits_type::in_place_delete>>> {
    template<typename, typename, typename>
    friend class basic_view;

public:
    /*! @brief Underlying entity identifier. */
    using entity_type = typename Get::entity_type;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Common type among all storage types. */
    using common_type = typename Get::base_type;
    /*! @brief Random access iterator type. */
    using iterator = typename common_type::iterator;
    /*! @brief Reversed iterator type. */
    using reverse_iterator = typename common_type::reverse_iterator;
    /*! @brief Iterable view type. */
    using iterable = decltype(std::declval<Get>().each());

    /*! @brief Default constructor to use to create empty, invalid views. */
    basic_view() noexcept
        : pools{},
          filter{},
          view{} {}

    /**
     * @brief Constructs a single-type view from a storage class.
     * @param value The storage for the type to iterate.
     */
    basic_view(Get &value) noexcept
        : pools{&value},
          filter{},
          view{&value} {}

    /**
     * @brief Constructs a single-type view from a storage class.
     * @param value The storage for the type to iterate.
     */
    basic_view(std::tuple<Get &> value, std::tuple<> = {}) noexcept
        : basic_view{std::get<0>(value)} {}

    /**
     * @brief Returns the leading storage of a view, if any.
     * @return The leading storage of the view.
     */
    [[nodiscard]] const common_type *handle() const noexcept {
        return view;
    }

    /**
     * @brief Returns the storage for a given component type, if any.
     * @tparam Type Type of component of which to return the storage.
     * @return The storage for the given component type.
     */
    template<typename Type = typename Get::value_type>
    [[nodiscard]] auto *storage() const noexcept {
        static_assert(std::is_same_v<std::remove_const_t<Type>, typename Get::value_type>, "Invalid component type");
        return storage<0>();
    }

    /**
     * @brief Returns the storage for a given index, if any.
     * @tparam Index Index of the storage to return.
     * @return The storage for the given index.
     */
    template<std::size_t Index>
    [[nodiscard]] auto *storage() const noexcept {
        return std::get<Index>(pools);
    }

    /**
     * @brief Assigns a storage to a view.
     * @param elem A storage to assign to the view.
     */
    void storage(Get &elem) noexcept {
        storage<0>(elem);
    }

    /**
     * @brief Assigns a storage to a view.
     * @tparam Index Index of the storage to assign to the view.
     * @param elem A storage to assign to the view.
     */
    template<std::size_t Index>
    void storage(Get &elem) noexcept {
        view = std::get<Index>(pools) = &elem;
    }

    /**
     * @brief Returns the number of entities that have the given component.
     * @return Number of entities that have the given component.
     */
    [[nodiscard]] size_type size() const noexcept {
        return view ? view->size() : size_type{};
    }

    /**
     * @brief Checks whether a view is empty.
     * @return True if the view is empty, false otherwise.
     */
    [[nodiscard]] bool empty() const noexcept {
        return !view || view->empty();
    }

    /**
     * @brief Returns an iterator to the first entity of the view.
     *
     * If the view is empty, the returned iterator will be equal to `end()`.
     *
     * @return An iterator to the first entity of the view.
     */
    [[nodiscard]] iterator begin() const noexcept {
        return view ? view->begin() : iterator{};
    }

    /**
     * @brief Returns an iterator that is past the last entity of the view.
     * @return An iterator to the entity following the last entity of the view.
     */
    [[nodiscard]] iterator end() const noexcept {
        return view ? view->end() : iterator{};
    }

    /**
     * @brief Returns an iterator to the first entity of the reversed view.
     *
     * If the view is empty, the returned iterator will be equal to `rend()`.
     *
     * @return An iterator to the first entity of the reversed view.
     */
    [[nodiscard]] reverse_iterator rbegin() const noexcept {
        return view ? view->rbegin() : reverse_iterator{};
    }

    /**
     * @brief Returns an iterator that is past the last entity of the reversed
     * view.
     * @return An iterator to the entity following the last entity of the
     * reversed view.
     */
    [[nodiscard]] reverse_iterator rend() const noexcept {
        return view ? view->rend() : reverse_iterator{};
    }

    /**
     * @brief Returns the first entity of the view, if any.
     * @return The first entity of the view if one exists, the null entity
     * otherwise.
     */
    [[nodiscard]] entity_type front() const noexcept {
        return (!view || view->empty()) ? null : *view->begin();
    }

    /**
     * @brief Returns the last entity of the view, if any.
     * @return The last entity of the view if one exists, the null entity
     * otherwise.
     */
    [[nodiscard]] entity_type back() const noexcept {
        return (!view || view->empty()) ? null : *view->rbegin();
    }

    /**
     * @brief Finds an entity.
     * @param entt A valid identifier.
     * @return An iterator to the given entity if it's found, past the end
     * iterator otherwise.
     */
    [[nodiscard]] iterator find(const entity_type entt) const noexcept {
        return view ? view->find(entt) : iterator{};
    }

    /**
     * @brief Returns the identifier that occupies the given position.
     * @param pos Position of the element to return.
     * @return The identifier that occupies the given position.
     */
    [[nodiscard]] entity_type operator[](const size_type pos) const {
        return begin()[pos];
    }

    /**
     * @brief Returns the component assigned to the given entity.
     * @param entt A valid identifier.
     * @return The component assigned to the given entity.
     */
    [[nodiscard]] decltype(auto) operator[](const entity_type entt) const {
        return std::get<0>(pools)->get(entt);
    }

    /**
     * @brief Checks if a view is fully initialized.
     * @return True if the view is fully initialized, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return (std::get<0>(pools) != nullptr);
    }

    /**
     * @brief Checks if a view contains an entity.
     * @param entt A valid identifier.
     * @return True if the view contains the given entity, false otherwise.
     */
    [[nodiscard]] bool contains(const entity_type entt) const noexcept {
        return view && view->contains(entt);
    }

    /**
     * @brief Returns the component assigned to the given entity.
     *
     * @warning
     * Attempting to use an entity that doesn't belong to the view results in
     * undefined behavior.
     *
     * @tparam Elem Type or index of the component to get.
     * @param entt A valid identifier.
     * @return The component assigned to the entity.
     */
    template<typename Elem>
    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
        static_assert(std::is_same_v<std::remove_const_t<Elem>, typename Get::value_type>, "Invalid component type");
        return get<0>(entt);
    }

    /*! @copydoc get */
    template<std::size_t... Elem>
    [[nodiscard]] decltype(auto) get(const entity_type entt) const {
        if constexpr(sizeof...(Elem) == 0) {
            return std::get<0>(pools)->get_as_tuple(entt);
        } else {
            return std::get<Elem...>(pools)->get(entt);
        }
    }

    /**
     * @brief Iterates entities and components and applies the given function
     * object to them.
     *
     * The function object is invoked for each entity. It is provided with the
     * entity itself and a reference to the component if it's a non-empty one.
     * The _constness_ of the component is as requested.<br/>
     * The signature of the function must be equivalent to one of the following
     * forms:
     *
     * @code{.cpp}
     * void(const entity_type, Type &);
     * void(typename Type &);
     * @endcode
     *
     * @note
     * Empty types aren't explicitly instantiated and therefore they are never
     * returned during iterations.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    void each(Func func) const {
        if(view) {
            if constexpr(is_applicable_v<Func, decltype(*each().begin())>) {
                for(const auto pack: each()) {
                    std::apply(func, pack);
                }
            } else if constexpr(Get::traits_type::page_size == 0u) {
                for(size_type pos{}, last = size(); pos < last; ++pos) {
                    func();
                }
            } else {
                for(auto &&component: *std::get<0>(pools)) {
                    func(component);
                }
            }
        }
    }

    /**
     * @brief Returns an iterable object to use to _visit_ a view.
     *
     * The iterable object returns a tuple that contains the current entity and
     * a reference to its component if it's a non-empty one. The _constness_ of
     * the component is as requested.
     *
     * @return An iterable object to use to _visit_ the view.
     */
    [[nodiscard]] iterable each() const noexcept {
        return view ? std::get<0>(pools)->each() : iterable{};
    }

    /**
     * @brief Combines two views in a _more specific_ one (friend function).
     * @tparam OGet Component list of the view to combine with.
     * @tparam OExclude Filter list of the view to combine with.
     * @param other The view to combine with.
     * @return A more specific view.
     */
    template<typename... OGet, typename... OExclude>
    [[nodiscard]] auto operator|(const basic_view<get_t<OGet...>, exclude_t<OExclude...>> &other) const noexcept {
        return internal::view_pack(
            std::tuple_cat(pools, other.pools),
            internal::filter_as_tuple<OExclude...>(other.filter),
            std::index_sequence_for<Get, OGet..., OExclude...>{});
    }

private:
    std::tuple<Get *> pools;
    std::array<const common_type *, 0u> filter;
    const common_type *view;
};

/**
 * @brief Deduction guide.
 * @tparam Type Type of storage classes used to create the view.
 * @param storage The storage for the types to iterate.
 */
template<typename... Type>
basic_view(Type &...storage) -> basic_view<get_t<Type...>, exclude_t<>>;

/**
 * @brief Deduction guide.
 * @tparam Get Types of components iterated by the view.
 * @tparam Exclude Types of components used to filter the view.
 */
template<typename... Get, typename... Exclude>
basic_view(std::tuple<Get &...>, std::tuple<Exclude &...> = {}) -> basic_view<get_t<Get...>, exclude_t<Exclude...>>;

} // namespace entt

#endif

///////////////////// END OF external/entt/entity/view.hpp /////////////////////

////////////////// START OF external/entt/entity/registry.hpp //////////////////

#ifndef ENTT_ENTITY_REGISTRY_HPP
#define ENTT_ENTITY_REGISTRY_HPP

#include <algorithm>
#include <cstddef>
#include <functional>
#include <iterator>
#include <memory>
#include <tuple>
#include <type_traits>
#include <utility>
#include <vector>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename It>
class registry_storage_iterator final {
    template<typename Other>
    friend class registry_storage_iterator;

    using mapped_type = std::remove_reference_t<decltype(std::declval<It>()->second)>;

public:
    using value_type = std::pair<id_type, constness_as_t<typename mapped_type::element_type, mapped_type> &>;
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::input_iterator_tag;

    constexpr registry_storage_iterator() noexcept
        : it{} {}

    constexpr registry_storage_iterator(It iter) noexcept
        : it{iter} {}

    template<typename Other, typename = std::enable_if_t<!std::is_same_v<It, Other> && std::is_constructible_v<It, Other>>>
    constexpr registry_storage_iterator(const registry_storage_iterator<Other> &other) noexcept
        : registry_storage_iterator{other.it} {}

    constexpr registry_storage_iterator &operator++() noexcept {
        return ++it, *this;
    }

    constexpr registry_storage_iterator operator++(int) noexcept {
        registry_storage_iterator orig = *this;
        return ++(*this), orig;
    }

    constexpr registry_storage_iterator &operator--() noexcept {
        return --it, *this;
    }

    constexpr registry_storage_iterator operator--(int) noexcept {
        registry_storage_iterator orig = *this;
        return operator--(), orig;
    }

    constexpr registry_storage_iterator &operator+=(const difference_type value) noexcept {
        it += value;
        return *this;
    }

    constexpr registry_storage_iterator operator+(const difference_type value) const noexcept {
        registry_storage_iterator copy = *this;
        return (copy += value);
    }

    constexpr registry_storage_iterator &operator-=(const difference_type value) noexcept {
        return (*this += -value);
    }

    constexpr registry_storage_iterator operator-(const difference_type value) const noexcept {
        return (*this + -value);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
        return {it[value].first, *it[value].second};
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return {it->first, *it->second};
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return operator*();
    }

    template<typename Lhs, typename Rhs>
    friend constexpr std::ptrdiff_t operator-(const registry_storage_iterator<Lhs> &, const registry_storage_iterator<Rhs> &) noexcept;

    template<typename Lhs, typename Rhs>
    friend constexpr bool operator==(const registry_storage_iterator<Lhs> &, const registry_storage_iterator<Rhs> &) noexcept;

    template<typename Lhs, typename Rhs>
    friend constexpr bool operator<(const registry_storage_iterator<Lhs> &, const registry_storage_iterator<Rhs> &) noexcept;

private:
    It it;
};

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr std::ptrdiff_t operator-(const registry_storage_iterator<Lhs> &lhs, const registry_storage_iterator<Rhs> &rhs) noexcept {
    return lhs.it - rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator==(const registry_storage_iterator<Lhs> &lhs, const registry_storage_iterator<Rhs> &rhs) noexcept {
    return lhs.it == rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator!=(const registry_storage_iterator<Lhs> &lhs, const registry_storage_iterator<Rhs> &rhs) noexcept {
    return !(lhs == rhs);
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator<(const registry_storage_iterator<Lhs> &lhs, const registry_storage_iterator<Rhs> &rhs) noexcept {
    return lhs.it < rhs.it;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator>(const registry_storage_iterator<Lhs> &lhs, const registry_storage_iterator<Rhs> &rhs) noexcept {
    return rhs < lhs;
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator<=(const registry_storage_iterator<Lhs> &lhs, const registry_storage_iterator<Rhs> &rhs) noexcept {
    return !(lhs > rhs);
}

template<typename Lhs, typename Rhs>
[[nodiscard]] constexpr bool operator>=(const registry_storage_iterator<Lhs> &lhs, const registry_storage_iterator<Rhs> &rhs) noexcept {
    return !(lhs < rhs);
}

template<typename Allocator>
class registry_context {
    using alloc_traits = std::allocator_traits<Allocator>;
    using allocator_type = typename alloc_traits::template rebind_alloc<std::pair<const id_type, basic_any<0u>>>;

public:
    explicit registry_context(const allocator_type &allocator)
        : ctx{allocator} {}

    template<typename Type, typename... Args>
    Type &emplace_as(const id_type id, Args &&...args) {
        return any_cast<Type &>(ctx.try_emplace(id, std::in_place_type<Type>, std::forward<Args>(args)...).first->second);
    }

    template<typename Type, typename... Args>
    Type &emplace(Args &&...args) {
        return emplace_as<Type>(type_id<Type>().hash(), std::forward<Args>(args)...);
    }

    template<typename Type>
    Type &insert_or_assign(const id_type id, Type &&value) {
        return any_cast<std::remove_cv_t<std::remove_reference_t<Type>> &>(ctx.insert_or_assign(id, std::forward<Type>(value)).first->second);
    }

    template<typename Type>
    Type &insert_or_assign(Type &&value) {
        return insert_or_assign(type_id<Type>().hash(), std::forward<Type>(value));
    }

    template<typename Type>
    bool erase(const id_type id = type_id<Type>().hash()) {
        const auto it = ctx.find(id);
        return it != ctx.end() && it->second.type() == type_id<Type>() ? (ctx.erase(it), true) : false;
    }

    template<typename Type>
    [[nodiscard]] const Type &get(const id_type id = type_id<Type>().hash()) const {
        return any_cast<const Type &>(ctx.at(id));
    }

    template<typename Type>
    [[nodiscard]] Type &get(const id_type id = type_id<Type>().hash()) {
        return any_cast<Type &>(ctx.at(id));
    }

    template<typename Type>
    [[nodiscard]] const Type *find(const id_type id = type_id<Type>().hash()) const {
        const auto it = ctx.find(id);
        return it != ctx.cend() ? any_cast<const Type>(&it->second) : nullptr;
    }

    template<typename Type>
    [[nodiscard]] Type *find(const id_type id = type_id<Type>().hash()) {
        const auto it = ctx.find(id);
        return it != ctx.end() ? any_cast<Type>(&it->second) : nullptr;
    }

    template<typename Type>
    [[nodiscard]] bool contains(const id_type id = type_id<Type>().hash()) const {
        const auto it = ctx.find(id);
        return it != ctx.cend() && it->second.type() == type_id<Type>();
    }

private:
    dense_map<id_type, basic_any<0u>, identity, std::equal_to<id_type>, allocator_type> ctx;
};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Fast and reliable entity-component system.
 * @tparam Entity A valid entity type.
 * @tparam Allocator Type of allocator used to manage memory and elements.
 */
template<typename Entity, typename Allocator>
class basic_registry {
    using base_type = basic_sparse_set<Entity, Allocator>;

    using alloc_traits = std::allocator_traits<Allocator>;
    static_assert(std::is_same_v<typename alloc_traits::value_type, Entity>, "Invalid value type");

    // std::shared_ptr because of its type erased allocator which is useful here
    using pool_container_type = dense_map<id_type, std::shared_ptr<base_type>, identity, std::equal_to<id_type>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, std::shared_ptr<base_type>>>>;
    using group_container_type = dense_map<id_type, std::shared_ptr<internal::group_descriptor>, identity, std::equal_to<id_type>, typename alloc_traits::template rebind_alloc<std::pair<const id_type, std::shared_ptr<internal::group_descriptor>>>>;

    template<typename Type>
    [[nodiscard]] auto &assure([[maybe_unused]] const id_type id = type_hash<Type>::value()) {
        if constexpr(std::is_same_v<Type, entity_type>) {
            return entities;
        } else {
            static_assert(std::is_same_v<Type, std::decay_t<Type>>, "Non-decayed types not allowed");
            auto &cpool = pools[id];

            if(!cpool) {
                using storage_type = storage_for_type<Type>;
                using alloc_type = typename storage_type::allocator_type;

                if constexpr(std::is_same_v<Type, void> && !std::is_constructible_v<alloc_type, allocator_type>) {
                    // std::allocator<void> has no cross constructors (waiting for C++20)
                    cpool = std::allocate_shared<storage_type>(get_allocator(), alloc_type{});
                } else {
                    cpool = std::allocate_shared<storage_type>(get_allocator(), get_allocator());
                }

                cpool->bind(forward_as_any(*this));
            }

            ENTT_ASSERT(cpool->type() == type_id<Type>(), "Unexpected type");
            return static_cast<storage_for_type<Type> &>(*cpool);
        }
    }

    template<typename Type>
    [[nodiscard]] const auto *assure([[maybe_unused]] const id_type id = type_hash<Type>::value()) const {
        if constexpr(std::is_same_v<Type, entity_type>) {
            return &entities;
        } else {
            static_assert(std::is_same_v<Type, std::decay_t<Type>>, "Non-decayed types not allowed");

            if(const auto it = pools.find(id); it != pools.cend()) {
                ENTT_ASSERT(it->second->type() == type_id<Type>(), "Unexpected type");
                return static_cast<const storage_for_type<Type> *>(it->second.get());
            }

            return static_cast<const storage_for_type<Type> *>(nullptr);
        }
    }

    void rebind() {
        entities.bind(forward_as_any(*this));

        for(auto &&curr: pools) {
            curr.second->bind(forward_as_any(*this));
        }
    }

public:
    /*! @brief Entity traits. */
    using traits_type = typename base_type::traits_type;
    /*! @brief Allocator type. */
    using allocator_type = Allocator;
    /*! @brief Underlying entity identifier. */
    using entity_type = typename traits_type::value_type;
    /*! @brief Underlying version type. */
    using version_type = typename traits_type::version_type;
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Common type among all storage types. */
    using common_type = base_type;
    /*! @brief Context type. */
    using context = internal::registry_context<allocator_type>;

    /**
     * @copybrief storage_for
     * @tparam Type Storage value type, eventually const.
     */
    template<typename Type>
    using storage_for_type = typename storage_for<Type, Entity, typename alloc_traits::template rebind_alloc<std::remove_const_t<Type>>>::type;

    /*! @brief Default constructor. */
    basic_registry()
        : basic_registry{allocator_type{}} {}

    /**
     * @brief Constructs an empty registry with a given allocator.
     * @param allocator The allocator to use.
     */
    explicit basic_registry(const allocator_type &allocator)
        : basic_registry{0u, allocator} {}

    /**
     * @brief Allocates enough memory upon construction to store `count` pools.
     * @param count The number of pools to allocate memory for.
     * @param allocator The allocator to use.
     */
    basic_registry(const size_type count, const allocator_type &allocator = allocator_type{})
        : vars{allocator},
          pools{allocator},
          groups{allocator},
          entities{allocator} {
        pools.reserve(count);
        rebind();
    }

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    basic_registry(basic_registry &&other) noexcept
        : vars{std::move(other.vars)},
          pools{std::move(other.pools)},
          groups{std::move(other.groups)},
          entities{std::move(other.entities)} {
        rebind();
    }

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This registry.
     */
    basic_registry &operator=(basic_registry &&other) noexcept {
        vars = std::move(other.vars);
        pools = std::move(other.pools);
        groups = std::move(other.groups);
        entities = std::move(other.entities);

        rebind();

        return *this;
    }

    /**
     * @brief Exchanges the contents with those of a given registry.
     * @param other Registry to exchange the content with.
     */
    void swap(basic_registry &other) {
        using std::swap;

        swap(vars, other.vars);
        swap(pools, other.pools);
        swap(groups, other.groups);
        swap(entities, other.entities);

        rebind();
        other.rebind();
    }

    /**
     * @brief Returns the associated allocator.
     * @return The associated allocator.
     */
    [[nodiscard]] constexpr allocator_type get_allocator() const noexcept {
        return pools.get_allocator();
    }

    /**
     * @brief Returns an iterable object to use to _visit_ a registry.
     *
     * The iterable object returns a pair that contains the name and a reference
     * to the current storage.
     *
     * @return An iterable object to use to _visit_ the registry.
     */
    [[nodiscard]] auto storage() noexcept {
        return iterable_adaptor{internal::registry_storage_iterator{pools.begin()}, internal::registry_storage_iterator{pools.end()}};
    }

    /*! @copydoc storage */
    [[nodiscard]] auto storage() const noexcept {
        return iterable_adaptor{internal::registry_storage_iterator{pools.cbegin()}, internal::registry_storage_iterator{pools.cend()}};
    }

    /**
     * @brief Finds the storage associated with a given name, if any.
     * @param id Name used to map the storage within the registry.
     * @return A pointer to the storage if it exists, a null pointer otherwise.
     */
    [[nodiscard]] common_type *storage(const id_type id) {
        return const_cast<common_type *>(std::as_const(*this).storage(id));
    }

    /**
     * @brief Finds the storage associated with a given name, if any.
     * @param id Name used to map the storage within the registry.
     * @return A pointer to the storage if it exists, a null pointer otherwise.
     */
    [[nodiscard]] const common_type *storage(const id_type id) const {
        const auto it = pools.find(id);
        return it == pools.cend() ? nullptr : it->second.get();
    }

    /**
     * @brief Returns the storage for a given component type.
     * @tparam Type Type of component of which to return the storage.
     * @param id Optional name used to map the storage within the registry.
     * @return The storage for the given component type.
     */
    template<typename Type>
    storage_for_type<Type> &storage(const id_type id = type_hash<Type>::value()) {
        return assure<Type>(id);
    }

    /**
     * @brief Returns the storage for a given component type, if any.
     * @tparam Type Type of component of which to return the storage.
     * @param id Optional name used to map the storage within the registry.
     * @return The storage for the given component type.
     */
    template<typename Type>
    const storage_for_type<Type> *storage(const id_type id = type_hash<Type>::value()) const {
        return assure<Type>(id);
    }

    /**
     * @brief Returns the number of entities created so far.
     * @return Number of entities created so far.
     */
    [[deprecated("use .storage<Entity>().size() instead")]] [[nodiscard]] size_type size() const noexcept {
        return entities.size();
    }

    /**
     * @brief Returns the number of entities still in use.
     * @return Number of entities still in use.
     */
    [[deprecated("use .storage<Entity>().in_use() instead")]] [[nodiscard]] size_type alive() const {
        return entities.in_use();
    }

    /**
     * @brief Increases the capacity (number of entities) of the registry.
     * @param cap Desired capacity.
     */
    [[deprecated("use .storage<Entity>().reserve(cap) instead")]] void reserve(const size_type cap) {
        entities.reserve(cap);
    }

    /**
     * @brief Returns the number of entities that a registry has currently
     * allocated space for.
     * @return Capacity of the registry.
     */
    [[deprecated("use .storage<Entity>().capacity() instead")]] [[nodiscard]] size_type capacity() const noexcept {
        return entities.capacity();
    }

    /**
     * @brief Checks whether the registry is empty (no entities still in use).
     * @return True if the registry is empty, false otherwise.
     */
    [[deprecated("use .storage<Entity>().in_use() instead")]] [[nodiscard]] bool empty() const {
        return !alive();
    }

    /**
     * @brief Direct access to the list of entities of a registry.
     *
     * The returned pointer is such that range `[data(), data() + size())` is
     * always a valid range, even if the registry is empty.
     *
     * @warning
     * This list contains both valid and destroyed entities and isn't suitable
     * for direct use.
     *
     * @return A pointer to the array of entities.
     */
    [[deprecated("use .storage<Entity>().data() instead")]] [[nodiscard]] const entity_type *data() const noexcept {
        return entities.data();
    }

    /**
     * @brief Returns the number of released entities.
     * @return The number of released entities.
     */
    [[deprecated("use .storage<Entity>().size() and .storage<Entity>().in_use() instead")]] [[nodiscard]] size_type released() const noexcept {
        return (entities.size() - entities.in_use());
    }

    /**
     * @brief Checks if an identifier refers to a valid entity.
     * @param entt An identifier, either valid or not.
     * @return True if the identifier is valid, false otherwise.
     */
    [[nodiscard]] bool valid(const entity_type entt) const {
        return entities.contains(entt) && (entities.index(entt) < entities.in_use());
    }

    /**
     * @brief Returns the actual version for an identifier.
     * @param entt A valid identifier.
     * @return The version for the given identifier if valid, the tombstone
     * version otherwise.
     */
    [[nodiscard]] version_type current(const entity_type entt) const {
        return entities.current(entt);
    }

    /**
     * @brief Creates a new entity or recycles a destroyed one.
     * @return A valid identifier.
     */
    [[nodiscard]] entity_type create() {
        return entities.emplace();
    }

    /**
     * @copybrief create
     *
     * If the requested entity isn't in use, the suggested identifier is used.
     * Otherwise, a new identifier is generated.
     *
     * @param hint Required identifier.
     * @return A valid identifier.
     */
    [[nodiscard]] entity_type create(const entity_type hint) {
        return entities.emplace(hint);
    }

    /**
     * @brief Assigns each element in a range an identifier.
     *
     * @sa create
     *
     * @tparam It Type of forward iterator.
     * @param first An iterator to the first element of the range to generate.
     * @param last An iterator past the last element of the range to generate.
     */
    template<typename It>
    void create(It first, It last) {
        entities.insert(std::move(first), std::move(last));
    }

    /**
     * @brief Assigns identifiers to an empty registry.
     *
     * This function is intended for use in conjunction with `data`, `size` and
     * `released`.<br/>
     * Don't try to inject ranges of randomly generated entities nor the _wrong_
     * head for the list of destroyed entities. There is no guarantee that a
     * registry will continue to work properly in this case.
     *
     * @warning
     * There must be no entities still alive for this to work properly.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param destroyed The number of released entities.
     */
    template<typename It>
    [[deprecated("use .storage<Entity>().push(first, last) and .storage<Entity>().in_use(len) instead")]] void assign(It first, It last, const size_type destroyed) {
        ENTT_ASSERT(!entities.in_use(), "Non-empty registry");
        entities.push(first, last);
        entities.in_use(entities.size() - destroyed);
    }

    /**
     * @brief Releases an identifier.
     *
     * The version is updated and the identifier can be recycled at any time.
     *
     * @param entt A valid identifier.
     * @return The version of the recycled entity.
     */
    [[deprecated("use .orphan(entt) and .storage<Entity>().erase(entt) instead")]] version_type release(const entity_type entt) {
        ENTT_ASSERT(orphan(entt), "Non-orphan entity");
        entities.erase(entt);
        return entities.current(entt);
    }

    /**
     * @brief Releases an identifier.
     *
     * The suggested version or the valid version closest to the suggested one
     * is used instead of the implicitly generated version.
     *
     * @param entt A valid identifier.
     * @param version A desired version upon destruction.
     * @return The version actually assigned to the entity.
     */
    [[deprecated("use .orphan(entt), then .storage<Entity>().erase(entt)/.bump(next) instead")]] version_type release(const entity_type entt, const version_type version) {
        ENTT_ASSERT(orphan(entt), "Non-orphan entity");
        entities.erase(entt);
        const auto elem = traits_type::construct(traits_type::to_entity(entt), version);
        return entities.bump((elem == tombstone) ? traits_type::next(elem) : elem);
    }

    /**
     * @brief Releases all identifiers in a range.
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename It>
    [[deprecated("use .orphan(entt) and .storage<Entity>().erase(first, last) instead")]] void release(It first, It last) {
        ENTT_ASSERT(std::all_of(first, last, [this](const auto entt) { return orphan(entt); }), "Non-orphan entity");
        entities.erase(std::move(first), std::move(last));
    }

    /**
     * @brief Destroys an entity and releases its identifier.
     *
     * @warning
     * Adding or removing components to an entity that is being destroyed can
     * result in undefined behavior.
     *
     * @param entt A valid identifier.
     * @return The version of the recycled entity.
     */
    version_type destroy(const entity_type entt) {
        for(size_type pos = pools.size(); pos; --pos) {
            pools.begin()[pos - 1u].second->remove(entt);
        }

        entities.erase(entt);
        return entities.current(entt);
    }

    /**
     * @brief Destroys an entity and releases its identifier.
     *
     * The suggested version or the valid version closest to the suggested one
     * is used instead of the implicitly generated version.
     *
     * @sa destroy
     *
     * @param entt A valid identifier.
     * @param version A desired version upon destruction.
     * @return The version actually assigned to the entity.
     */
    version_type destroy(const entity_type entt, const version_type version) {
        destroy(entt);
        const auto elem = traits_type::construct(traits_type::to_entity(entt), version);
        return entities.bump((elem == tombstone) ? traits_type::next(elem) : elem);
    }

    /**
     * @brief Destroys all entities in a range and releases their identifiers.
     *
     * @sa destroy
     *
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename It>
    void destroy(It first, It last) {
        const auto from = entities.each().cbegin().base();
        const auto to = from + entities.pack(first, last);

        for(size_type pos = pools.size(); pos; --pos) {
            pools.begin()[pos - 1u].second->remove(from, to);
        }

        entities.erase(from, to);
    }

    /**
     * @brief Assigns the given component to an entity.
     *
     * The component must have a proper constructor or be of aggregate type.
     *
     * @warning
     * Attempting to assign a component to an entity that already owns it
     * results in undefined behavior.
     *
     * @tparam Type Type of component to create.
     * @tparam Args Types of arguments to use to construct the component.
     * @param entt A valid identifier.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the newly created component.
     */
    template<typename Type, typename... Args>
    decltype(auto) emplace(const entity_type entt, Args &&...args) {
        return assure<Type>().emplace(entt, std::forward<Args>(args)...);
    }

    /**
     * @brief Assigns each entity in a range the given component.
     *
     * @sa emplace
     *
     * @tparam Type Type of component to create.
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param value An instance of the component to assign.
     */
    template<typename Type, typename It>
    void insert(It first, It last, const Type &value = {}) {
        assure<Type>().insert(std::move(first), std::move(last), value);
    }

    /**
     * @brief Assigns each entity in a range the given components.
     *
     * @sa emplace
     *
     * @tparam Type Type of component to create.
     * @tparam EIt Type of input iterator.
     * @tparam CIt Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @param from An iterator to the first element of the range of components.
     */
    template<typename Type, typename EIt, typename CIt, typename = std::enable_if_t<std::is_same_v<typename std::iterator_traits<CIt>::value_type, Type>>>
    void insert(EIt first, EIt last, CIt from) {
        assure<Type>().insert(first, last, from);
    }

    /**
     * @brief Assigns or replaces the given component for an entity.
     *
     * @sa emplace
     * @sa replace
     *
     * @tparam Type Type of component to assign or replace.
     * @tparam Args Types of arguments to use to construct the component.
     * @param entt A valid identifier.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the newly created component.
     */
    template<typename Type, typename... Args>
    decltype(auto) emplace_or_replace(const entity_type entt, Args &&...args) {
        if(auto &cpool = assure<Type>(); cpool.contains(entt)) {
            return cpool.patch(entt, [&args...](auto &...curr) { ((curr = Type{std::forward<Args>(args)...}), ...); });
        } else {
            return cpool.emplace(entt, std::forward<Args>(args)...);
        }
    }

    /**
     * @brief Patches the given component for an entity.
     *
     * The signature of the function should be equivalent to the following:
     *
     * @code{.cpp}
     * void(Type &);
     * @endcode
     *
     * @warning
     * Attempting to patch a component of an entity that doesn't own it
     * results in undefined behavior.
     *
     * @tparam Type Type of component to patch.
     * @tparam Func Types of the function objects to invoke.
     * @param entt A valid identifier.
     * @param func Valid function objects.
     * @return A reference to the patched component.
     */
    template<typename Type, typename... Func>
    decltype(auto) patch(const entity_type entt, Func &&...func) {
        return assure<Type>().patch(entt, std::forward<Func>(func)...);
    }

    /**
     * @brief Replaces the given component for an entity.
     *
     * The component must have a proper constructor or be of aggregate type.
     *
     * @warning
     * Attempting to replace a component of an entity that doesn't own it
     * results in undefined behavior.
     *
     * @tparam Type Type of component to replace.
     * @tparam Args Types of arguments to use to construct the component.
     * @param entt A valid identifier.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the component being replaced.
     */
    template<typename Type, typename... Args>
    decltype(auto) replace(const entity_type entt, Args &&...args) {
        return patch<Type>(entt, [&args...](auto &...curr) { ((curr = Type{std::forward<Args>(args)...}), ...); });
    }

    /**
     * @brief Removes the given components from an entity.
     * @tparam Type Type of component to remove.
     * @tparam Other Other types of components to remove.
     * @param entt A valid identifier.
     * @return The number of components actually removed.
     */
    template<typename Type, typename... Other>
    size_type remove(const entity_type entt) {
        return (assure<Type>().remove(entt) + ... + assure<Other>().remove(entt));
    }

    /**
     * @brief Removes the given components from all the entities in a range.
     *
     * @sa remove
     *
     * @tparam Type Type of component to remove.
     * @tparam Other Other types of components to remove.
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     * @return The number of components actually removed.
     */
    template<typename Type, typename... Other, typename It>
    size_type remove(It first, It last) {
        size_type count{};

        if constexpr(std::is_same_v<It, typename common_type::iterator>) {
            common_type *cpools[sizeof...(Other) + 1u]{&assure<Type>(), &assure<Other>()...};

            for(size_type pos{}, len = sizeof...(Other) + 1u; pos < len; ++pos) {
                if constexpr(sizeof...(Other) != 0u) {
                    if(cpools[pos]->data() == first.data()) {
                        std::swap(cpools[pos], cpools[sizeof...(Other)]);
                    }
                }

                count += cpools[pos]->remove(first, last);
            }
        } else {
            for(auto cpools = std::forward_as_tuple(assure<Type>(), assure<Other>()...); first != last; ++first) {
                count += std::apply([entt = *first](auto &...curr) { return (curr.remove(entt) + ... + 0u); }, cpools);
            }
        }

        return count;
    }

    /**
     * @brief Erases the given components from an entity.
     *
     * @warning
     * Attempting to erase a component from an entity that doesn't own it
     * results in undefined behavior.
     *
     * @tparam Type Types of components to erase.
     * @tparam Other Other types of components to erase.
     * @param entt A valid identifier.
     */
    template<typename Type, typename... Other>
    void erase(const entity_type entt) {
        (assure<Type>().erase(entt), (assure<Other>().erase(entt), ...));
    }

    /**
     * @brief Erases the given components from all the entities in a range.
     *
     * @sa erase
     *
     * @tparam Type Types of components to erase.
     * @tparam Other Other types of components to erase.
     * @tparam It Type of input iterator.
     * @param first An iterator to the first element of the range of entities.
     * @param last An iterator past the last element of the range of entities.
     */
    template<typename Type, typename... Other, typename It>
    void erase(It first, It last) {
        if constexpr(std::is_same_v<It, typename common_type::iterator>) {
            common_type *cpools[sizeof...(Other) + 1u]{&assure<Type>(), &assure<Other>()...};

            for(size_type pos{}, len = sizeof...(Other) + 1u; pos < len; ++pos) {
                if constexpr(sizeof...(Other) != 0u) {
                    if(cpools[pos]->data() == first.data()) {
                        std::swap(cpools[pos], cpools[sizeof...(Other)]);
                    }
                }

                cpools[pos]->erase(first, last);
            }
        } else {
            for(auto cpools = std::forward_as_tuple(assure<Type>(), assure<Other>()...); first != last; ++first) {
                std::apply([entt = *first](auto &...curr) { (curr.erase(entt), ...); }, cpools);
            }
        }
    }

    /**
     * @brief Erases components satisfying specific criteria from an entity.
     *
     * The function type is equivalent to:
     *
     * @code{.cpp}
     * void(const id_type, typename basic_registry<Entity>::base_type &);
     * @endcode
     *
     * Only storage where the entity exists are passed to the function.
     *
     * @tparam Func Type of the function object to invoke.
     * @param entt A valid identifier.
     * @param func A valid function object.
     */
    template<typename Func>
    void erase_if(const entity_type entt, Func func) {
        for(auto [id, cpool]: storage()) {
            if(cpool.contains(entt) && func(id, std::as_const(cpool))) {
                cpool.erase(entt);
            }
        }
    }

    /**
     * @brief Removes all tombstones from a registry or only the pools for the
     * given components.
     * @tparam Type Types of components for which to clear all tombstones.
     */
    template<typename... Type>
    void compact() {
        if constexpr(sizeof...(Type) == 0u) {
            for(auto &&curr: pools) {
                curr.second->compact();
            }
        } else {
            (assure<Type>().compact(), ...);
        }
    }

    /**
     * @brief Check if an entity is part of all the given storage.
     * @tparam Type Type of storage to check for.
     * @param entt A valid identifier.
     * @return True if the entity is part of all the storage, false otherwise.
     */
    template<typename... Type>
    [[nodiscard]] bool all_of(const entity_type entt) const {
        if constexpr(sizeof...(Type) == 1u) {
            auto *cpool = assure<std::remove_const_t<Type>...>();
            return cpool && cpool->contains(entt);
        } else {
            return (all_of<Type>(entt) && ...);
        }
    }

    /**
     * @brief Check if an entity is part of at least one given storage.
     * @tparam Type Type of storage to check for.
     * @param entt A valid identifier.
     * @return True if the entity is part of at least one storage, false
     * otherwise.
     */
    template<typename... Type>
    [[nodiscard]] bool any_of(const entity_type entt) const {
        return (all_of<Type>(entt) || ...);
    }

    /**
     * @brief Returns references to the given components for an entity.
     *
     * @warning
     * Attempting to get a component from an entity that doesn't own it results
     * in undefined behavior.
     *
     * @tparam Type Types of components to get.
     * @param entt A valid identifier.
     * @return References to the components owned by the entity.
     */
    template<typename... Type>
    [[nodiscard]] decltype(auto) get([[maybe_unused]] const entity_type entt) const {
        if constexpr(sizeof...(Type) == 1u) {
            return (assure<std::remove_const_t<Type>>()->get(entt), ...);
        } else {
            return std::forward_as_tuple(get<Type>(entt)...);
        }
    }

    /*! @copydoc get */
    template<typename... Type>
    [[nodiscard]] decltype(auto) get([[maybe_unused]] const entity_type entt) {
        if constexpr(sizeof...(Type) == 1u) {
            return (static_cast<storage_for_type<Type> &>(assure<std::remove_const_t<Type>>()).get(entt), ...);
        } else {
            return std::forward_as_tuple(get<Type>(entt)...);
        }
    }

    /**
     * @brief Returns a reference to the given component for an entity.
     *
     * In case the entity doesn't own the component, the parameters provided are
     * used to construct it.
     *
     * @sa get
     * @sa emplace
     *
     * @tparam Type Type of component to get.
     * @tparam Args Types of arguments to use to construct the component.
     * @param entt A valid identifier.
     * @param args Parameters to use to initialize the component.
     * @return Reference to the component owned by the entity.
     */
    template<typename Type, typename... Args>
    [[nodiscard]] decltype(auto) get_or_emplace(const entity_type entt, Args &&...args) {
        if(auto &cpool = assure<Type>(); cpool.contains(entt)) {
            return cpool.get(entt);
        } else {
            return cpool.emplace(entt, std::forward<Args>(args)...);
        }
    }

    /**
     * @brief Returns pointers to the given components for an entity.
     *
     * @note
     * The registry retains ownership of the pointed-to components.
     *
     * @tparam Type Types of components to get.
     * @param entt A valid identifier.
     * @return Pointers to the components owned by the entity.
     */
    template<typename... Type>
    [[nodiscard]] auto try_get([[maybe_unused]] const entity_type entt) const {
        if constexpr(sizeof...(Type) == 1u) {
            const auto *cpool = assure<std::remove_const_t<Type>...>();
            return (cpool && cpool->contains(entt)) ? std::addressof(cpool->get(entt)) : nullptr;
        } else {
            return std::make_tuple(try_get<Type>(entt)...);
        }
    }

    /*! @copydoc try_get */
    template<typename... Type>
    [[nodiscard]] auto try_get([[maybe_unused]] const entity_type entt) {
        if constexpr(sizeof...(Type) == 1u) {
            auto &cpool = assure<std::remove_const_t<Type>...>();
            return (static_cast<Type *>(cpool.contains(entt) ? std::addressof(cpool.get(entt)) : nullptr), ...);
        } else {
            return std::make_tuple(try_get<Type>(entt)...);
        }
    }

    /**
     * @brief Clears a whole registry or the pools for the given components.
     * @tparam Type Types of components to remove from their entities.
     */
    template<typename... Type>
    void clear() {
        if constexpr(sizeof...(Type) == 0u) {
            for(size_type pos = pools.size(); pos; --pos) {
                pools.begin()[pos - 1u].second->clear();
            }

            const auto iterable = entities.each();
            entities.erase(iterable.begin().base(), iterable.end().base());
        } else {
            (assure<Type>().clear(), ...);
        }
    }

    /**
     * @brief Iterates all the entities that are still in use.
     *
     * The signature of the function should be equivalent to the following:
     *
     * @code{.cpp}
     * void(const Entity);
     * @endcode
     *
     * It's not defined whether entities created during iteration are returned.
     *
     * @tparam Func Type of the function object to invoke.
     * @param func A valid function object.
     */
    template<typename Func>
    [[deprecated("use .storage<Entity>().each() instead")]] void each(Func func) const {
        for(auto [entt]: entities.each()) {
            func(entt);
        }
    }

    /**
     * @brief Checks if an entity has components assigned.
     * @param entt A valid identifier.
     * @return True if the entity has no components assigned, false otherwise.
     */
    [[nodiscard]] bool orphan(const entity_type entt) const {
        return std::none_of(pools.cbegin(), pools.cend(), [entt](auto &&curr) { return curr.second->contains(entt); });
    }

    /**
     * @brief Returns a sink object for the given component.
     *
     * Use this function to receive notifications whenever a new instance of the
     * given component is created and assigned to an entity.<br/>
     * The function type for a listener is equivalent to:
     *
     * @code{.cpp}
     * void(basic_registry<Entity> &, Entity);
     * @endcode
     *
     * Listeners are invoked **after** assigning the component to the entity.
     *
     * @sa sink
     *
     * @tparam Type Type of component of which to get the sink.
     * @param id Optional name used to map the storage within the registry.
     * @return A temporary sink object.
     */
    template<typename Type>
    [[nodiscard]] auto on_construct(const id_type id = type_hash<Type>::value()) {
        return assure<Type>(id).on_construct();
    }

    /**
     * @brief Returns a sink object for the given component.
     *
     * Use this function to receive notifications whenever an instance of the
     * given component is explicitly updated.<br/>
     * The function type for a listener is equivalent to:
     *
     * @code{.cpp}
     * void(basic_registry<Entity> &, Entity);
     * @endcode
     *
     * Listeners are invoked **after** updating the component.
     *
     * @sa sink
     *
     * @tparam Type Type of component of which to get the sink.
     * @param id Optional name used to map the storage within the registry.
     * @return A temporary sink object.
     */
    template<typename Type>
    [[nodiscard]] auto on_update(const id_type id = type_hash<Type>::value()) {
        return assure<Type>(id).on_update();
    }

    /**
     * @brief Returns a sink object for the given component.
     *
     * Use this function to receive notifications whenever an instance of the
     * given component is removed from an entity and thus destroyed.<br/>
     * The function type for a listener is equivalent to:
     *
     * @code{.cpp}
     * void(basic_registry<Entity> &, Entity);
     * @endcode
     *
     * Listeners are invoked **before** removing the component from the entity.
     *
     * @sa sink
     *
     * @tparam Type Type of component of which to get the sink.
     * @param id Optional name used to map the storage within the registry.
     * @return A temporary sink object.
     */
    template<typename Type>
    [[nodiscard]] auto on_destroy(const id_type id = type_hash<Type>::value()) {
        return assure<Type>(id).on_destroy();
    }

    /**
     * @brief Returns a view for the given components.
     * @tparam Type Type of component used to construct the view.
     * @tparam Other Other types of components used to construct the view.
     * @tparam Exclude Types of components used to filter the view.
     * @return A newly created view.
     */
    template<typename Type, typename... Other, typename... Exclude>
    [[nodiscard]] basic_view<get_t<storage_for_type<const Type>, storage_for_type<const Other>...>, exclude_t<storage_for_type<const Exclude>...>>
    view(exclude_t<Exclude...> = exclude_t{}) const {
        const auto cpools = std::make_tuple(assure<std::remove_const_t<Type>>(), assure<std::remove_const_t<Other>>()..., assure<std::remove_const_t<Exclude>>()...);
        basic_view<get_t<storage_for_type<const Type>, storage_for_type<const Other>...>, exclude_t<storage_for_type<const Exclude>...>> elem{};
        std::apply([&elem](const auto *...curr) { ((curr ? elem.storage(*curr) : void()), ...); }, cpools);
        return elem;
    }

    /*! @copydoc view */
    template<typename Type, typename... Other, typename... Exclude>
    [[nodiscard]] basic_view<get_t<storage_for_type<Type>, storage_for_type<Other>...>, exclude_t<storage_for_type<Exclude>...>>
    view(exclude_t<Exclude...> = exclude_t{}) {
        return {assure<std::remove_const_t<Type>>(), assure<std::remove_const_t<Other>>()..., assure<std::remove_const_t<Exclude>>()...};
    }

    /**
     * @brief Returns a group for the given components.
     * @tparam Owned Types of storage _owned_ by the group.
     * @tparam Get Types of storage _observed_ by the group, if any.
     * @tparam Exclude Types of storage used to filter the group, if any.
     * @return A newly created group.
     */
    template<typename... Owned, typename... Get, typename... Exclude>
    basic_group<owned_t<storage_for_type<Owned>...>, get_t<storage_for_type<Get>...>, exclude_t<storage_for_type<Exclude>...>>
    group(get_t<Get...> = get_t{}, exclude_t<Exclude...> = exclude_t{}) {
        using handler_type = typename basic_group<owned_t<storage_for_type<Owned>...>, get_t<storage_for_type<Get>...>, exclude_t<storage_for_type<Exclude>...>>::handler;

        if(auto it = groups.find(type_hash<handler_type>::value()); it != groups.cend()) {
            return {*std::static_pointer_cast<handler_type>(it->second)};
        }

        std::shared_ptr<handler_type> handler{};

        if constexpr(sizeof...(Owned) == 0u) {
            handler = std::allocate_shared<handler_type>(get_allocator(), get_allocator(), assure<std::remove_const_t<Get>>()..., assure<std::remove_const_t<Exclude>>()...);
        } else {
            handler = std::allocate_shared<handler_type>(get_allocator(), assure<std::remove_const_t<Owned>>()..., assure<std::remove_const_t<Get>>()..., assure<std::remove_const_t<Exclude>>()...);
            [[maybe_unused]] const id_type elem[]{type_hash<std::remove_const_t<Owned>>::value()..., type_hash<std::remove_const_t<Get>>::value()..., type_hash<std::remove_const_t<Exclude>>::value()...};
            ENTT_ASSERT(std::all_of(groups.cbegin(), groups.cend(), [&elem](const auto &data) { return data.second->owned(elem, sizeof...(Owned)) == 0u; }), "Conflicting groups");
        }

        groups.emplace(type_hash<handler_type>::value(), handler);
        return {*handler};
    }

    /*! @copydoc group */
    template<typename... Owned, typename... Get, typename... Exclude>
    basic_group<owned_t<storage_for_type<const Owned>...>, get_t<storage_for_type<const Get>...>, exclude_t<storage_for_type<const Exclude>...>>
    group_if_exists(get_t<Get...> = get_t{}, exclude_t<Exclude...> = exclude_t{}) const {
        using handler_type = typename basic_group<owned_t<storage_for_type<const Owned>...>, get_t<storage_for_type<const Get>...>, exclude_t<storage_for_type<const Exclude>...>>::handler;

        if(auto it = groups.find(type_hash<handler_type>::value()); it != groups.cend()) {
            return {*std::static_pointer_cast<handler_type>(it->second)};
        }

        return {};
    }

    /**
     * @brief Checks whether the given components belong to any group.
     * @tparam Type Type of component in which one is interested.
     * @tparam Other Other types of components in which one is interested.
     * @return True if the pools of the given components are _free_, false
     * otherwise.
     */
    template<typename Type, typename... Other>
    [[nodiscard]] bool owned() const {
        const id_type elem[]{type_hash<std::remove_const_t<Type>>::value(), type_hash<std::remove_const_t<Other>>::value()...};
        return std::any_of(groups.cbegin(), groups.cend(), [&elem](auto &&data) { return data.second->owned(elem, 1u + sizeof...(Other)); });
    }

    /**
     * @brief Sorts the elements of a given component.
     *
     * The comparison function object returns `true` if the first element is
     * _less_ than the second one, `false` otherwise. Its signature is also
     * equivalent to one of the following:
     *
     * @code{.cpp}
     * bool(const Entity, const Entity);
     * bool(const Type &, const Type &);
     * @endcode
     *
     * Moreover, it shall induce a _strict weak ordering_ on the values.<br/>
     * The sort function object offers an `operator()` that accepts:
     *
     * * An iterator to the first element of the range to sort.
     * * An iterator past the last element of the range to sort.
     * * A comparison function object to use to compare the elements.
     *
     * The comparison function object hasn't necessarily the type of the one
     * passed along with the other parameters to this member function.
     *
     * @warning
     * Pools of components owned by a group cannot be sorted.
     *
     * @tparam Type Type of components to sort.
     * @tparam Compare Type of comparison function object.
     * @tparam Sort Type of sort function object.
     * @tparam Args Types of arguments to forward to the sort function object.
     * @param compare A valid comparison function object.
     * @param algo A valid sort function object.
     * @param args Arguments to forward to the sort function object, if any.
     */
    template<typename Type, typename Compare, typename Sort = std_sort, typename... Args>
    void sort(Compare compare, Sort algo = Sort{}, Args &&...args) {
        ENTT_ASSERT(!owned<Type>(), "Cannot sort owned storage");
        auto &cpool = assure<Type>();

        if constexpr(std::is_invocable_v<Compare, decltype(cpool.get({})), decltype(cpool.get({}))>) {
            auto comp = [&cpool, compare = std::move(compare)](const auto lhs, const auto rhs) { return compare(std::as_const(cpool.get(lhs)), std::as_const(cpool.get(rhs))); };
            cpool.sort(std::move(comp), std::move(algo), std::forward<Args>(args)...);
        } else {
            cpool.sort(std::move(compare), std::move(algo), std::forward<Args>(args)...);
        }
    }

    /**
     * @brief Sorts two pools of components in the same way.
     *
     * Entities and components in `To` which are part of both storage are sorted
     * internally with the order they have in `From`. The others follow in no
     * particular order.
     *
     * @warning
     * Pools of components owned by a group cannot be sorted.
     *
     * @tparam To Type of components to sort.
     * @tparam From Type of components to use to sort.
     */
    template<typename To, typename From>
    void sort() {
        ENTT_ASSERT(!owned<To>(), "Cannot sort owned storage");
        assure<To>().sort_as(assure<From>());
    }

    /**
     * @brief Returns the context object, that is, a general purpose container.
     * @return The context object, that is, a general purpose container.
     */
    context &ctx() noexcept {
        return vars;
    }

    /*! @copydoc ctx */
    const context &ctx() const noexcept {
        return vars;
    }

private:
    context vars;
    pool_container_type pools;
    group_container_type groups;
    storage_for_type<entity_type> entities;
};

} // namespace entt

#endif

/////////////////// END OF external/entt/entity/registry.hpp ///////////////////

////////////////// START OF external/entt/locator/locator.hpp //////////////////

#ifndef ENTT_LOCATOR_LOCATOR_HPP
#define ENTT_LOCATOR_LOCATOR_HPP

#include <memory>
#include <utility>

namespace entt {

/**
 * @brief Service locator, nothing more.
 *
 * A service locator is used to do what it promises: locate services.<br/>
 * Usually service locators are tightly bound to the services they expose and
 * thus it's hard to define a general purpose class to do that. This tiny class
 * tries to fill the gap and to get rid of the burden of defining a different
 * specific locator for each application.
 *
 * @note
 * Users shouldn't retain references to a service. The recommended way is to
 * retrieve the service implementation currently set each and every time the
 * need for it arises. The risk is to incur in unexpected behaviors otherwise.
 *
 * @tparam Service Service type.
 */
template<typename Service>
class locator final {
    class service_handle {
        friend class locator<Service>;
        std::shared_ptr<Service> value{};
    };

public:
    /*! @brief Service type. */
    using type = Service;
    /*! @brief Service node type. */
    using node_type = service_handle;

    /*! @brief Default constructor, deleted on purpose. */
    locator() = delete;
    /*! @brief Default destructor, deleted on purpose. */
    ~locator() = delete;

    /**
     * @brief Checks whether a service locator contains a value.
     * @return True if the service locator contains a value, false otherwise.
     */
    [[nodiscard]] static bool has_value() noexcept {
        return (service != nullptr);
    }

    /**
     * @brief Returns a reference to a valid service, if any.
     *
     * @warning
     * Invoking this function can result in undefined behavior if the service
     * hasn't been set yet.
     *
     * @return A reference to the service currently set, if any.
     */
    [[nodiscard]] static Service &value() noexcept {
        ENTT_ASSERT(has_value(), "Service not available");
        return *service;
    }

    /**
     * @brief Returns a service if available or sets it from a fallback type.
     *
     * Arguments are used only if a service doesn't already exist. In all other
     * cases, they are discarded.
     *
     * @tparam Args Types of arguments to use to construct the fallback service.
     * @tparam Type Fallback service type.
     * @param args Parameters to use to construct the fallback service.
     * @return A reference to a valid service.
     */
    template<typename Type = Service, typename... Args>
    [[nodiscard]] static Service &value_or(Args &&...args) {
        return service ? *service : emplace<Type>(std::forward<Args>(args)...);
    }

    /**
     * @brief Sets or replaces a service.
     * @tparam Type Service type.
     * @tparam Args Types of arguments to use to construct the service.
     * @param args Parameters to use to construct the service.
     * @return A reference to a valid service.
     */
    template<typename Type = Service, typename... Args>
    static Service &emplace(Args &&...args) {
        service = std::make_shared<Type>(std::forward<Args>(args)...);
        return *service;
    }

    /**
     * @brief Sets or replaces a service using a given allocator.
     * @tparam Type Service type.
     * @tparam Allocator Type of allocator used to manage memory and elements.
     * @tparam Args Types of arguments to use to construct the service.
     * @param alloc The allocator to use.
     * @param args Parameters to use to construct the service.
     * @return A reference to a valid service.
     */
    template<typename Type = Service, typename Allocator, typename... Args>
    static Service &emplace(std::allocator_arg_t, Allocator alloc, Args &&...args) {
        service = std::allocate_shared<Type>(alloc, std::forward<Args>(args)...);
        return *service;
    }

    /**
     * @brief Returns a handle to the underlying service.
     * @return A handle to the underlying service.
     */
    static node_type handle() noexcept {
        node_type node{};
        node.value = service;
        return node;
    }

    /**
     * @brief Resets or replaces a service.
     * @param other Optional handle with which to replace the service.
     */
    static void reset(const node_type &other = {}) noexcept {
        service = other.value;
    }

    /**
     * @brief Resets or replaces a service.
     * @tparam Type Service type.
     * @tparam Deleter Deleter type.
     * @param elem A pointer to a service to manage.
     * @param deleter A deleter to use to destroy the service.
     */
    template<typename Type, typename Deleter = std::default_delete<Type>>
    static void reset(Type *elem, Deleter deleter = {}) {
        service = std::shared_ptr<Service>{elem, std::move(deleter)};
    }

private:
    // std::shared_ptr because of its type erased allocator which is useful here
    inline static std::shared_ptr<Service> service{};
};

} // namespace entt

#endif

/////////////////// END OF external/entt/locator/locator.hpp ///////////////////

/////////////////// START OF external/entt/meta/context.hpp ////////////////////

#ifndef ENTT_META_CTX_HPP
#define ENTT_META_CTX_HPP


namespace entt {

class meta_ctx;

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

struct meta_type_node;

struct meta_context {
    dense_map<id_type, meta_type_node, identity> value{};

    [[nodiscard]] static inline meta_context &from(meta_ctx &ctx);
    [[nodiscard]] static inline const meta_context &from(const meta_ctx &ctx);
};

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/*! @brief Disambiguation tag for constructors and the like. */
class meta_ctx_arg_t final {};

/*! @brief Constant of type meta_context_arg_t used to disambiguate calls. */
inline constexpr meta_ctx_arg_t meta_ctx_arg{};

/*! @brief Opaque meta context type. */
class meta_ctx: private internal::meta_context {
    /*! @brief Attorney idiom like model to access the base class. */
    friend struct internal::meta_context;
};

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

[[nodiscard]] inline internal::meta_context &internal::meta_context::from(meta_ctx &ctx) {
    return ctx;
}

[[nodiscard]] inline const internal::meta_context &internal::meta_context::from(const meta_ctx &ctx) {
    return ctx;
}

/**
 * Internal details not to be documented.
 * @endcond
 */

} // namespace entt

#endif

//////////////////// END OF external/entt/meta/context.hpp /////////////////////

///////////////// START OF external/entt/meta/adl_pointer.hpp //////////////////

#ifndef ENTT_META_ADL_POINTER_HPP
#define ENTT_META_ADL_POINTER_HPP

namespace entt {

/**
 * @brief ADL based lookup function for dereferencing meta pointer-like types.
 * @tparam Type Element type.
 * @param value A pointer-like object.
 * @return The value returned from the dereferenced pointer.
 */
template<typename Type>
decltype(auto) dereference_meta_pointer_like(const Type &value) {
    return *value;
}

/**
 * @brief Fake ADL based lookup function for meta pointer-like types.
 * @tparam Type Element type.
 */
template<typename Type>
struct adl_meta_pointer_like {
    /**
     * @brief Uses the default ADL based lookup method to resolve the call.
     * @param value A pointer-like object.
     * @return The value returned from the dereferenced pointer.
     */
    static decltype(auto) dereference(const Type &value) {
        return dereference_meta_pointer_like(value);
    }
};

} // namespace entt

#endif

////////////////// END OF external/entt/meta/adl_pointer.hpp ///////////////////

///////////////////// START OF external/entt/meta/fwd.hpp //////////////////////

#ifndef ENTT_META_FWD_HPP
#define ENTT_META_FWD_HPP

namespace entt {

class meta_sequence_container;

class meta_associative_container;

class meta_any;

struct meta_handle;

struct meta_prop;

struct meta_data;

struct meta_func;

class meta_type;

} // namespace entt

#endif

////////////////////// END OF external/entt/meta/fwd.hpp ///////////////////////

///////////////////// START OF external/entt/core/enum.hpp /////////////////////

#ifndef ENTT_CORE_ENUM_HPP
#define ENTT_CORE_ENUM_HPP

#include <type_traits>

namespace entt {

/**
 * @brief Enable bitmask support for enum classes.
 * @tparam Type The enum type for which to enable bitmask support.
 */
template<typename Type, typename = void>
struct enum_as_bitmask: std::false_type {};

/*! @copydoc enum_as_bitmask */
template<typename Type>
struct enum_as_bitmask<Type, std::void_t<decltype(Type::_entt_enum_as_bitmask)>>: std::is_enum<Type> {};

/**
 * @brief Helper variable template.
 * @tparam Type The enum class type for which to enable bitmask support.
 */
template<typename Type>
inline constexpr bool enum_as_bitmask_v = enum_as_bitmask<Type>::value;

} // namespace entt

/**
 * @brief Operator available for enums for which bitmask support is enabled.
 * @tparam Type Enum class type.
 * @param lhs The first value to use.
 * @param rhs The second value to use.
 * @return The result of invoking the operator on the underlying types of the
 * two values provided.
 */
template<typename Type>
[[nodiscard]] constexpr std::enable_if_t<entt::enum_as_bitmask_v<Type>, Type>
operator|(const Type lhs, const Type rhs) noexcept {
    return static_cast<Type>(static_cast<std::underlying_type_t<Type>>(lhs) | static_cast<std::underlying_type_t<Type>>(rhs));
}

/*! @copydoc operator| */
template<typename Type>
[[nodiscard]] constexpr std::enable_if_t<entt::enum_as_bitmask_v<Type>, Type>
operator&(const Type lhs, const Type rhs) noexcept {
    return static_cast<Type>(static_cast<std::underlying_type_t<Type>>(lhs) & static_cast<std::underlying_type_t<Type>>(rhs));
}

/*! @copydoc operator| */
template<typename Type>
[[nodiscard]] constexpr std::enable_if_t<entt::enum_as_bitmask_v<Type>, Type>
operator^(const Type lhs, const Type rhs) noexcept {
    return static_cast<Type>(static_cast<std::underlying_type_t<Type>>(lhs) ^ static_cast<std::underlying_type_t<Type>>(rhs));
}

/**
 * @brief Operator available for enums for which bitmask support is enabled.
 * @tparam Type Enum class type.
 * @param value The value to use.
 * @return The result of invoking the operator on the underlying types of the
 * value provided.
 */
template<typename Type>
[[nodiscard]] constexpr std::enable_if_t<entt::enum_as_bitmask_v<Type>, Type>
operator~(const Type value) noexcept {
    return static_cast<Type>(~static_cast<std::underlying_type_t<Type>>(value));
}

/*! @copydoc operator~ */
template<typename Type>
[[nodiscard]] constexpr std::enable_if_t<entt::enum_as_bitmask_v<Type>, bool>
operator!(const Type value) noexcept {
    return !static_cast<std::underlying_type_t<Type>>(value);
}

/*! @copydoc operator| */
template<typename Type>
constexpr std::enable_if_t<entt::enum_as_bitmask_v<Type>, Type &>
operator|=(Type &lhs, const Type rhs) noexcept {
    return (lhs = (lhs | rhs));
}

/*! @copydoc operator| */
template<typename Type>
constexpr std::enable_if_t<entt::enum_as_bitmask_v<Type>, Type &>
operator&=(Type &lhs, const Type rhs) noexcept {
    return (lhs = (lhs & rhs));
}

/*! @copydoc operator| */
template<typename Type>
constexpr std::enable_if_t<entt::enum_as_bitmask_v<Type>, Type &>
operator^=(Type &lhs, const Type rhs) noexcept {
    return (lhs = (lhs ^ rhs));
}

#endif

////////////////////// END OF external/entt/core/enum.hpp //////////////////////

///////////////// START OF external/entt/meta/type_traits.hpp //////////////////

#ifndef ENTT_META_TYPE_TRAITS_HPP
#define ENTT_META_TYPE_TRAITS_HPP

#include <type_traits>
#include <utility>

namespace entt {

/**
 * @brief Traits class template to be specialized to enable support for meta
 * template information.
 */
template<typename>
struct meta_template_traits;

/**
 * @brief Traits class template to be specialized to enable support for meta
 * sequence containers.
 */
template<typename>
struct meta_sequence_container_traits;

/**
 * @brief Traits class template to be specialized to enable support for meta
 * associative containers.
 */
template<typename>
struct meta_associative_container_traits;

/**
 * @brief Provides the member constant `value` to true if a given type is a
 * pointer-like type from the point of view of the meta system, false otherwise.
 */
template<typename>
struct is_meta_pointer_like: std::false_type {};

/**
 * @brief Partial specialization to ensure that const pointer-like types are
 * also accepted.
 * @tparam Type Potentially pointer-like type.
 */
template<typename Type>
struct is_meta_pointer_like<const Type>: is_meta_pointer_like<Type> {};

/**
 * @brief Helper variable template.
 * @tparam Type Potentially pointer-like type.
 */
template<typename Type>
inline constexpr auto is_meta_pointer_like_v = is_meta_pointer_like<Type>::value;

} // namespace entt

#endif

////////////////// END OF external/entt/meta/type_traits.hpp ///////////////////

///////////////////// START OF external/entt/meta/node.hpp /////////////////////

#ifndef ENTT_META_NODE_HPP
#define ENTT_META_NODE_HPP

#include <cstddef>
#include <memory>
#include <type_traits>
#include <utility>

namespace entt {

class meta_any;
class meta_type;
struct meta_handle;

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

enum class meta_traits : std::uint32_t {
    is_none = 0x0000,
    is_const = 0x0001,
    is_static = 0x0002,
    is_arithmetic = 0x0004,
    is_integral = 0x0008,
    is_signed = 0x0010,
    is_array = 0x0020,
    is_enum = 0x0040,
    is_class = 0x0080,
    is_meta_pointer_like = 0x0100,
    is_meta_sequence_container = 0x0200,
    is_meta_associative_container = 0x0400,
    _entt_enum_as_bitmask
};

struct meta_type_node;

struct meta_prop_node {
    meta_type_node (*type)(const meta_context &) noexcept {};
    std::shared_ptr<void> value{};
};

struct meta_base_node {
    meta_type_node (*type)(const meta_context &) noexcept {};
    const void *(*cast)(const void *) noexcept {};
};

struct meta_conv_node {
    meta_any (*conv)(const meta_ctx &, const void *){};
};

struct meta_ctor_node {
    using size_type = std::size_t;

    size_type arity{0u};
    meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
    meta_any (*invoke)(const meta_ctx &, meta_any *const){};
};

struct meta_dtor_node {
    void (*dtor)(void *){};
};

struct meta_data_node {
    using size_type = std::size_t;

    meta_traits traits{meta_traits::is_none};
    size_type arity{0u};
    meta_type_node (*type)(const meta_context &) noexcept {};
    meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
    bool (*set)(meta_handle, meta_any){};
    meta_any (*get)(const meta_ctx &, meta_handle){};
    dense_map<id_type, meta_prop_node, identity> prop{};
};

struct meta_func_node {
    using size_type = std::size_t;

    meta_traits traits{meta_traits::is_none};
    size_type arity{0u};
    meta_type_node (*ret)(const meta_context &) noexcept {};
    meta_type (*arg)(const meta_ctx &, const size_type) noexcept {};
    meta_any (*invoke)(const meta_ctx &, meta_handle, meta_any *const){};
    std::shared_ptr<meta_func_node> next{};
    dense_map<id_type, meta_prop_node, identity> prop{};
};

struct meta_template_node {
    using size_type = std::size_t;

    size_type arity{0u};
    meta_type_node (*type)(const meta_context &) noexcept {};
    meta_type_node (*arg)(const meta_context &, const size_type) noexcept {};
};

struct meta_type_descriptor {
    dense_map<id_type, meta_ctor_node, identity> ctor{};
    dense_map<id_type, meta_base_node, identity> base{};
    dense_map<id_type, meta_conv_node, identity> conv{};
    dense_map<id_type, meta_data_node, identity> data{};
    dense_map<id_type, meta_func_node, identity> func{};
    dense_map<id_type, meta_prop_node, identity> prop{};
};

struct meta_type_node {
    using size_type = std::size_t;

    const type_info *info{};
    id_type id{};
    meta_traits traits{meta_traits::is_none};
    size_type size_of{0u};
    meta_type_node (*resolve)(const meta_context &) noexcept {};
    meta_type_node (*remove_pointer)(const meta_context &) noexcept {};
    meta_any (*default_constructor)(const meta_ctx &){};
    double (*conversion_helper)(void *, const void *){};
    meta_any (*from_void)(const meta_ctx &, void *, const void *){};
    meta_template_node templ{};
    meta_dtor_node dtor{};
    std::shared_ptr<meta_type_descriptor> details{};
};

template<typename Type>
meta_type_node resolve(const meta_context &) noexcept;

template<typename... Args>
[[nodiscard]] auto meta_arg_node(const meta_context &context, type_list<Args...>, [[maybe_unused]] const std::size_t index) noexcept {
    [[maybe_unused]] std::size_t pos{};
    meta_type_node (*value)(const meta_context &) noexcept = nullptr;
    ((value = (pos++ == index ? &resolve<std::remove_cv_t<std::remove_reference_t<Args>>> : value)), ...);
    ENTT_ASSERT(value != nullptr, "Out of bounds");
    return value(context);
}

[[nodiscard]] inline const void *try_cast(const meta_context &context, const meta_type_node &from, const meta_type_node &to, const void *instance) noexcept {
    if(from.info && to.info && *from.info == *to.info) {
        return instance;
    }

    if(from.details) {
        for(auto &&curr: from.details->base) {
            if(const void *elem = try_cast(context, curr.second.type(context), to, curr.second.cast(instance)); elem) {
                return elem;
            }
        }
    }

    return nullptr;
}

[[nodiscard]] inline const meta_type_node *try_resolve(const meta_context &context, const type_info &info) noexcept {
    const auto it = context.value.find(info.hash());
    return it != context.value.end() ? &it->second : nullptr;
}

template<typename Type>
[[nodiscard]] meta_type_node resolve(const meta_context &context) noexcept {
    static_assert(std::is_same_v<Type, std::remove_const_t<std::remove_reference_t<Type>>>, "Invalid type");

    if(auto *elem = try_resolve(context, type_id<Type>()); elem) {
        return *elem;
    }

    meta_type_node node{
        &type_id<Type>(),
        type_id<Type>().hash(),
        (std::is_arithmetic_v<Type> ? meta_traits::is_arithmetic : meta_traits::is_none)
            | (std::is_integral_v<Type> ? meta_traits::is_integral : meta_traits::is_none)
            | (std::is_signed_v<Type> ? meta_traits::is_signed : meta_traits::is_none)
            | (std::is_array_v<Type> ? meta_traits::is_array : meta_traits::is_none)
            | (std::is_enum_v<Type> ? meta_traits::is_enum : meta_traits::is_none)
            | (std::is_class_v<Type> ? meta_traits::is_class : meta_traits::is_none)
            | (is_meta_pointer_like_v<Type> ? meta_traits::is_meta_pointer_like : meta_traits::is_none)
            | (is_complete_v<meta_sequence_container_traits<Type>> ? meta_traits::is_meta_sequence_container : meta_traits::is_none)
            | (is_complete_v<meta_associative_container_traits<Type>> ? meta_traits::is_meta_associative_container : meta_traits::is_none),
        size_of_v<Type>,
        &resolve<Type>,
        &resolve<std::remove_cv_t<std::remove_pointer_t<Type>>>};

    if constexpr(std::is_default_constructible_v<Type>) {
        node.default_constructor = +[](const meta_ctx &ctx) {
            return meta_any{ctx, std::in_place_type<Type>};
        };
    }

    if constexpr(std::is_arithmetic_v<Type>) {
        node.conversion_helper = +[](void *bin, const void *value) {
            return bin ? static_cast<double>(*static_cast<Type *>(bin) = static_cast<Type>(*static_cast<const double *>(value))) : static_cast<double>(*static_cast<const Type *>(value));
        };
    } else if constexpr(std::is_enum_v<Type>) {
        node.conversion_helper = +[](void *bin, const void *value) {
            return bin ? static_cast<double>(*static_cast<Type *>(bin) = static_cast<Type>(static_cast<std::underlying_type_t<Type>>(*static_cast<const double *>(value)))) : static_cast<double>(*static_cast<const Type *>(value));
        };
    }

    if constexpr(!std::is_same_v<Type, void> && !std::is_function_v<Type>) {
        node.from_void = +[](const meta_ctx &ctx, void *element, const void *as_const) {
            if(element) {
                return meta_any{ctx, std::in_place_type<std::decay_t<Type> &>, *static_cast<std::decay_t<Type> *>(element)};
            }

            return meta_any{ctx, std::in_place_type<const std::decay_t<Type> &>, *static_cast<const std::decay_t<Type> *>(as_const)};
        };
    }

    if constexpr(is_complete_v<meta_template_traits<Type>>) {
        node.templ = meta_template_node{
            meta_template_traits<Type>::args_type::size,
            &resolve<typename meta_template_traits<Type>::class_type>,
            +[](const meta_context &area, const std::size_t index) noexcept { return meta_arg_node(area, typename meta_template_traits<Type>::args_type{}, index); }};
    }

    return node;
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

} // namespace entt

#endif

////////////////////// END OF external/entt/meta/node.hpp //////////////////////

//////////////////// START OF external/entt/meta/range.hpp /////////////////////

#ifndef ENTT_META_RANGE_HPP
#define ENTT_META_RANGE_HPP

#include <cstddef>
#include <iterator>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Type, typename It>
struct meta_range_iterator final {
    using difference_type = std::ptrdiff_t;
    using value_type = std::pair<id_type, Type>;
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using iterator_category = std::input_iterator_tag;

    constexpr meta_range_iterator() noexcept
        : it{},
          ctx{} {}

    constexpr meta_range_iterator(const meta_ctx &area, const It iter) noexcept
        : it{iter},
          ctx{&area} {}

    constexpr meta_range_iterator &operator++() noexcept {
        return ++it, *this;
    }

    constexpr meta_range_iterator operator++(int) noexcept {
        meta_range_iterator orig = *this;
        return ++(*this), orig;
    }

    constexpr meta_range_iterator &operator--() noexcept {
        return --it, *this;
    }

    constexpr meta_range_iterator operator--(int) noexcept {
        meta_range_iterator orig = *this;
        return operator--(), orig;
    }

    constexpr meta_range_iterator &operator+=(const difference_type value) noexcept {
        it += value;
        return *this;
    }

    constexpr meta_range_iterator operator+(const difference_type value) const noexcept {
        meta_range_iterator copy = *this;
        return (copy += value);
    }

    constexpr meta_range_iterator &operator-=(const difference_type value) noexcept {
        return (*this += -value);
    }

    constexpr meta_range_iterator operator-(const difference_type value) const noexcept {
        return (*this + -value);
    }

    [[nodiscard]] constexpr reference operator[](const difference_type value) const noexcept {
        return {it[value].first, Type{*ctx, it[value].second}};
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return operator*();
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return {it->first, Type{*ctx, it->second}};
    }

    template<typename... Args>
    friend constexpr std::ptrdiff_t operator-(const meta_range_iterator<Args...> &, const meta_range_iterator<Args...> &) noexcept;

    template<typename... Args>
    friend constexpr bool operator==(const meta_range_iterator<Args...> &, const meta_range_iterator<Args...> &) noexcept;

    template<typename... Args>
    friend constexpr bool operator<(const meta_range_iterator<Args...> &, const meta_range_iterator<Args...> &) noexcept;

private:
    It it;
    const meta_ctx *ctx;
};

template<typename... Args>
[[nodiscard]] constexpr std::ptrdiff_t operator-(const meta_range_iterator<Args...> &lhs, const meta_range_iterator<Args...> &rhs) noexcept {
    return lhs.it - rhs.it;
}

template<typename... Args>
[[nodiscard]] constexpr bool operator==(const meta_range_iterator<Args...> &lhs, const meta_range_iterator<Args...> &rhs) noexcept {
    return lhs.it == rhs.it;
}

template<typename... Args>
[[nodiscard]] constexpr bool operator!=(const meta_range_iterator<Args...> &lhs, const meta_range_iterator<Args...> &rhs) noexcept {
    return !(lhs == rhs);
}

template<typename... Args>
[[nodiscard]] constexpr bool operator<(const meta_range_iterator<Args...> &lhs, const meta_range_iterator<Args...> &rhs) noexcept {
    return lhs.it < rhs.it;
}

template<typename... Args>
[[nodiscard]] constexpr bool operator>(const meta_range_iterator<Args...> &lhs, const meta_range_iterator<Args...> &rhs) noexcept {
    return rhs < lhs;
}

template<typename... Args>
[[nodiscard]] constexpr bool operator<=(const meta_range_iterator<Args...> &lhs, const meta_range_iterator<Args...> &rhs) noexcept {
    return !(lhs > rhs);
}

template<typename... Args>
[[nodiscard]] constexpr bool operator>=(const meta_range_iterator<Args...> &lhs, const meta_range_iterator<Args...> &rhs) noexcept {
    return !(lhs < rhs);
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Iterable range to use to iterate all types of meta objects.
 * @tparam Type Type of meta objects returned.
 * @tparam It Type of forward iterator.
 */
template<typename Type, typename It>
using meta_range = iterable_adaptor<internal::meta_range_iterator<Type, It>>;

} // namespace entt

#endif

///////////////////// END OF external/entt/meta/range.hpp //////////////////////

///////////////////// START OF external/entt/meta/meta.hpp /////////////////////

#ifndef ENTT_META_META_HPP
#define ENTT_META_META_HPP

#include <cstddef>
#include <iterator>
#include <memory>
#include <type_traits>
#include <utility>

namespace entt {

class meta_any;
class meta_type;

/*! @brief Proxy object for sequence containers. */
class meta_sequence_container {
    class meta_iterator;

public:
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Meta iterator type. */
    using iterator = meta_iterator;

    /**
     * @brief Context aware constructor.
     * @param area The context from which to search for meta types.
     */
    meta_sequence_container(const meta_ctx &area = locator<meta_ctx>::value_or()) noexcept
        : ctx{&area} {}

    /**
     * @brief Rebinds a proxy object to a sequence container type.
     * @tparam Type Type of container to wrap.
     * @param instance The container to wrap.
     */
    template<typename Type>
    void rebind(any instance) noexcept {
        value_type_node = &internal::resolve<typename Type::value_type>;
        size_fn = &meta_sequence_container_traits<Type>::size;
        resize_fn = &meta_sequence_container_traits<Type>::resize;
        iter_fn = &meta_sequence_container_traits<Type>::iter;
        insert_or_erase_fn = &meta_sequence_container_traits<Type>::insert_or_erase;
        storage = std::move(instance);
    }

    [[nodiscard]] inline meta_type value_type() const noexcept;
    [[nodiscard]] inline size_type size() const noexcept;
    inline bool resize(const size_type);
    inline bool clear();
    [[nodiscard]] inline iterator begin();
    [[nodiscard]] inline iterator end();
    inline iterator insert(iterator, meta_any);
    inline iterator erase(iterator);
    [[nodiscard]] inline meta_any operator[](const size_type);
    [[nodiscard]] inline explicit operator bool() const noexcept;

private:
    const meta_ctx *ctx{};
    internal::meta_type_node (*value_type_node)(const internal::meta_context &){};
    size_type (*size_fn)(const any &) noexcept {};
    bool (*resize_fn)(any &, size_type){};
    iterator (*iter_fn)(const meta_ctx &, any &, const bool){};
    iterator (*insert_or_erase_fn)(const meta_ctx &, any &, const any &, meta_any &){};
    any storage{};
};

/*! @brief Proxy object for associative containers. */
class meta_associative_container {
    class meta_iterator;

public:
    /*! @brief Unsigned integer type. */
    using size_type = std::size_t;
    /*! @brief Meta iterator type. */
    using iterator = meta_iterator;

    /**
     * @brief Context aware constructor.
     * @param area The context from which to search for meta types.
     */
    meta_associative_container(const meta_ctx &area = locator<meta_ctx>::value_or()) noexcept
        : ctx{&area} {}

    /**
     * @brief Rebinds a proxy object to an associative container type.
     * @tparam Type Type of container to wrap.
     * @param instance The container to wrap.
     */
    template<typename Type>
    void rebind(any instance) noexcept {
        if constexpr(!meta_associative_container_traits<Type>::key_only) {
            mapped_type_node = &internal::resolve<typename Type::mapped_type>;
        }

        key_only_container = meta_associative_container_traits<Type>::key_only;
        key_type_node = &internal::resolve<typename Type::key_type>;
        value_type_node = &internal::resolve<typename Type::value_type>;
        size_fn = &meta_associative_container_traits<Type>::size;
        clear_fn = &meta_associative_container_traits<Type>::clear;
        iter_fn = &meta_associative_container_traits<Type>::iter;
        insert_or_erase_fn = &meta_associative_container_traits<Type>::insert_or_erase;
        find_fn = &meta_associative_container_traits<Type>::find;
        storage = std::move(instance);
    }

    [[nodiscard]] inline bool key_only() const noexcept;
    [[nodiscard]] inline meta_type key_type() const noexcept;
    [[nodiscard]] inline meta_type mapped_type() const noexcept;
    [[nodiscard]] inline meta_type value_type() const noexcept;
    [[nodiscard]] inline size_type size() const noexcept;
    inline bool clear();
    [[nodiscard]] inline iterator begin();
    [[nodiscard]] inline iterator end();
    inline bool insert(meta_any);
    inline bool insert(meta_any, meta_any);
    inline size_type erase(meta_any);
    [[nodiscard]] inline iterator find(meta_any);
    [[nodiscard]] inline explicit operator bool() const noexcept;

private:
    const meta_ctx *ctx{};
    bool key_only_container{};
    internal::meta_type_node (*key_type_node)(const internal::meta_context &){};
    internal::meta_type_node (*mapped_type_node)(const internal::meta_context &){};
    internal::meta_type_node (*value_type_node)(const internal::meta_context &){};
    size_type (*size_fn)(const any &) noexcept {};
    bool (*clear_fn)(any &){};
    iterator (*iter_fn)(const meta_ctx &, any &, const bool){};
    size_type (*insert_or_erase_fn)(any &, meta_any &, meta_any &){};
    iterator (*find_fn)(const meta_ctx &, any &, meta_any &){};
    any storage{};
};

/*! @brief Opaque wrapper for values of any type. */
class meta_any {
    enum class operation : std::uint8_t {
        deref,
        seq,
        assoc
    };

    using vtable_type = void(const operation, const any &, void *);

    template<typename Type>
    static void basic_vtable([[maybe_unused]] const operation op, [[maybe_unused]] const any &value, [[maybe_unused]] void *other) {
        static_assert(std::is_same_v<std::remove_cv_t<std::remove_reference_t<Type>>, Type>, "Invalid type");

        if constexpr(!std::is_void_v<Type>) {
            switch(op) {
            case operation::deref:
                if constexpr(is_meta_pointer_like_v<Type>) {
                    if constexpr(std::is_function_v<typename std::pointer_traits<Type>::element_type>) {
                        static_cast<meta_any *>(other)->emplace<Type>(any_cast<Type>(value));
                    } else if constexpr(!std::is_same_v<std::remove_const_t<typename std::pointer_traits<Type>::element_type>, void>) {
                        using in_place_type = decltype(adl_meta_pointer_like<Type>::dereference(any_cast<const Type &>(value)));

                        if constexpr(std::is_constructible_v<bool, Type>) {
                            if(const auto &pointer_like = any_cast<const Type &>(value); pointer_like) {
                                static_cast<meta_any *>(other)->emplace<in_place_type>(adl_meta_pointer_like<Type>::dereference(pointer_like));
                            }
                        } else {
                            static_cast<meta_any *>(other)->emplace<in_place_type>(adl_meta_pointer_like<Type>::dereference(any_cast<const Type &>(value)));
                        }
                    }
                }
                break;
            case operation::seq:
                if constexpr(is_complete_v<meta_sequence_container_traits<Type>>) {
                    static_cast<meta_sequence_container *>(other)->rebind<Type>(std::move(const_cast<any &>(value)));
                }
                break;
            case operation::assoc:
                if constexpr(is_complete_v<meta_associative_container_traits<Type>>) {
                    static_cast<meta_associative_container *>(other)->rebind<Type>(std::move(const_cast<any &>(value)));
                }
                break;
            }
        }
    }

    void release() {
        if(node.dtor.dtor && owner()) {
            node.dtor.dtor(storage.data());
        }
    }

    meta_any(const meta_ctx &area, const meta_any &other, any ref) noexcept
        : storage{std::move(ref)},
          ctx{&area},
          node{storage ? other.node : internal::meta_type_node{}},
          vtable{storage ? other.vtable : &basic_vtable<void>} {}

public:
    /*! Default constructor. */
    meta_any() noexcept
        : meta_any{meta_ctx_arg, locator<meta_ctx>::value_or()} {}

    /**
     * @brief Context aware constructor.
     * @param area The context from which to search for meta types.
     */
    meta_any(meta_ctx_arg_t, const meta_ctx &area) noexcept
        : storage{},
          ctx{&area},
          node{},
          vtable{&basic_vtable<void>} {}

    /**
     * @brief Constructs a wrapper by directly initializing the new object.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @tparam Args Types of arguments to use to construct the new instance.
     * @param args Parameters to use to construct the instance.
     */
    template<typename Type, typename... Args>
    explicit meta_any(std::in_place_type_t<Type>, Args &&...args)
        : meta_any{locator<meta_ctx>::value_or(), std::in_place_type<Type>, std::forward<Args>(args)...} {}

    /**
     * @brief Constructs a wrapper by directly initializing the new object.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @tparam Args Types of arguments to use to construct the new instance.
     * @param area The context from which to search for meta types.
     * @param args Parameters to use to construct the instance.
     */
    template<typename Type, typename... Args>
    explicit meta_any(const meta_ctx &area, std::in_place_type_t<Type>, Args &&...args)
        : storage{std::in_place_type<Type>, std::forward<Args>(args)...},
          ctx{&area},
          node{internal::resolve<std::remove_cv_t<std::remove_reference_t<Type>>>(internal::meta_context::from(*ctx))},
          vtable{&basic_vtable<std::remove_cv_t<std::remove_reference_t<Type>>>} {}

    /**
     * @brief Constructs a wrapper from a given value.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @param value An instance of an object to use to initialize the wrapper.
     */
    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_any>>>
    meta_any(Type &&value)
        : meta_any{locator<meta_ctx>::value_or(), std::forward<Type>(value)} {}

    /**
     * @brief Constructs a wrapper from a given value.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @param area The context from which to search for meta types.
     * @param value An instance of an object to use to initialize the wrapper.
     */
    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_any>>>
    meta_any(const meta_ctx &area, Type &&value)
        : meta_any{area, std::in_place_type<std::decay_t<Type>>, std::forward<Type>(value)} {}

    /**
     * @brief Context aware copy constructor.
     * @param area The context from which to search for meta types.
     * @param other The instance to copy from.
     */
    meta_any(const meta_ctx &area, const meta_any &other)
        : meta_any{other} {
        ctx = &area;
        node = node.resolve ? node.resolve(internal::meta_context::from(*ctx)) : node;
    }

    /**
     * @brief Context aware move constructor.
     * @param area The context from which to search for meta types.
     * @param other The instance to move from.
     */
    meta_any(const meta_ctx &area, meta_any &&other)
        : meta_any{std::move(other)} {
        ctx = &area;
        node = node.resolve ? node.resolve(internal::meta_context::from(*ctx)) : node;
    }

    /**
     * @brief Copy constructor.
     * @param other The instance to copy from.
     */
    meta_any(const meta_any &other) = default;

    /**
     * @brief Move constructor.
     * @param other The instance to move from.
     */
    meta_any(meta_any &&other) noexcept
        : storage{std::move(other.storage)},
          ctx{other.ctx},
          node{std::exchange(other.node, internal::meta_type_node{})},
          vtable{std::exchange(other.vtable, &basic_vtable<void>)} {}

    /*! @brief Frees the internal storage, whatever it means. */
    ~meta_any() {
        release();
    }

    /**
     * @brief Copy assignment operator.
     * @param other The instance to copy from.
     * @return This meta any object.
     */
    meta_any &operator=(const meta_any &other) {
        release();
        storage = other.storage;
        ctx = other.ctx;
        node = other.node;
        vtable = other.vtable;
        return *this;
    }

    /**
     * @brief Move assignment operator.
     * @param other The instance to move from.
     * @return This meta any object.
     */
    meta_any &operator=(meta_any &&other) noexcept {
        release();
        storage = std::move(other.storage);
        ctx = other.ctx;
        node = std::exchange(other.node, internal::meta_type_node{});
        vtable = std::exchange(other.vtable, &basic_vtable<void>);
        return *this;
    }

    /**
     * @brief Value assignment operator.
     * @tparam Type Type of object to use to initialize the wrapper.
     * @param value An instance of an object to use to initialize the wrapper.
     * @return This meta any object.
     */
    template<typename Type>
    std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_any>, meta_any &>
    operator=(Type &&value) {
        emplace<std::decay_t<Type>>(std::forward<Type>(value));
        return *this;
    }

    /*! @copydoc any::type */
    [[nodiscard]] inline meta_type type() const noexcept;

    /*! @copydoc any::data */
    [[nodiscard]] const void *data() const noexcept {
        return storage.data();
    }

    /*! @copydoc any::data */
    [[nodiscard]] void *data() noexcept {
        return storage.data();
    }

    /**
     * @brief Invokes the underlying function, if possible.
     * @tparam Args Types of arguments to use to invoke the function.
     * @param id Unique identifier.
     * @param args Parameters to use to invoke the function.
     * @return A wrapper containing the returned value, if any.
     */
    template<typename... Args>
    meta_any invoke(const id_type id, Args &&...args) const;

    /*! @copydoc invoke */
    template<typename... Args>
    meta_any invoke(const id_type id, Args &&...args);

    /**
     * @brief Sets the value of a given variable.
     * @tparam Type Type of value to assign.
     * @param id Unique identifier.
     * @param value Parameter to use to set the underlying variable.
     * @return True in case of success, false otherwise.
     */
    template<typename Type>
    bool set(const id_type id, Type &&value);

    /**
     * @brief Gets the value of a given variable.
     * @param id Unique identifier.
     * @return A wrapper containing the value of the underlying variable.
     */
    [[nodiscard]] meta_any get(const id_type id) const;

    /*! @copydoc get */
    [[nodiscard]] meta_any get(const id_type id);

    /**
     * @brief Tries to cast an instance to a given type.
     * @tparam Type Type to which to cast the instance.
     * @return A (possibly null) pointer to the contained instance.
     */
    template<typename Type>
    [[nodiscard]] const Type *try_cast() const {
        const auto other = internal::resolve<std::remove_cv_t<Type>>(internal::meta_context::from(*ctx));
        return static_cast<const Type *>(internal::try_cast(internal::meta_context::from(*ctx), node, other, data()));
    }

    /*! @copydoc try_cast */
    template<typename Type>
    [[nodiscard]] Type *try_cast() {
        if constexpr(std::is_const_v<Type>) {
            return std::as_const(*this).try_cast<std::remove_const_t<Type>>();
        } else {
            const auto other = internal::resolve<std::remove_cv_t<Type>>(internal::meta_context::from(*ctx));
            return static_cast<Type *>(const_cast<void *>(internal::try_cast(internal::meta_context::from(*ctx), node, other, data())));
        }
    }

    /**
     * @brief Tries to cast an instance to a given type.
     *
     * @warning
     * Attempting to perform an invalid cast results is undefined behavior.
     *
     * @tparam Type Type to which to cast the instance.
     * @return A reference to the contained instance.
     */
    template<typename Type>
    [[nodiscard]] Type cast() const {
        auto *const instance = try_cast<std::remove_reference_t<Type>>();
        ENTT_ASSERT(instance, "Invalid instance");
        return static_cast<Type>(*instance);
    }

    /*! @copydoc cast */
    template<typename Type>
    [[nodiscard]] Type cast() {
        // forces const on non-reference types to make them work also with wrappers for const references
        auto *const instance = try_cast<std::remove_reference_t<const Type>>();
        ENTT_ASSERT(instance, "Invalid instance");
        return static_cast<Type>(*instance);
    }

    /**
     * @brief Converts an object in such a way that a given cast becomes viable.
     * @param type Meta type to which the cast is requested.
     * @return A valid meta any object if there exists a viable conversion, an
     * invalid one otherwise.
     */
    [[nodiscard]] meta_any allow_cast(const meta_type &type) const;

    /**
     * @brief Converts an object in such a way that a given cast becomes viable.
     * @param type Meta type to which the cast is requested.
     * @return True if there exists a viable conversion, false otherwise.
     */
    [[nodiscard]] bool allow_cast(const meta_type &type) {
        if(auto other = std::as_const(*this).allow_cast(type); other) {
            if(other.owner()) {
                std::swap(*this, other);
            }

            return true;
        }

        return false;
    }

    /**
     * @brief Converts an object in such a way that a given cast becomes viable.
     * @tparam Type Type to which the cast is requested.
     * @return A valid meta any object if there exists a viable conversion, an
     * invalid one otherwise.
     */
    template<typename Type>
    [[nodiscard]] meta_any allow_cast() const {
        if constexpr(std::is_reference_v<Type> && !std::is_const_v<std::remove_reference_t<Type>>) {
            return meta_any{meta_ctx_arg, *ctx};
        } else {
            auto other = internal::resolve<std::remove_cv_t<std::remove_reference_t<Type>>>(internal::meta_context::from(*ctx));
            return allow_cast(meta_type{*ctx, other});
        }
    }

    /**
     * @brief Converts an object in such a way that a given cast becomes viable.
     * @tparam Type Type to which the cast is requested.
     * @return True if there exists a viable conversion, false otherwise.
     */
    template<typename Type>
    bool allow_cast() {
        auto other = internal::resolve<std::remove_cv_t<std::remove_reference_t<Type>>>(internal::meta_context::from(*ctx));
        return allow_cast(meta_type{*ctx, other}) && (!(std::is_reference_v<Type> && !std::is_const_v<std::remove_reference_t<Type>>) || storage.data() != nullptr);
    }

    /*! @copydoc any::emplace */
    template<typename Type, typename... Args>
    void emplace(Args &&...args) {
        release();
        storage.emplace<Type>(std::forward<Args>(args)...);
        node = internal::resolve<std::remove_cv_t<std::remove_reference_t<Type>>>(internal::meta_context::from(*ctx));
        vtable = &basic_vtable<std::remove_cv_t<std::remove_reference_t<Type>>>;
    }

    /*! @copydoc any::assign */
    bool assign(const meta_any &other);

    /*! @copydoc any::assign */
    bool assign(meta_any &&other);

    /*! @copydoc any::reset */
    void reset() {
        release();
        storage.reset();
        node = {};
        vtable = &basic_vtable<void>;
    }

    /**
     * @brief Returns a sequence container proxy.
     * @return A sequence container proxy for the underlying object.
     */
    [[nodiscard]] meta_sequence_container as_sequence_container() noexcept {
        any detached = storage.as_ref();
        meta_sequence_container proxy{*ctx};
        vtable(operation::seq, detached, &proxy);
        return proxy;
    }

    /*! @copydoc as_sequence_container */
    [[nodiscard]] meta_sequence_container as_sequence_container() const noexcept {
        any detached = storage.as_ref();
        meta_sequence_container proxy{*ctx};
        vtable(operation::seq, detached, &proxy);
        return proxy;
    }

    /**
     * @brief Returns an associative container proxy.
     * @return An associative container proxy for the underlying object.
     */
    [[nodiscard]] meta_associative_container as_associative_container() noexcept {
        any detached = storage.as_ref();
        meta_associative_container proxy{*ctx};
        vtable(operation::assoc, detached, &proxy);
        return proxy;
    }

    /*! @copydoc as_associative_container */
    [[nodiscard]] meta_associative_container as_associative_container() const noexcept {
        any detached = storage.as_ref();
        meta_associative_container proxy{*ctx};
        vtable(operation::assoc, detached, &proxy);
        return proxy;
    }

    /**
     * @brief Indirection operator for dereferencing opaque objects.
     * @return A wrapper that shares a reference to an unmanaged object if the
     * wrapped element is dereferenceable, an invalid meta any otherwise.
     */
    [[nodiscard]] meta_any operator*() const noexcept {
        meta_any ret{meta_ctx_arg, *ctx};
        vtable(operation::deref, storage, &ret);
        return ret;
    }

    /**
     * @brief Returns false if a wrapper is invalid, true otherwise.
     * @return False if the wrapper is invalid, true otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return !(node.info == nullptr);
    }

    /*! @copydoc any::operator== */
    [[nodiscard]] bool operator==(const meta_any &other) const noexcept {
        return (ctx == other.ctx) && ((!node.info && !other.node.info) || (node.info && other.node.info && *node.info == *other.node.info && storage == other.storage));
    }

    /*! @copydoc any::operator!= */
    [[nodiscard]] bool operator!=(const meta_any &other) const noexcept {
        return !(*this == other);
    }

    /*! @copydoc any::as_ref */
    [[nodiscard]] meta_any as_ref() noexcept {
        return meta_any{*ctx, *this, storage.as_ref()};
    }

    /*! @copydoc any::as_ref */
    [[nodiscard]] meta_any as_ref() const noexcept {
        return meta_any{*ctx, *this, storage.as_ref()};
    }

    /*! @copydoc any::owner */
    [[nodiscard]] bool owner() const noexcept {
        return storage.owner();
    }

private:
    any storage;
    const meta_ctx *ctx;
    internal::meta_type_node node;
    vtable_type *vtable;
};

/**
 * @brief Forwards its argument and avoids copies for lvalue references.
 * @tparam Type Type of argument to use to construct the new instance.
 * @param value Parameter to use to construct the instance.
 * @param ctx The context from which to search for meta types.
 * @return A properly initialized and not necessarily owning wrapper.
 */
template<typename Type>
[[nodiscard]] meta_any forward_as_meta(const meta_ctx &ctx, Type &&value) {
    return meta_any{ctx, std::in_place_type<Type &&>, std::forward<Type>(value)};
}

/**
 * @brief Forwards its argument and avoids copies for lvalue references.
 * @tparam Type Type of argument to use to construct the new instance.
 * @param value Parameter to use to construct the instance.
 * @return A properly initialized and not necessarily owning wrapper.
 */
template<typename Type>
[[nodiscard]] meta_any forward_as_meta(Type &&value) {
    return forward_as_meta(locator<meta_ctx>::value_or(), std::forward<Type>(value));
}

/**
 * @brief Opaque pointers to instances of any type.
 *
 * A handle doesn't perform copies and isn't responsible for the contained
 * object. It doesn't prolong the lifetime of the pointed instance.<br/>
 * Handles are used to generate references to actual objects when needed.
 */
struct meta_handle {
    /*! Default constructor. */
    meta_handle() noexcept
        : meta_handle{meta_ctx_arg, locator<meta_ctx>::value_or()} {}

    /**
     * @brief Context aware constructor.
     * @param area The context from which to search for meta types.
     */
    meta_handle(meta_ctx_arg_t, const meta_ctx &area) noexcept
        : any{meta_ctx_arg, area} {}

    /**
     * @brief Creates a handle that points to an unmanaged object.
     * @param value An instance of an object to use to initialize the handle.
     */
    meta_handle(meta_any &value) noexcept
        : any{value.as_ref()} {}

    /**
     * @brief Creates a handle that points to an unmanaged object.
     * @param value An instance of an object to use to initialize the handle.
     */
    meta_handle(const meta_any &value) noexcept
        : any{value.as_ref()} {}

    /**
     * @brief Creates a handle that points to an unmanaged object.
     * @tparam Type Type of object to use to initialize the handle.
     * @param ctx The context from which to search for meta types.
     * @param value An instance of an object to use to initialize the handle.
     */
    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_handle>>>
    meta_handle(const meta_ctx &ctx, Type &value) noexcept
        : any{ctx, std::in_place_type<Type &>, value} {}

    /**
     * @brief Creates a handle that points to an unmanaged object.
     * @tparam Type Type of object to use to initialize the handle.
     * @param value An instance of an object to use to initialize the handle.
     */
    template<typename Type, typename = std::enable_if_t<!std::is_same_v<std::decay_t<Type>, meta_handle>>>
    meta_handle(Type &value) noexcept
        : meta_handle{locator<meta_ctx>::value_or(), value} {}

    /**
     * @brief Context aware copy constructor.
     * @param area The context from which to search for meta types.
     * @param other The instance to copy from.
     */
    meta_handle(const meta_ctx &area, const meta_handle &other)
        : any{area, other.any} {}

    /**
     * @brief Context aware move constructor.
     * @param area The context from which to search for meta types.
     * @param other The instance to move from.
     */
    meta_handle(const meta_ctx &area, meta_handle &&other)
        : any{area, std::move(other.any)} {}

    /*! @brief Default copy constructor, deleted on purpose. */
    meta_handle(const meta_handle &) = delete;

    /*! @brief Default move constructor. */
    meta_handle(meta_handle &&) = default;

    /**
     * @brief Default copy assignment operator, deleted on purpose.
     * @return This meta handle.
     */
    meta_handle &operator=(const meta_handle &) = delete;

    /**
     * @brief Default move assignment operator.
     * @return This meta handle.
     */
    meta_handle &operator=(meta_handle &&) = default;

    /**
     * @brief Returns false if a handle is invalid, true otherwise.
     * @return False if the handle is invalid, true otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return static_cast<bool>(any);
    }

    /*! @copydoc meta_any::operator== */
    [[nodiscard]] bool operator==(const meta_handle &other) const noexcept {
        return (any == other.any);
    }

    /*! @copydoc meta_any::operator!= */
    [[nodiscard]] bool operator!=(const meta_handle &other) const noexcept {
        return !(*this == other);
    }

    /**
     * @brief Access operator for accessing the contained opaque object.
     * @return A wrapper that shares a reference to an unmanaged object.
     */
    [[nodiscard]] meta_any *operator->() {
        return &any;
    }

    /*! @copydoc operator-> */
    [[nodiscard]] const meta_any *operator->() const {
        return &any;
    }

private:
    meta_any any;
};

/*! @brief Opaque wrapper for properties of any type. */
struct meta_prop {
    /*! @brief Default constructor. */
    meta_prop() noexcept
        : node{},
          ctx{} {}

    /**
     * @brief Context aware constructor for meta objects.
     * @param area The context from which to search for meta types.
     * @param curr The underlying node with which to construct the instance.
     */
    meta_prop(const meta_ctx &area, const internal::meta_prop_node &curr) noexcept
        : node{&curr},
          ctx{&area} {}

    /**
     * @brief Returns the stored value by const reference.
     * @return A wrapper containing the value stored with the property.
     */
    [[nodiscard]] meta_any value() const {
        return node->value ? node->type(internal::meta_context::from(*ctx)).from_void(*ctx, nullptr, node->value.get()) : meta_any{meta_ctx_arg, *ctx};
    }

    /**
     * @brief Returns the stored value by reference.
     * @return A wrapper containing the value stored with the property.
     */
    [[nodiscard]] meta_any value() {
        return node->value ? node->type(internal::meta_context::from(*ctx)).from_void(*ctx, node->value.get(), nullptr) : meta_any{meta_ctx_arg, *ctx};
    }

    /**
     * @brief Returns true if an object is valid, false otherwise.
     * @return True if the object is valid, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return (node != nullptr);
    }

    /**
     * @brief Checks if two objects refer to the same type.
     * @param other The object with which to compare.
     * @return True if the objects refer to the same type, false otherwise.
     */
    [[nodiscard]] bool operator==(const meta_prop &other) const noexcept {
        return (ctx == other.ctx && node == other.node);
    }

private:
    const internal::meta_prop_node *node;
    const meta_ctx *ctx;
};

/**
 * @brief Checks if two objects refer to the same type.
 * @param lhs An object, either valid or not.
 * @param rhs An object, either valid or not.
 * @return False if the objects refer to the same node, true otherwise.
 */
[[nodiscard]] inline bool operator!=(const meta_prop &lhs, const meta_prop &rhs) noexcept {
    return !(lhs == rhs);
}

/*! @brief Opaque wrapper for data members. */
struct meta_data {
    /*! @brief Unsigned integer type. */
    using size_type = typename internal::meta_data_node::size_type;

    /*! @brief Default constructor. */
    meta_data() noexcept
        : node{},
          ctx{} {}

    /**
     * @brief Context aware constructor for meta objects.
     * @param area The context from which to search for meta types.
     * @param curr The underlying node with which to construct the instance.
     */
    meta_data(const meta_ctx &area, const internal::meta_data_node &curr) noexcept
        : node{&curr},
          ctx{&area} {}

    /**
     * @brief Returns the number of setters available.
     * @return The number of setters available.
     */
    [[nodiscard]] size_type arity() const noexcept {
        return node->arity;
    }

    /**
     * @brief Indicates whether a data member is constant or not.
     * @return True if the data member is constant, false otherwise.
     */
    [[nodiscard]] bool is_const() const noexcept {
        return static_cast<bool>(node->traits & internal::meta_traits::is_const);
    }

    /**
     * @brief Indicates whether a data member is static or not.
     * @return True if the data member is static, false otherwise.
     */
    [[nodiscard]] bool is_static() const noexcept {
        return static_cast<bool>(node->traits & internal::meta_traits::is_static);
    }

    /*! @copydoc meta_any::type */
    [[nodiscard]] inline meta_type type() const noexcept;

    /**
     * @brief Sets the value of a given variable.
     * @tparam Type Type of value to assign.
     * @param instance An opaque instance of the underlying type.
     * @param value Parameter to use to set the underlying variable.
     * @return True in case of success, false otherwise.
     */
    template<typename Type>
    bool set(meta_handle instance, Type &&value) const {
        return node->set && node->set(meta_handle{*ctx, std::move(instance)}, meta_any{*ctx, std::forward<Type>(value)});
    }

    /**
     * @brief Gets the value of a given variable.
     * @param instance An opaque instance of the underlying type.
     * @return A wrapper containing the value of the underlying variable.
     */
    [[nodiscard]] meta_any get(meta_handle instance) const {
        return node->get(*ctx, meta_handle{*ctx, std::move(instance)});
    }

    /**
     * @brief Returns the type accepted by the i-th setter.
     * @param index Index of the setter of which to return the accepted type.
     * @return The type accepted by the i-th setter.
     */
    [[nodiscard]] inline meta_type arg(const size_type index) const noexcept;

    /**
     * @brief Returns a range to visit registered meta properties.
     * @return An iterable range to visit registered meta properties.
     */
    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_data_node::prop)::const_iterator> prop() const noexcept {
        return {{*ctx, node->prop.cbegin()}, {*ctx, node->prop.cend()}};
    }

    /**
     * @brief Lookup utility for meta properties.
     * @param key The key to use to search for a property.
     * @return The registered meta property for the given key, if any.
     */
    [[nodiscard]] meta_prop prop(const id_type key) const {
        const auto it = node->prop.find(key);
        return it != node->prop.cend() ? meta_prop{*ctx, it->second} : meta_prop{};
    }

    /**
     * @brief Returns true if an object is valid, false otherwise.
     * @return True if the object is valid, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return (node != nullptr);
    }

    /*! @copydoc meta_prop::operator== */
    [[nodiscard]] bool operator==(const meta_data &other) const noexcept {
        return (ctx == other.ctx && node == other.node);
    }

private:
    const internal::meta_data_node *node;
    const meta_ctx *ctx;
};

/**
 * @brief Checks if two objects refer to the same type.
 * @param lhs An object, either valid or not.
 * @param rhs An object, either valid or not.
 * @return False if the objects refer to the same node, true otherwise.
 */
[[nodiscard]] inline bool operator!=(const meta_data &lhs, const meta_data &rhs) noexcept {
    return !(lhs == rhs);
}

/*! @brief Opaque wrapper for member functions. */
struct meta_func {
    /*! @brief Unsigned integer type. */
    using size_type = typename internal::meta_func_node::size_type;

    /*! @brief Default constructor. */
    meta_func() noexcept
        : node{},
          ctx{} {}

    /**
     * @brief Context aware constructor for meta objects.
     * @param area The context from which to search for meta types.
     * @param curr The underlying node with which to construct the instance.
     */
    meta_func(const meta_ctx &area, const internal::meta_func_node &curr) noexcept
        : node{&curr},
          ctx{&area} {}

    /**
     * @brief Returns the number of arguments accepted by a member function.
     * @return The number of arguments accepted by the member function.
     */
    [[nodiscard]] size_type arity() const noexcept {
        return node->arity;
    }

    /**
     * @brief Indicates whether a member function is constant or not.
     * @return True if the member function is constant, false otherwise.
     */
    [[nodiscard]] bool is_const() const noexcept {
        return static_cast<bool>(node->traits & internal::meta_traits::is_const);
    }

    /**
     * @brief Indicates whether a member function is static or not.
     * @return True if the member function is static, false otherwise.
     */
    [[nodiscard]] bool is_static() const noexcept {
        return static_cast<bool>(node->traits & internal::meta_traits::is_static);
    }

    /**
     * @brief Returns the return type of a member function.
     * @return The return type of the member function.
     */
    [[nodiscard]] inline meta_type ret() const noexcept;

    /**
     * @brief Returns the type of the i-th argument of a member function.
     * @param index Index of the argument of which to return the type.
     * @return The type of the i-th argument of a member function.
     */
    [[nodiscard]] inline meta_type arg(const size_type index) const noexcept;

    /**
     * @brief Invokes the underlying function, if possible.
     *
     * @warning
     * The context of the arguments is **not** changed.<br/>
     * It's up to the caller to bind them to the right context(s).
     *
     * @param instance An opaque instance of the underlying type.
     * @param args Parameters to use to invoke the function.
     * @param sz Number of parameters to use to invoke the function.
     * @return A wrapper containing the returned value, if any.
     */
    meta_any invoke(meta_handle instance, meta_any *const args, const size_type sz) const {
        return sz == arity() ? node->invoke(*ctx, meta_handle{*ctx, std::move(instance)}, args) : meta_any{meta_ctx_arg, *ctx};
    }

    /**
     * @copybrief invoke
     * @tparam Args Types of arguments to use to invoke the function.
     * @param instance An opaque instance of the underlying type.
     * @param args Parameters to use to invoke the function.
     * @return A wrapper containing the returned value, if any.
     */
    template<typename... Args>
    meta_any invoke(meta_handle instance, Args &&...args) const {
        if constexpr(sizeof...(Args) == 0u) {
            return invoke(std::move(instance), static_cast<meta_any *>(nullptr), size_type{});
        } else {
            meta_any arguments[sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
            return invoke(std::move(instance), arguments, sizeof...(Args));
        }
    }

    /*! @copydoc meta_data::prop */
    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_func_node::prop)::const_iterator> prop() const noexcept {
        return {{*ctx, node->prop.cbegin()}, {*ctx, node->prop.cend()}};
    }

    /**
     * @brief Lookup utility for meta properties.
     * @param key The key to use to search for a property.
     * @return The registered meta property for the given key, if any.
     */
    [[nodiscard]] meta_prop prop(const id_type key) const {
        const auto it = node->prop.find(key);
        return it != node->prop.cend() ? meta_prop{*ctx, it->second} : meta_prop{};
    }

    /**
     * @brief Returns the next overload of a given function, if any.
     * @return The next overload of the given function, if any.
     */
    [[nodiscard]] meta_func next() const {
        return node->next ? meta_func{*ctx, *node->next} : meta_func{};
    }

    /**
     * @brief Returns true if an object is valid, false otherwise.
     * @return True if the object is valid, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return (node != nullptr);
    }

    /*! @copydoc meta_prop::operator== */
    [[nodiscard]] bool operator==(const meta_func &other) const noexcept {
        return (ctx == other.ctx && node == other.node);
    }

private:
    const internal::meta_func_node *node;
    const meta_ctx *ctx;
};

/**
 * @brief Checks if two objects refer to the same type.
 * @param lhs An object, either valid or not.
 * @param rhs An object, either valid or not.
 * @return False if the objects refer to the same node, true otherwise.
 */
[[nodiscard]] inline bool operator!=(const meta_func &lhs, const meta_func &rhs) noexcept {
    return !(lhs == rhs);
}

/*! @brief Opaque wrapper for types. */
class meta_type {
    template<typename Func>
    [[nodiscard]] auto lookup(meta_any *const args, const typename internal::meta_type_node::size_type sz, [[maybe_unused]] bool constness, Func next) const {
        decltype(next()) candidate = nullptr;
        size_type same{};
        bool ambiguous{};

        for(auto curr = next(); curr; curr = next()) {
            if constexpr(std::is_same_v<std::decay_t<decltype(*curr)>, internal::meta_func_node>) {
                if(constness && !static_cast<bool>(curr->traits & internal::meta_traits::is_const)) {
                    continue;
                }
            }

            if(curr->arity == sz) {
                size_type match{};
                size_type pos{};

                for(; pos < sz && args[pos]; ++pos) {
                    const auto other = curr->arg(*ctx, pos);
                    const auto type = args[pos].type();

                    if(const auto &info = other.info(); info == type.info()) {
                        ++match;
                    } else if(!((type.node.details && (type.node.details->base.contains(info.hash()) || type.node.details->conv.contains(info.hash()))) || (type.node.conversion_helper && other.node.conversion_helper))) {
                        break;
                    }
                }

                if(pos == sz) {
                    if(!candidate || match > same) {
                        candidate = curr;
                        same = match;
                        ambiguous = false;
                    } else if(match == same) {
                        if constexpr(std::is_same_v<std::decay_t<decltype(*curr)>, internal::meta_func_node>) {
                            if(static_cast<bool>(curr->traits & internal::meta_traits::is_const) != static_cast<bool>(candidate->traits & internal::meta_traits::is_const)) {
                                candidate = static_cast<bool>(candidate->traits & internal::meta_traits::is_const) ? curr : candidate;
                                ambiguous = false;
                                continue;
                            }
                        }

                        ambiguous = true;
                    }
                }
            }
        }

        return ambiguous ? nullptr : candidate;
    }

public:
    /*! @brief Unsigned integer type. */
    using size_type = typename internal::meta_type_node::size_type;

    /*! @brief Default constructor. */
    meta_type() noexcept
        : node{},
          ctx{} {}

    /**
     * @brief Context aware constructor for meta objects.
     * @param area The context from which to search for meta types.
     * @param curr The underlying node with which to construct the instance.
     */
    meta_type(const meta_ctx &area, const internal::meta_type_node &curr) noexcept
        : node{curr},
          ctx{&area} {}

    /**
     * @brief Context aware constructor for meta objects.
     * @param area The context from which to search for meta types.
     * @param curr The underlying node with which to construct the instance.
     */
    meta_type(const meta_ctx &area, const internal::meta_base_node &curr) noexcept
        : meta_type{area, curr.type(internal::meta_context::from(area))} {}

    /**
     * @brief Returns the type info object of the underlying type.
     * @return The type info object of the underlying type.
     */
    [[nodiscard]] const type_info &info() const noexcept {
        return *node.info;
    }

    /**
     * @brief Returns the identifier assigned to a type.
     * @return The identifier assigned to the type.
     */
    [[nodiscard]] id_type id() const noexcept {
        return node.id;
    }

    /**
     * @brief Returns the size of the underlying type if known.
     * @return The size of the underlying type if known, 0 otherwise.
     */
    [[nodiscard]] size_type size_of() const noexcept {
        return node.size_of;
    }

    /**
     * @brief Checks whether a type refers to an arithmetic type or not.
     * @return True if the underlying type is an arithmetic type, false
     * otherwise.
     */
    [[nodiscard]] bool is_arithmetic() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_arithmetic);
    }

    /**
     * @brief Checks whether a type refers to an integral type or not.
     * @return True if the underlying type is an integral type, false otherwise.
     */
    [[nodiscard]] bool is_integral() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_integral);
    }

    /**
     * @brief Checks whether a type refers to a signed type or not.
     * @return True if the underlying type is a signed type, false otherwise.
     */
    [[nodiscard]] bool is_signed() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_signed);
    }

    /**
     * @brief Checks whether a type refers to an array type or not.
     * @return True if the underlying type is an array type, false otherwise.
     */
    [[nodiscard]] bool is_array() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_array);
    }

    /**
     * @brief Checks whether a type refers to an enum or not.
     * @return True if the underlying type is an enum, false otherwise.
     */
    [[nodiscard]] bool is_enum() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_enum);
    }

    /**
     * @brief Checks whether a type refers to a class or not.
     * @return True if the underlying type is a class, false otherwise.
     */
    [[nodiscard]] bool is_class() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_class);
    }

    /**
     * @brief Checks whether a type refers to a pointer or not.
     * @return True if the underlying type is a pointer, false otherwise.
     */
    [[nodiscard]] bool is_pointer() const noexcept {
        return node.info && (node.info->hash() != remove_pointer().info().hash());
    }

    /**
     * @brief Provides the type for which the pointer is defined.
     * @return The type for which the pointer is defined or this type if it
     * doesn't refer to a pointer type.
     */
    [[nodiscard]] meta_type remove_pointer() const noexcept {
        return {*ctx, node.remove_pointer(internal::meta_context::from(*ctx))};
    }

    /**
     * @brief Checks whether a type is a pointer-like type or not.
     * @return True if the underlying type is a pointer-like one, false
     * otherwise.
     */
    [[nodiscard]] bool is_pointer_like() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_meta_pointer_like);
    }

    /**
     * @brief Checks whether a type refers to a sequence container or not.
     * @return True if the type is a sequence container, false otherwise.
     */
    [[nodiscard]] bool is_sequence_container() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_meta_sequence_container);
    }

    /**
     * @brief Checks whether a type refers to an associative container or not.
     * @return True if the type is an associative container, false otherwise.
     */
    [[nodiscard]] bool is_associative_container() const noexcept {
        return static_cast<bool>(node.traits & internal::meta_traits::is_meta_associative_container);
    }

    /**
     * @brief Checks whether a type refers to a recognized class template
     * specialization or not.
     * @return True if the type is a recognized class template specialization,
     * false otherwise.
     */
    [[nodiscard]] bool is_template_specialization() const noexcept {
        return (node.templ.arity != 0u);
    }

    /**
     * @brief Returns the number of template arguments.
     * @return The number of template arguments.
     */
    [[nodiscard]] size_type template_arity() const noexcept {
        return node.templ.arity;
    }

    /**
     * @brief Returns a tag for the class template of the underlying type.
     * @return The tag for the class template of the underlying type.
     */
    [[nodiscard]] inline meta_type template_type() const noexcept {
        return node.templ.type ? meta_type{*ctx, node.templ.type(internal::meta_context::from(*ctx))} : meta_type{};
    }

    /**
     * @brief Returns the type of the i-th template argument of a type.
     * @param index Index of the template argument of which to return the type.
     * @return The type of the i-th template argument of a type.
     */
    [[nodiscard]] inline meta_type template_arg(const size_type index) const noexcept {
        return index < template_arity() ? meta_type{*ctx, node.templ.arg(internal::meta_context::from(*ctx), index)} : meta_type{};
    }

    /**
     * @brief Returns a range to visit registered top-level base meta types.
     * @return An iterable range to visit registered top-level base meta types.
     */
    [[nodiscard]] meta_range<meta_type, typename decltype(internal::meta_type_descriptor::base)::const_iterator> base() const noexcept {
        using range_type = meta_range<meta_type, typename decltype(internal::meta_type_descriptor::base)::const_iterator>;
        return node.details ? range_type{{*ctx, node.details->base.cbegin()}, {*ctx, node.details->base.cend()}} : range_type{};
    }

    /**
     * @brief Returns a range to visit registered top-level meta data.
     * @return An iterable range to visit registered top-level meta data.
     */
    [[nodiscard]] meta_range<meta_data, typename decltype(internal::meta_type_descriptor::data)::const_iterator> data() const noexcept {
        using range_type = meta_range<meta_data, typename decltype(internal::meta_type_descriptor::data)::const_iterator>;
        return node.details ? range_type{{*ctx, node.details->data.cbegin()}, {*ctx, node.details->data.cend()}} : range_type{};
    }

    /**
     * @brief Lookup utility for meta data (bases are also visited).
     * @param id Unique identifier.
     * @return The registered meta data for the given identifier, if any.
     */
    [[nodiscard]] meta_data data(const id_type id) const {
        if(node.details) {
            if(const auto it = node.details->data.find(id); it != node.details->data.cend()) {
                return meta_data{*ctx, it->second};
            }
        }

        for(auto &&curr: base()) {
            if(auto elem = curr.second.data(id); elem) {
                return elem;
            }
        }

        return meta_data{};
    }

    /**
     * @brief Returns a range to visit registered top-level functions.
     * @return An iterable range to visit registered top-level functions.
     */
    [[nodiscard]] meta_range<meta_func, typename decltype(internal::meta_type_descriptor::func)::const_iterator> func() const noexcept {
        using return_type = meta_range<meta_func, typename decltype(internal::meta_type_descriptor::func)::const_iterator>;
        return node.details ? return_type{{*ctx, node.details->func.cbegin()}, {*ctx, node.details->func.cend()}} : return_type{};
    }

    /**
     * @brief Lookup utility for meta functions (bases are also visited).
     *
     * In case of overloaded functions, the first one with the required
     * identifier is returned.
     *
     * @param id Unique identifier.
     * @return The registered meta function for the given identifier, if any.
     */
    [[nodiscard]] meta_func func(const id_type id) const {
        if(node.details) {
            if(const auto it = node.details->func.find(id); it != node.details->func.cend()) {
                return meta_func{*ctx, it->second};
            }
        }

        for(auto &&curr: base()) {
            if(auto elem = curr.second.func(id); elem) {
                return elem;
            }
        }

        return meta_func{};
    }

    /**
     * @brief Creates an instance of the underlying type, if possible.
     *
     * If suitable, the implicitly generated default constructor is used.
     *
     * @warning
     * The context of the arguments is **not** changed.<br/>
     * It's up to the caller to bind them to the right context(s).
     *
     * @param args Parameters to use to construct the instance.
     * @param sz Number of parameters to use to construct the instance.
     * @return A wrapper containing the new instance, if any.
     */
    [[nodiscard]] meta_any construct(meta_any *const args, const size_type sz) const {
        if(node.details) {
            if(const auto *candidate = lookup(args, sz, false, [first = node.details->ctor.cbegin(), last = node.details->ctor.cend()]() mutable { return first == last ? nullptr : &(first++)->second; }); candidate) {
                return candidate->invoke(*ctx, args);
            }
        }

        if(sz == 0u && node.default_constructor) {
            return node.default_constructor(*ctx);
        }

        return meta_any{meta_ctx_arg, *ctx};
    }

    /**
     * @copybrief construct
     * @tparam Args Types of arguments to use to construct the instance.
     * @param args Parameters to use to construct the instance.
     * @return A wrapper containing the new instance, if any.
     */
    template<typename... Args>
    [[nodiscard]] meta_any construct(Args &&...args) const {
        if constexpr(sizeof...(Args) == 0u) {
            return construct(static_cast<meta_any *>(nullptr), size_type{});
        } else {
            meta_any arguments[sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
            return construct(arguments, sizeof...(Args));
        }
    }

    /**
     * @brief Wraps an opaque element of the underlying type.
     * @param element A valid pointer to an element of the underlying type.
     * @return A wrapper that references the given instance.
     */
    [[nodiscard]] meta_any from_void(void *element) const {
        return (element && node.from_void) ? node.from_void(*ctx, element, nullptr) : meta_any{meta_ctx_arg, *ctx};
    }

    /*! @copydoc from_void */
    [[nodiscard]] meta_any from_void(const void *element) const {
        return (element && node.from_void) ? node.from_void(*ctx, nullptr, element) : meta_any{meta_ctx_arg, *ctx};
    }

    /**
     * @brief Invokes a function given an identifier, if possible.
     *
     * @warning
     * The context of the arguments is **not** changed.<br/>
     * It's up to the caller to bind them to the right context(s).
     *
     * @param id Unique identifier.
     * @param instance An opaque instance of the underlying type.
     * @param args Parameters to use to invoke the function.
     * @param sz Number of parameters to use to invoke the function.
     * @return A wrapper containing the returned value, if any.
     */
    meta_any invoke(const id_type id, meta_handle instance, meta_any *const args, const size_type sz) const {
        if(node.details) {
            if(auto it = node.details->func.find(id); it != node.details->func.cend()) {
                if(const auto *candidate = lookup(args, sz, instance && (instance->data() == nullptr), [curr = &it->second]() mutable { return curr ? std::exchange(curr, curr->next.get()) : nullptr; }); candidate) {
                    return candidate->invoke(*ctx, meta_handle{*ctx, std::move(instance)}, args);
                }
            }
        }

        for(auto &&curr: base()) {
            if(auto elem = curr.second.invoke(id, *instance.operator->(), args, sz); elem) {
                return elem;
            }
        }

        return meta_any{meta_ctx_arg, *ctx};
    }

    /**
     * @copybrief invoke
     *
     * @param id Unique identifier.
     * @tparam Args Types of arguments to use to invoke the function.
     * @param instance An opaque instance of the underlying type.
     * @param args Parameters to use to invoke the function.
     * @return A wrapper containing the returned value, if any.
     */
    template<typename... Args>
    meta_any invoke(const id_type id, meta_handle instance, Args &&...args) const {
        if constexpr(sizeof...(Args) == 0u) {
            return invoke(id, std::move(instance), static_cast<meta_any *>(nullptr), size_type{});
        } else {
            meta_any arguments[sizeof...(Args)]{{*ctx, std::forward<Args>(args)}...};
            return invoke(id, std::move(instance), arguments, sizeof...(Args));
        }
    }

    /**
     * @brief Sets the value of a given variable.
     * @tparam Type Type of value to assign.
     * @param id Unique identifier.
     * @param instance An opaque instance of the underlying type.
     * @param value Parameter to use to set the underlying variable.
     * @return True in case of success, false otherwise.
     */
    template<typename Type>
    bool set(const id_type id, meta_handle instance, Type &&value) const {
        const auto candidate = data(id);
        return candidate && candidate.set(std::move(instance), std::forward<Type>(value));
    }

    /**
     * @brief Gets the value of a given variable.
     * @param id Unique identifier.
     * @param instance An opaque instance of the underlying type.
     * @return A wrapper containing the value of the underlying variable.
     */
    [[nodiscard]] meta_any get(const id_type id, meta_handle instance) const {
        const auto candidate = data(id);
        return candidate ? candidate.get(std::move(instance)) : meta_any{meta_ctx_arg, *ctx};
    }

    /**
     * @brief Returns a range to visit registered top-level meta properties.
     * @return An iterable range to visit registered top-level meta properties.
     */
    [[nodiscard]] meta_range<meta_prop, typename decltype(internal::meta_type_descriptor::prop)::const_iterator> prop() const noexcept {
        using range_type = meta_range<meta_prop, typename decltype(internal::meta_type_descriptor::prop)::const_iterator>;
        return node.details ? range_type{{*ctx, node.details->prop.cbegin()}, {*ctx, node.details->prop.cend()}} : range_type{};
    }

    /**
     * @brief Lookup utility for meta properties (bases are also visited).
     * @param key The key to use to search for a property.
     * @return The registered meta property for the given key, if any.
     */
    [[nodiscard]] meta_prop prop(const id_type key) const {
        if(node.details) {
            if(const auto it = node.details->prop.find(key); it != node.details->prop.cend()) {
                return meta_prop{*ctx, it->second};
            }
        }

        for(auto &&curr: base()) {
            if(auto elem = curr.second.prop(key); elem) {
                return elem;
            }
        }

        return meta_prop{};
    }

    /**
     * @brief Returns true if an object is valid, false otherwise.
     * @return True if the object is valid, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return !(ctx == nullptr);
    }

    /*! @copydoc meta_prop::operator== */
    [[nodiscard]] bool operator==(const meta_type &other) const noexcept {
        return (ctx == other.ctx) && ((!node.info && !other.node.info) || (node.info && other.node.info && *node.info == *other.node.info));
    }

private:
    internal::meta_type_node node;
    const meta_ctx *ctx;
};

/**
 * @brief Checks if two objects refer to the same type.
 * @param lhs An object, either valid or not.
 * @param rhs An object, either valid or not.
 * @return False if the objects refer to the same node, true otherwise.
 */
[[nodiscard]] inline bool operator!=(const meta_type &lhs, const meta_type &rhs) noexcept {
    return !(lhs == rhs);
}

[[nodiscard]] inline meta_type meta_any::type() const noexcept {
    return node.info ? meta_type{*ctx, node} : meta_type{};
}

template<typename... Args>
meta_any meta_any::invoke(const id_type id, Args &&...args) const {
    return type().invoke(id, *this, std::forward<Args>(args)...);
}

template<typename... Args>
meta_any meta_any::invoke(const id_type id, Args &&...args) {
    return type().invoke(id, *this, std::forward<Args>(args)...);
}

template<typename Type>
bool meta_any::set(const id_type id, Type &&value) {
    return type().set(id, *this, std::forward<Type>(value));
}

[[nodiscard]] inline meta_any meta_any::get(const id_type id) const {
    return type().get(id, *this);
}

[[nodiscard]] inline meta_any meta_any::get(const id_type id) {
    return type().get(id, *this);
}

[[nodiscard]] inline meta_any meta_any::allow_cast(const meta_type &type) const {
    if(node.info && *node.info == type.info()) {
        return as_ref();
    }

    if(const auto *value = data(); node.details) {
        if(auto it = node.details->conv.find(type.info().hash()); it != node.details->conv.cend()) {
            return it->second.conv(*ctx, data());
        }

        for(auto &&curr: node.details->base) {
            const auto &as_const = curr.second.type(internal::meta_context::from(*ctx)).from_void(*ctx, nullptr, curr.second.cast(value));

            if(auto other = as_const.allow_cast(type); other) {
                return other;
            }
        }
    }

    if(node.conversion_helper && (type.is_arithmetic() || type.is_enum())) {
        // exploits the fact that arithmetic types and enums are also default constructible
        auto other = type.construct();
        ENTT_ASSERT(other.node.conversion_helper, "Conversion helper not found");
        const auto value = node.conversion_helper(nullptr, storage.data());
        other.node.conversion_helper(other.storage.data(), &value);
        return other;
    }

    return meta_any{meta_ctx_arg, *ctx};
}

inline bool meta_any::assign(const meta_any &other) {
    auto value = other.allow_cast({*ctx, node});
    return value && storage.assign(std::move(value.storage));
}

inline bool meta_any::assign(meta_any &&other) {
    if(*node.info == *other.node.info) {
        return storage.assign(std::move(other.storage));
    }

    return assign(std::as_const(other));
}

[[nodiscard]] inline meta_type meta_data::type() const noexcept {
    return meta_type{*ctx, node->type(internal::meta_context::from(*ctx))};
}

[[nodiscard]] inline meta_type meta_data::arg(const size_type index) const noexcept {
    return index < arity() ? node->arg(*ctx, index) : meta_type{};
}

[[nodiscard]] inline meta_type meta_func::ret() const noexcept {
    return meta_type{*ctx, node->ret(internal::meta_context::from(*ctx))};
}

[[nodiscard]] inline meta_type meta_func::arg(const size_type index) const noexcept {
    return index < arity() ? node->arg(*ctx, index) : meta_type{};
}

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

class meta_sequence_container::meta_iterator final {
    friend class meta_sequence_container;

    enum class operation : std::uint8_t {
        incr,
        deref
    };

    using vtable_type = void(const operation, const any &, const std::ptrdiff_t, meta_any *);

    template<typename It>
    static void basic_vtable(const operation op, const any &value, const std::ptrdiff_t offset, meta_any *other) {
        switch(op) {
        case operation::incr: {
            auto &it = any_cast<It &>(const_cast<any &>(value));
            it = std::next(it, offset);
        } break;
        case operation::deref: {
            const auto &it = any_cast<const It &>(value);
            other->emplace<decltype(*it)>(*it);
        } break;
        }
    }

public:
    using difference_type = std::ptrdiff_t;
    using value_type = meta_any;
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using iterator_category = std::input_iterator_tag;

    constexpr meta_iterator() noexcept
        : ctx{},
          vtable{},
          handle{} {}

    template<typename It>
    explicit meta_iterator(const meta_ctx &area, It iter) noexcept
        : ctx{&area},
          vtable{&basic_vtable<It>},
          handle{iter} {}

    meta_iterator &operator++() noexcept {
        vtable(operation::incr, handle, 1, nullptr);
        return *this;
    }

    meta_iterator operator++(int value) noexcept {
        meta_iterator orig = *this;
        vtable(operation::incr, handle, ++value, nullptr);
        return orig;
    }

    meta_iterator &operator--() noexcept {
        vtable(operation::incr, handle, -1, nullptr);
        return *this;
    }

    meta_iterator operator--(int value) noexcept {
        meta_iterator orig = *this;
        vtable(operation::incr, handle, --value, nullptr);
        return orig;
    }

    [[nodiscard]] reference operator*() const {
        reference other{meta_ctx_arg, *ctx};
        vtable(operation::deref, handle, 0, &other);
        return other;
    }

    [[nodiscard]] pointer operator->() const {
        return operator*();
    }

    [[nodiscard]] explicit operator bool() const noexcept {
        return static_cast<bool>(handle);
    }

    [[nodiscard]] bool operator==(const meta_iterator &other) const noexcept {
        return handle == other.handle;
    }

    [[nodiscard]] bool operator!=(const meta_iterator &other) const noexcept {
        return !(*this == other);
    }

private:
    const meta_ctx *ctx;
    vtable_type *vtable;
    any handle;
};

class meta_associative_container::meta_iterator final {
    enum class operation : std::uint8_t {
        incr,
        deref
    };

    using vtable_type = void(const operation, const any &, std::pair<meta_any, meta_any> *);

    template<bool KeyOnly, typename It>
    static void basic_vtable(const operation op, const any &value, std::pair<meta_any, meta_any> *other) {
        switch(op) {
        case operation::incr:
            ++any_cast<It &>(const_cast<any &>(value));
            break;
        case operation::deref:
            const auto &it = any_cast<const It &>(value);
            if constexpr(KeyOnly) {
                other->first.emplace<decltype(*it)>(*it);
            } else {
                other->first.emplace<decltype((it->first))>(it->first);
                other->second.emplace<decltype((it->second))>(it->second);
            }
            break;
        }
    }

public:
    using difference_type = std::ptrdiff_t;
    using value_type = std::pair<meta_any, meta_any>;
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using iterator_category = std::input_iterator_tag;

    constexpr meta_iterator() noexcept
        : ctx{},
          vtable{},
          handle{} {}

    template<bool KeyOnly, typename It>
    meta_iterator(const meta_ctx &area, std::integral_constant<bool, KeyOnly>, It iter) noexcept
        : ctx{&area},
          vtable{&basic_vtable<KeyOnly, It>},
          handle{iter} {}

    meta_iterator &operator++() noexcept {
        vtable(operation::incr, handle, nullptr);
        return *this;
    }

    meta_iterator operator++(int) noexcept {
        meta_iterator orig = *this;
        return ++(*this), orig;
    }

    [[nodiscard]] reference operator*() const {
        reference other{{meta_ctx_arg, *ctx}, {meta_ctx_arg, *ctx}};
        vtable(operation::deref, handle, &other);
        return other;
    }

    [[nodiscard]] pointer operator->() const {
        return operator*();
    }

    [[nodiscard]] explicit operator bool() const noexcept {
        return static_cast<bool>(handle);
    }

    [[nodiscard]] bool operator==(const meta_iterator &other) const noexcept {
        return handle == other.handle;
    }

    [[nodiscard]] bool operator!=(const meta_iterator &other) const noexcept {
        return !(*this == other);
    }

private:
    const meta_ctx *ctx;
    vtable_type *vtable;
    any handle;
};

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Returns the meta value type of a container.
 * @return The meta value type of the container.
 */
[[nodiscard]] inline meta_type meta_sequence_container::value_type() const noexcept {
    return value_type_node ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
}

/**
 * @brief Returns the size of a container.
 * @return The size of the container.
 */
[[nodiscard]] inline meta_sequence_container::size_type meta_sequence_container::size() const noexcept {
    return size_fn(storage);
}

/**
 * @brief Resizes a container to contain a given number of elements.
 * @param sz The new size of the container.
 * @return True in case of success, false otherwise.
 */
inline bool meta_sequence_container::resize(const size_type sz) {
    return resize_fn(storage, sz);
}

/**
 * @brief Clears the content of a container.
 * @return True in case of success, false otherwise.
 */
inline bool meta_sequence_container::clear() {
    return resize_fn(storage, 0u);
}

/**
 * @brief Returns an iterator to the first element of a container.
 * @return An iterator to the first element of the container.
 */
[[nodiscard]] inline meta_sequence_container::iterator meta_sequence_container::begin() {
    return iter_fn(*ctx, storage, false);
}

/**
 * @brief Returns an iterator that is past the last element of a container.
 * @return An iterator that is past the last element of the container.
 */
[[nodiscard]] inline meta_sequence_container::iterator meta_sequence_container::end() {
    return iter_fn(*ctx, storage, true);
}

/**
 * @brief Inserts an element at a specified location of a container.
 * @param it Iterator before which the element will be inserted.
 * @param value Element value to insert.
 * @return A possibly invalid iterator to the inserted element.
 */
inline meta_sequence_container::iterator meta_sequence_container::insert(iterator it, meta_any value) {
    return insert_or_erase_fn(*ctx, storage, it.handle, value);
}

/**
 * @brief Removes a given element from a container.
 * @param it Iterator to the element to remove.
 * @return A possibly invalid iterator following the last removed element.
 */
inline meta_sequence_container::iterator meta_sequence_container::erase(iterator it) {
    return insert(it, {});
}

/**
 * @brief Returns a reference to the element at a given location of a container
 * (no bounds checking is performed).
 * @param pos The position of the element to return.
 * @return A reference to the requested element properly wrapped.
 */
[[nodiscard]] inline meta_any meta_sequence_container::operator[](const size_type pos) {
    auto it = begin();
    it.operator++(static_cast<int>(pos) - 1);
    return *it;
}

/**
 * @brief Returns false if a proxy is invalid, true otherwise.
 * @return False if the proxy is invalid, true otherwise.
 */
[[nodiscard]] inline meta_sequence_container::operator bool() const noexcept {
    return static_cast<bool>(storage);
}

/**
 * @brief Returns true if a container is also key-only, false otherwise.
 * @return True if the associative container is also key-only, false otherwise.
 */
[[nodiscard]] inline bool meta_associative_container::key_only() const noexcept {
    return key_only_container;
}

/**
 * @brief Returns the meta key type of a container.
 * @return The meta key type of the a container.
 */
[[nodiscard]] inline meta_type meta_associative_container::key_type() const noexcept {
    return key_type_node ? meta_type{*ctx, key_type_node(internal::meta_context::from(*ctx))} : meta_type{};
}

/**
 * @brief Returns the meta mapped type of a container.
 * @return The meta mapped type of the a container.
 */
[[nodiscard]] inline meta_type meta_associative_container::mapped_type() const noexcept {
    return mapped_type_node ? meta_type{*ctx, mapped_type_node(internal::meta_context::from(*ctx))} : meta_type{};
}

/*! @copydoc meta_sequence_container::value_type */
[[nodiscard]] inline meta_type meta_associative_container::value_type() const noexcept {
    return value_type_node ? meta_type{*ctx, value_type_node(internal::meta_context::from(*ctx))} : meta_type{};
}

/*! @copydoc meta_sequence_container::size */
[[nodiscard]] inline meta_associative_container::size_type meta_associative_container::size() const noexcept {
    return size_fn(storage);
}

/*! @copydoc meta_sequence_container::clear */
inline bool meta_associative_container::clear() {
    return clear_fn(storage);
}

/*! @copydoc meta_sequence_container::begin */
[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::begin() {
    return iter_fn(*ctx, storage, false);
}

/*! @copydoc meta_sequence_container::end */
[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::end() {
    return iter_fn(*ctx, storage, true);
}

/**
 * @brief Inserts a key only element into a container.
 * @param key The key of the element to insert.
 * @return A bool denoting whether the insertion took place.
 */
inline bool meta_associative_container::insert(meta_any key) {
    meta_any value{*ctx, std::in_place_type<void>};
    return (insert_or_erase_fn(storage, key, value) != 0u);
}

/**
 * @brief Inserts a key/value element into a container.
 * @param key The key of the element to insert.
 * @param value The value of the element to insert.
 * @return A bool denoting whether the insertion took place.
 */
inline bool meta_associative_container::insert(meta_any key, meta_any value) {
    return (insert_or_erase_fn(storage, key, value) != 0u);
}

/**
 * @brief Removes the specified element from a container.
 * @param key The key of the element to remove.
 * @return A bool denoting whether the removal took place.
 */
inline meta_associative_container::size_type meta_associative_container::erase(meta_any key) {
    return insert(std::move(key), meta_any{meta_ctx_arg, *ctx});
}

/**
 * @brief Returns an iterator to the element with a given key, if any.
 * @param key The key of the element to search.
 * @return An iterator to the element with the given key, if any.
 */
[[nodiscard]] inline meta_associative_container::iterator meta_associative_container::find(meta_any key) {
    return find_fn(*ctx, storage, key);
}

/**
 * @brief Returns false if a proxy is invalid, true otherwise.
 * @return False if the proxy is invalid, true otherwise.
 */
[[nodiscard]] inline meta_associative_container::operator bool() const noexcept {
    return static_cast<bool>(storage);
}

} // namespace entt

#endif

////////////////////// END OF external/entt/meta/meta.hpp //////////////////////

/////////////////// START OF external/entt/meta/resolve.hpp ////////////////////

#ifndef ENTT_META_RESOLVE_HPP
#define ENTT_META_RESOLVE_HPP

#include <type_traits>

namespace entt {

/**
 * @brief Returns the meta type associated with a given type.
 * @tparam Type Type to use to search for a meta type.
 * @param ctx The context from which to search for meta types.
 * @return The meta type associated with the given type, if any.
 */
template<typename Type>
[[nodiscard]] meta_type resolve(const meta_ctx &ctx) noexcept {
    auto &&context = internal::meta_context::from(ctx);
    return {ctx, internal::resolve<std::remove_cv_t<std::remove_reference_t<Type>>>(context)};
}

/**
 * @brief Returns the meta type associated with a given type.
 * @tparam Type Type to use to search for a meta type.
 * @return The meta type associated with the given type, if any.
 */
template<typename Type>
[[nodiscard]] meta_type resolve() noexcept {
    return resolve<Type>(locator<meta_ctx>::value_or());
}

/**
 * @brief Returns a range to use to visit all meta types.
 * @param ctx The context from which to search for meta types.
 * @return An iterable range to use to visit all meta types.
 */
[[nodiscard]] inline meta_range<meta_type, typename decltype(internal::meta_context::value)::const_iterator> resolve(const meta_ctx &ctx) noexcept {
    auto &&context = internal::meta_context::from(ctx);
    return {{ctx, context.value.cbegin()}, {ctx, context.value.cend()}};
}

/**
 * @brief Returns a range to use to visit all meta types.
 * @return An iterable range to use to visit all meta types.
 */
[[nodiscard]] inline meta_range<meta_type, typename decltype(internal::meta_context::value)::const_iterator> resolve() noexcept {
    return resolve(locator<meta_ctx>::value_or());
}

/**
 * @brief Returns the meta type associated with a given identifier, if any.
 * @param ctx The context from which to search for meta types.
 * @param id Unique identifier.
 * @return The meta type associated with the given identifier, if any.
 */
[[nodiscard]] inline meta_type resolve(const meta_ctx &ctx, const id_type id) noexcept {
    for(auto &&curr: resolve(ctx)) {
        if(curr.second.id() == id) {
            return curr.second;
        }
    }

    return meta_type{};
}

/**
 * @brief Returns the meta type associated with a given identifier, if any.
 * @param id Unique identifier.
 * @return The meta type associated with the given identifier, if any.
 */
[[nodiscard]] inline meta_type resolve(const id_type id) noexcept {
    return resolve(locator<meta_ctx>::value_or(), id);
}

/**
 * @brief Returns the meta type associated with a given type info object.
 * @param ctx The context from which to search for meta types.
 * @param info The type info object of the requested type.
 * @return The meta type associated with the given type info object, if any.
 */
[[nodiscard]] inline meta_type resolve(const meta_ctx &ctx, const type_info &info) noexcept {
    auto &&context = internal::meta_context::from(ctx);
    const auto *elem = internal::try_resolve(context, info);
    return elem ? meta_type{ctx, *elem} : meta_type{};
}

/**
 * @brief Returns the meta type associated with a given type info object.
 * @param info The type info object of the requested type.
 * @return The meta type associated with the given type info object, if any.
 */
[[nodiscard]] inline meta_type resolve(const type_info &info) noexcept {
    return resolve(locator<meta_ctx>::value_or(), info);
}

} // namespace entt

#endif

//////////////////// END OF external/entt/meta/resolve.hpp /////////////////////

//////////////////////// START OF src/Types/Entity.hpp /////////////////////////

#include <vector>

namespace pokesim::types {
template <typename T, typename... Other>
using view = entt::view<entt::get_t<const T, const Other...>>;

using entity = entt::entity;

using ClonedEntityMap = entt::dense_map<entity, std::vector<entity>>;
}  // namespace pokesim::types

///////////////////////// END OF src/Types/Entity.hpp //////////////////////////

/////////////// START OF src/Components/EntityHolders/Battle.hpp ///////////////

namespace pokesim {
// Contains the entity of a simulation's battle.
struct Battle {
  types::entity val{};
};
}  // namespace pokesim

//////////////// END OF src/Components/EntityHolders/Battle.hpp ////////////////

//////////////////////// START OF src/Config/Config.hpp ////////////////////////

#ifdef POKESIM_ENABLE_TESTING
#define POKESIM_TESTING
#endif

#if !defined(NDEBUG) || defined(POKESIM_TESTING)
#define POKESIM_DEBUG_CHECK_UTILITIES
#endif

///////////////////////// END OF src/Config/Config.hpp /////////////////////////

///////////// START OF src/Components/EntityHolders/BattleTree.hpp /////////////

namespace pokesim {
struct ParentBattle {
  types::entity val{};
};

struct RootBattle {
  types::entity val{};
};

#ifdef POKESIM_DEBUG_CHECK_UTILITIES
struct ParentEntity {
  types::entity val{};
};
#endif
}  // namespace pokesim

////////////// END OF src/Components/EntityHolders/BattleTree.hpp //////////////

/////////////////////// START OF src/Config/Require.hpp ////////////////////////

// NOLINTBEGIN cppcoreguidelines-macro-usage
#ifdef POKESIM_DEBUG_CHECK_UTILITIES
#include <cstdint>
#include <cstring>
#include <stdexcept>

namespace pokesim::debug {
class require : public std::exception {
  std::string errorMessage;

 public:
  static inline uint64_t count = 0;

  require(const char* file, int line, const char* function, const char* condition, const std::string& message) {
    errorMessage += file;
    errorMessage += ":" + std::to_string(line);

    errorMessage += "  ";
    errorMessage += function;
    errorMessage += "  ( ";
    errorMessage += condition;
    errorMessage += " )";

    if (!message.empty()) {
      errorMessage += "  \" ";
      errorMessage += message;
      errorMessage += " \"";
    }
  }

  virtual const char* what() const noexcept override { return errorMessage.c_str(); }
};
}  // namespace pokesim::debug

#if defined __clang__ || defined __GNUC__
#define POKESIM_ASSERT(condition, message) \
  pokesim::debug::require::count++;        \
  if (!(condition)) throw pokesim::debug::require(__FILE__, __LINE__, __PRETTY_FUNCTION__, #condition, message);
#elif defined _MSC_VER
#define POKESIM_ASSERT(condition, message) \
  pokesim::debug::require::count++;        \
  if (!(condition)) throw pokesim::debug::require(__FILE__, __LINE__, __FUNCSIG__, #condition, message);
#endif

#else
#define POKESIM_ASSERT(condition, message)
#endif

// An assert with no message. For use in debug checks only.
#define POKESIM_ASSERT_NM(condition) POKESIM_ASSERT(condition, "")
#define POKESIM_ASSERT_FAIL(message) POKESIM_ASSERT(false, message)
// NOLINTEND cppcoreguidelines-macro-usage

//////////////////////// END OF src/Config/Require.hpp /////////////////////////

//////////////////// START OF external/entt/meta/policy.hpp ////////////////////

#ifndef ENTT_META_POLICY_HPP
#define ENTT_META_POLICY_HPP

#include <type_traits>

namespace entt {

/*! @brief Empty class type used to request the _as ref_ policy. */
struct as_ref_t final {
    /**
     * @cond TURN_OFF_DOXYGEN
     * Internal details not to be documented.
     */
    template<typename Type>
    static constexpr bool value = std::is_reference_v<Type> && !std::is_const_v<std::remove_reference_t<Type>>;
    /**
     * Internal details not to be documented.
     * @endcond
     */
};

/*! @brief Empty class type used to request the _as cref_ policy. */
struct as_cref_t final {
    /**
     * @cond TURN_OFF_DOXYGEN
     * Internal details not to be documented.
     */
    template<typename Type>
    static constexpr bool value = std::is_reference_v<Type>;
    /**
     * Internal details not to be documented.
     * @endcond
     */
};

/*! @brief Empty class type used to request the _as-is_ policy. */
struct as_is_t final {
    /**
     * @cond TURN_OFF_DOXYGEN
     * Internal details not to be documented.
     */
    template<typename>
    static constexpr bool value = true;
    /**
     * Internal details not to be documented.
     * @endcond
     */
};

/*! @brief Empty class type used to request the _as void_ policy. */
struct as_void_t final {
    /**
     * @cond TURN_OFF_DOXYGEN
     * Internal details not to be documented.
     */
    template<typename>
    static constexpr bool value = true;
    /**
     * Internal details not to be documented.
     * @endcond
     */
};

/**
 * @brief Provides the member constant `value` to true if a type also is a meta
 * policy, false otherwise.
 * @tparam Type Type to check.
 */
template<typename Type>
struct is_meta_policy
    : std::bool_constant<std::is_same_v<Type, as_ref_t> || std::is_same_v<Type, as_cref_t> || std::is_same_v<Type, as_is_t> || std::is_same_v<Type, as_void_t>> {};

/**
 * @brief Helper variable template.
 * @tparam Type Type to check.
 */
template<typename Type>
inline constexpr bool is_meta_policy_v = is_meta_policy<Type>::value;

} // namespace entt

#endif

///////////////////// END OF external/entt/meta/policy.hpp /////////////////////

/////////////////// START OF external/entt/meta/utility.hpp ////////////////////

#ifndef ENTT_META_UTILITY_HPP
#define ENTT_META_UTILITY_HPP

#include <cstddef>
#include <functional>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @brief Meta function descriptor traits.
 * @tparam Ret Function return type.
 * @tparam Args Function arguments.
 * @tparam Static Function staticness.
 * @tparam Const Function constness.
 */
template<typename Ret, typename Args, bool Static, bool Const>
struct meta_function_descriptor_traits {
    /*! @brief Meta function return type. */
    using return_type = Ret;
    /*! @brief Meta function arguments. */
    using args_type = Args;

    /*! @brief True if the meta function is static, false otherwise. */
    static constexpr bool is_static = Static;
    /*! @brief True if the meta function is const, false otherwise. */
    static constexpr bool is_const = Const;
};

/*! @brief Primary template isn't defined on purpose. */
template<typename, typename>
struct meta_function_descriptor;

/**
 * @brief Meta function descriptor.
 * @tparam Type Reflected type to which the meta function is associated.
 * @tparam Ret Function return type.
 * @tparam Class Actual owner of the member function.
 * @tparam Args Function arguments.
 */
template<typename Type, typename Ret, typename Class, typename... Args>
struct meta_function_descriptor<Type, Ret (Class::*)(Args...) const>
    : meta_function_descriptor_traits<
          Ret,
          std::conditional_t<std::is_base_of_v<Class, Type>, type_list<Args...>, type_list<const Class &, Args...>>,
          !std::is_base_of_v<Class, Type>,
          true> {};

/**
 * @brief Meta function descriptor.
 * @tparam Type Reflected type to which the meta function is associated.
 * @tparam Ret Function return type.
 * @tparam Class Actual owner of the member function.
 * @tparam Args Function arguments.
 */
template<typename Type, typename Ret, typename Class, typename... Args>
struct meta_function_descriptor<Type, Ret (Class::*)(Args...)>
    : meta_function_descriptor_traits<
          Ret,
          std::conditional_t<std::is_base_of_v<Class, Type>, type_list<Args...>, type_list<Class &, Args...>>,
          !std::is_base_of_v<Class, Type>,
          false> {};

/**
 * @brief Meta function descriptor.
 * @tparam Type Reflected type to which the meta data is associated.
 * @tparam Class Actual owner of the data member.
 * @tparam Ret Data member type.
 */
template<typename Type, typename Ret, typename Class>
struct meta_function_descriptor<Type, Ret Class::*>
    : meta_function_descriptor_traits<
          Ret &,
          std::conditional_t<std::is_base_of_v<Class, Type>, type_list<>, type_list<Class &>>,
          !std::is_base_of_v<Class, Type>,
          false> {};

/**
 * @brief Meta function descriptor.
 * @tparam Type Reflected type to which the meta function is associated.
 * @tparam Ret Function return type.
 * @tparam MaybeType First function argument.
 * @tparam Args Other function arguments.
 */
template<typename Type, typename Ret, typename MaybeType, typename... Args>
struct meta_function_descriptor<Type, Ret (*)(MaybeType, Args...)>
    : meta_function_descriptor_traits<
          Ret,
          std::conditional_t<
              std::is_same_v<std::remove_cv_t<std::remove_reference_t<MaybeType>>, Type> || std::is_base_of_v<std::remove_cv_t<std::remove_reference_t<MaybeType>>, Type>,
              type_list<Args...>,
              type_list<MaybeType, Args...>>,
          !(std::is_same_v<std::remove_cv_t<std::remove_reference_t<MaybeType>>, Type> || std::is_base_of_v<std::remove_cv_t<std::remove_reference_t<MaybeType>>, Type>),
          std::is_const_v<std::remove_reference_t<MaybeType>> && (std::is_same_v<std::remove_cv_t<std::remove_reference_t<MaybeType>>, Type> || std::is_base_of_v<std::remove_cv_t<std::remove_reference_t<MaybeType>>, Type>)> {};

/**
 * @brief Meta function descriptor.
 * @tparam Type Reflected type to which the meta function is associated.
 * @tparam Ret Function return type.
 */
template<typename Type, typename Ret>
struct meta_function_descriptor<Type, Ret (*)()>
    : meta_function_descriptor_traits<
          Ret,
          type_list<>,
          true,
          false> {};

/**
 * @brief Meta function helper.
 *
 * Converts a function type to be associated with a reflected type into its meta
 * function descriptor.
 *
 * @tparam Type Reflected type to which the meta function is associated.
 * @tparam Candidate The actual function to associate with the reflected type.
 */
template<typename Type, typename Candidate>
class meta_function_helper {
    template<typename Ret, typename... Args, typename Class>
    static constexpr meta_function_descriptor<Type, Ret (Class::*)(Args...) const> get_rid_of_noexcept(Ret (Class::*)(Args...) const);

    template<typename Ret, typename... Args, typename Class>
    static constexpr meta_function_descriptor<Type, Ret (Class::*)(Args...)> get_rid_of_noexcept(Ret (Class::*)(Args...));

    template<typename Ret, typename Class>
    static constexpr meta_function_descriptor<Type, Ret Class::*> get_rid_of_noexcept(Ret Class::*);

    template<typename Ret, typename... Args>
    static constexpr meta_function_descriptor<Type, Ret (*)(Args...)> get_rid_of_noexcept(Ret (*)(Args...));

    template<typename Class>
    static constexpr meta_function_descriptor<Class, decltype(&Class::operator())> get_rid_of_noexcept(Class);

public:
    /*! @brief The meta function descriptor of the given function. */
    using type = decltype(get_rid_of_noexcept(std::declval<Candidate>()));
};

/**
 * @brief Helper type.
 * @tparam Type Reflected type to which the meta function is associated.
 * @tparam Candidate The actual function to associate with the reflected type.
 */
template<typename Type, typename Candidate>
using meta_function_helper_t = typename meta_function_helper<Type, Candidate>::type;

/**
 * @brief Wraps a value depending on the given policy.
 *
 * This function always returns a wrapped value in the requested context.<br/>
 * Therefore, if the passed value is itself a wrapped object with a different
 * context, it undergoes a rebinding to the requested context.
 *
 * @tparam Policy Optional policy (no policy set by default).
 * @tparam Type Type of value to wrap.
 * @param ctx The context from which to search for meta types.
 * @param value Value to wrap.
 * @return A meta any containing the returned value, if any.
 */
template<typename Policy = as_is_t, typename Type>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_dispatch(const meta_ctx &ctx, [[maybe_unused]] Type &&value) {
    if constexpr(std::is_same_v<Policy, as_void_t>) {
        return meta_any{ctx, std::in_place_type<void>};
    } else if constexpr(std::is_same_v<Policy, as_ref_t>) {
        return meta_any{ctx, std::in_place_type<Type>, value};
    } else if constexpr(std::is_same_v<Policy, as_cref_t>) {
        static_assert(std::is_lvalue_reference_v<Type>, "Invalid type");
        return meta_any{ctx, std::in_place_type<const std::remove_reference_t<Type> &>, std::as_const(value)};
    } else {
        return meta_any{ctx, std::forward<Type>(value)};
    }
}

/**
 * @brief Wraps a value depending on the given policy.
 * @tparam Policy Optional policy (no policy set by default).
 * @tparam Type Type of value to wrap.
 * @param value Value to wrap.
 * @return A meta any containing the returned value, if any.
 */
template<typename Policy = as_is_t, typename Type>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_dispatch(Type &&value) {
    return meta_dispatch<Policy, Type>(locator<meta_ctx>::value_or(), std::forward<Type>(value));
}

/**
 * @brief Returns the meta type of the i-th element of a list of arguments.
 * @tparam Type Type list of the actual types of arguments.
 * @param ctx The context from which to search for meta types.
 * @param index The index of the element for which to return the meta type.
 * @return The meta type of the i-th element of the list of arguments.
 */
template<typename Type>
[[nodiscard]] static meta_type meta_arg(const meta_ctx &ctx, const std::size_t index) noexcept {
    auto &&context = internal::meta_context::from(ctx);
    return {ctx, internal::meta_arg_node(context, Type{}, index)};
}

/**
 * @brief Returns the meta type of the i-th element of a list of arguments.
 * @tparam Type Type list of the actual types of arguments.
 * @param index The index of the element for which to return the meta type.
 * @return The meta type of the i-th element of the list of arguments.
 */
template<typename Type>
[[nodiscard]] static meta_type meta_arg(const std::size_t index) noexcept {
    return meta_arg<Type>(locator<meta_ctx>::value_or(), index);
}

/**
 * @brief Sets the value of a given variable.
 * @tparam Type Reflected type to which the variable is associated.
 * @tparam Data The actual variable to set.
 * @param instance An opaque instance of the underlying type, if required.
 * @param value Parameter to use to set the variable.
 * @return True in case of success, false otherwise.
 */
template<typename Type, auto Data>
[[nodiscard]] bool meta_setter([[maybe_unused]] meta_handle instance, [[maybe_unused]] meta_any value) {
    if constexpr(!std::is_same_v<decltype(Data), Type> && !std::is_same_v<decltype(Data), std::nullptr_t>) {
        if constexpr(std::is_member_function_pointer_v<decltype(Data)> || std::is_function_v<std::remove_reference_t<std::remove_pointer_t<decltype(Data)>>>) {
            using descriptor = meta_function_helper_t<Type, decltype(Data)>;
            using data_type = type_list_element_t<descriptor::is_static, typename descriptor::args_type>;

            if(auto *const clazz = instance->try_cast<Type>(); clazz && value.allow_cast<data_type>()) {
                std::invoke(Data, *clazz, value.cast<data_type>());
                return true;
            }
        } else if constexpr(std::is_member_object_pointer_v<decltype(Data)>) {
            using data_type = std::remove_reference_t<typename meta_function_helper_t<Type, decltype(Data)>::return_type>;

            if constexpr(!std::is_array_v<data_type> && !std::is_const_v<data_type>) {
                if(auto *const clazz = instance->try_cast<Type>(); clazz && value.allow_cast<data_type>()) {
                    std::invoke(Data, *clazz) = value.cast<data_type>();
                    return true;
                }
            }
        } else {
            using data_type = std::remove_reference_t<decltype(*Data)>;

            if constexpr(!std::is_array_v<data_type> && !std::is_const_v<data_type>) {
                if(value.allow_cast<data_type>()) {
                    *Data = value.cast<data_type>();
                    return true;
                }
            }
        }
    }

    return false;
}

/**
 * @brief Gets the value of a given variable.
 *
 * @warning
 * The context provided is used only for the return type.<br/>
 * It's up to the caller to bind the arguments to the right context(s).
 *
 * @tparam Type Reflected type to which the variable is associated.
 * @tparam Data The actual variable to get.
 * @tparam Policy Optional policy (no policy set by default).
 * @param ctx The context from which to search for meta types.
 * @param instance An opaque instance of the underlying type, if required.
 * @return A meta any containing the value of the underlying variable.
 */
template<typename Type, auto Data, typename Policy = as_is_t>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_getter(const meta_ctx &ctx, [[maybe_unused]] meta_handle instance) {
    if constexpr(std::is_member_pointer_v<decltype(Data)> || std::is_function_v<std::remove_reference_t<std::remove_pointer_t<decltype(Data)>>>) {
        if constexpr(!std::is_array_v<std::remove_cv_t<std::remove_reference_t<std::invoke_result_t<decltype(Data), Type &>>>>) {
            if constexpr(std::is_invocable_v<decltype(Data), Type &>) {
                if(auto *clazz = instance->try_cast<Type>(); clazz) {
                    return meta_dispatch<Policy>(ctx, std::invoke(Data, *clazz));
                }
            }

            if constexpr(std::is_invocable_v<decltype(Data), const Type &>) {
                if(auto *fallback = instance->try_cast<const Type>(); fallback) {
                    return meta_dispatch<Policy>(ctx, std::invoke(Data, *fallback));
                }
            }
        }

        return meta_any{meta_ctx_arg, ctx};
    } else if constexpr(std::is_pointer_v<decltype(Data)>) {
        if constexpr(std::is_array_v<std::remove_pointer_t<decltype(Data)>>) {
            return meta_any{meta_ctx_arg, ctx};
        } else {
            return meta_dispatch<Policy>(ctx, *Data);
        }
    } else {
        return meta_dispatch<Policy>(ctx, Data);
    }
}

/**
 * @brief Gets the value of a given variable.
 * @tparam Type Reflected type to which the variable is associated.
 * @tparam Data The actual variable to get.
 * @tparam Policy Optional policy (no policy set by default).
 * @param instance An opaque instance of the underlying type, if required.
 * @return A meta any containing the value of the underlying variable.
 */
template<typename Type, auto Data, typename Policy = as_is_t>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_getter(meta_handle instance) {
    return meta_getter<Type, Data, Policy>(locator<meta_ctx>::value_or(), std::move(instance));
}

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename Policy, typename Candidate, typename... Args>
[[nodiscard]] meta_any meta_invoke_with_args(const meta_ctx &ctx, Candidate &&candidate, Args &&...args) {
    if constexpr(std::is_same_v<decltype(std::invoke(std::forward<Candidate>(candidate), args...)), void>) {
        std::invoke(std::forward<Candidate>(candidate), args...);
        return meta_any{ctx, std::in_place_type<void>};
    } else {
        return meta_dispatch<Policy>(ctx, std::invoke(std::forward<Candidate>(candidate), args...));
    }
}

template<typename Type, typename Policy, typename Candidate, std::size_t... Index>
[[nodiscard]] meta_any meta_invoke(const meta_ctx &ctx, [[maybe_unused]] meta_handle instance, Candidate &&candidate, [[maybe_unused]] meta_any *args, std::index_sequence<Index...>) {
    using descriptor = meta_function_helper_t<Type, std::remove_reference_t<Candidate>>;

    if constexpr(std::is_invocable_v<std::remove_reference_t<Candidate>, const Type &, type_list_element_t<Index, typename descriptor::args_type>...>) {
        if(const auto *const clazz = instance->try_cast<const Type>(); clazz && ((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) {
            return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), *clazz, (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
        }
    } else if constexpr(std::is_invocable_v<std::remove_reference_t<Candidate>, Type &, type_list_element_t<Index, typename descriptor::args_type>...>) {
        if(auto *const clazz = instance->try_cast<Type>(); clazz && ((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) {
            return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), *clazz, (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
        }
    } else {
        if(((args + Index)->allow_cast<type_list_element_t<Index, typename descriptor::args_type>>() && ...)) {
            return meta_invoke_with_args<Policy>(ctx, std::forward<Candidate>(candidate), (args + Index)->cast<type_list_element_t<Index, typename descriptor::args_type>>()...);
        }
    }

    return meta_any{meta_ctx_arg, ctx};
}

template<typename Type, typename... Args, std::size_t... Index>
[[nodiscard]] meta_any meta_construct(const meta_ctx &ctx, meta_any *const args, std::index_sequence<Index...>) {
    if(((args + Index)->allow_cast<Args>() && ...)) {
        return meta_any{ctx, std::in_place_type<Type>, (args + Index)->cast<Args>()...};
    }

    return meta_any{meta_ctx_arg, ctx};
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Tries to _invoke_ an object given a list of erased parameters.
 *
 * @warning
 * The context provided is used only for the return type.<br/>
 * It's up to the caller to bind the arguments to the right context(s).
 *
 * @tparam Type Reflected type to which the object to _invoke_ is associated.
 * @tparam Policy Optional policy (no policy set by default).
 * @param ctx The context from which to search for meta types.
 * @tparam Candidate The type of the actual object to _invoke_.
 * @param instance An opaque instance of the underlying type, if required.
 * @param candidate The actual object to _invoke_.
 * @param args Parameters to use to _invoke_ the object.
 * @return A meta any containing the returned value, if any.
 */
template<typename Type, typename Policy = as_is_t, typename Candidate>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_invoke(const meta_ctx &ctx, meta_handle instance, Candidate &&candidate, meta_any *const args) {
    return internal::meta_invoke<Type, Policy>(ctx, std::move(instance), std::forward<Candidate>(candidate), args, std::make_index_sequence<meta_function_helper_t<Type, std::remove_reference_t<Candidate>>::args_type::size>{});
}

/**
 * @brief Tries to _invoke_ an object given a list of erased parameters.
 * @tparam Type Reflected type to which the object to _invoke_ is associated.
 * @tparam Policy Optional policy (no policy set by default).
 * @tparam Candidate The type of the actual object to _invoke_.
 * @param instance An opaque instance of the underlying type, if required.
 * @param candidate The actual object to _invoke_.
 * @param args Parameters to use to _invoke_ the object.
 * @return A meta any containing the returned value, if any.
 */
template<typename Type, typename Policy = as_is_t, typename Candidate>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_invoke(meta_handle instance, Candidate &&candidate, meta_any *const args) {
    return meta_invoke<Type, Policy>(locator<meta_ctx>::value_or(), std::move(instance), std::forward<Candidate>(candidate), args);
}

/**
 * @brief Tries to invoke a function given a list of erased parameters.
 *
 * @warning
 * The context provided is used only for the return type.<br/>
 * It's up to the caller to bind the arguments to the right context(s).
 *
 * @tparam Type Reflected type to which the function is associated.
 * @tparam Candidate The actual function to invoke.
 * @tparam Policy Optional policy (no policy set by default).
 * @param ctx The context from which to search for meta types.
 * @param instance An opaque instance of the underlying type, if required.
 * @param args Parameters to use to invoke the function.
 * @return A meta any containing the returned value, if any.
 */
template<typename Type, auto Candidate, typename Policy = as_is_t>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_invoke(const meta_ctx &ctx, meta_handle instance, meta_any *const args) {
    return internal::meta_invoke<Type, Policy>(ctx, std::move(instance), Candidate, args, std::make_index_sequence<meta_function_helper_t<Type, std::remove_reference_t<decltype(Candidate)>>::args_type::size>{});
}

/**
 * @brief Tries to invoke a function given a list of erased parameters.
 * @tparam Type Reflected type to which the function is associated.
 * @tparam Candidate The actual function to invoke.
 * @tparam Policy Optional policy (no policy set by default).
 * @param instance An opaque instance of the underlying type, if required.
 * @param args Parameters to use to invoke the function.
 * @return A meta any containing the returned value, if any.
 */
template<typename Type, auto Candidate, typename Policy = as_is_t>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_invoke(meta_handle instance, meta_any *const args) {
    return meta_invoke<Type, Candidate, Policy>(locator<meta_ctx>::value_or(), std::move(instance), args);
}

/**
 * @brief Tries to construct an instance given a list of erased parameters.
 *
 * @warning
 * The context provided is used only for the return type.<br/>
 * It's up to the caller to bind the arguments to the right context(s).
 *
 * @tparam Type Actual type of the instance to construct.
 * @tparam Args Types of arguments expected.
 * @param ctx The context from which to search for meta types.
 * @param args Parameters to use to construct the instance.
 * @return A meta any containing the new instance, if any.
 */
template<typename Type, typename... Args>
[[nodiscard]] meta_any meta_construct(const meta_ctx &ctx, meta_any *const args) {
    return internal::meta_construct<Type, Args...>(ctx, args, std::index_sequence_for<Args...>{});
}

/**
 * @brief Tries to construct an instance given a list of erased parameters.
 * @tparam Type Actual type of the instance to construct.
 * @tparam Args Types of arguments expected.
 * @param args Parameters to use to construct the instance.
 * @return A meta any containing the new instance, if any.
 */
template<typename Type, typename... Args>
[[nodiscard]] meta_any meta_construct(meta_any *const args) {
    return meta_construct<Type, Args...>(locator<meta_ctx>::value_or(), args);
}

/**
 * @brief Tries to construct an instance given a list of erased parameters.
 *
 * @warning
 * The context provided is used only for the return type.<br/>
 * It's up to the caller to bind the arguments to the right context(s).
 *
 * @tparam Type Reflected type to which the object to _invoke_ is associated.
 * @tparam Policy Optional policy (no policy set by default).
 * @tparam Candidate The type of the actual object to _invoke_.
 * @param ctx The context from which to search for meta types.
 * @param candidate The actual object to _invoke_.
 * @param args Parameters to use to _invoke_ the object.
 * @return A meta any containing the returned value, if any.
 */
template<typename Type, typename Policy = as_is_t, typename Candidate>
[[nodiscard]] meta_any meta_construct(const meta_ctx &ctx, Candidate &&candidate, meta_any *const args) {
    if constexpr(meta_function_helper_t<Type, Candidate>::is_static || std::is_class_v<std::remove_cv_t<std::remove_reference_t<Candidate>>>) {
        return internal::meta_invoke<Type, Policy>(ctx, {}, std::forward<Candidate>(candidate), args, std::make_index_sequence<meta_function_helper_t<Type, std::remove_reference_t<Candidate>>::args_type::size>{});
    } else {
        return internal::meta_invoke<Type, Policy>(ctx, *args, std::forward<Candidate>(candidate), args + 1u, std::make_index_sequence<meta_function_helper_t<Type, std::remove_reference_t<Candidate>>::args_type::size>{});
    }
}

/**
 * @brief Tries to construct an instance given a list of erased parameters.
 * @tparam Type Reflected type to which the object to _invoke_ is associated.
 * @tparam Policy Optional policy (no policy set by default).
 * @tparam Candidate The type of the actual object to _invoke_.
 * @param candidate The actual object to _invoke_.
 * @param args Parameters to use to _invoke_ the object.
 * @return A meta any containing the returned value, if any.
 */
template<typename Type, typename Policy = as_is_t, typename Candidate>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_construct(Candidate &&candidate, meta_any *const args) {
    return meta_construct<Type, Policy>(locator<meta_ctx>::value_or(), std::forward<Candidate>(candidate), args);
}

/**
 * @brief Tries to construct an instance given a list of erased parameters.
 *
 * @warning
 * The context provided is used only for the return type.<br/>
 * It's up to the caller to bind the arguments to the right context(s).
 *
 * @tparam Type Reflected type to which the function is associated.
 * @tparam Candidate The actual function to invoke.
 * @tparam Policy Optional policy (no policy set by default).
 * @param ctx The context from which to search for meta types.
 * @param args Parameters to use to invoke the function.
 * @return A meta any containing the returned value, if any.
 */
template<typename Type, auto Candidate, typename Policy = as_is_t>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_construct(const meta_ctx &ctx, meta_any *const args) {
    return meta_construct<Type, Policy>(ctx, Candidate, args);
}

/**
 * @brief Tries to construct an instance given a list of erased parameters.
 * @tparam Type Reflected type to which the function is associated.
 * @tparam Candidate The actual function to invoke.
 * @tparam Policy Optional policy (no policy set by default).
 * @param args Parameters to use to invoke the function.
 * @return A meta any containing the returned value, if any.
 */
template<typename Type, auto Candidate, typename Policy = as_is_t>
[[nodiscard]] std::enable_if_t<is_meta_policy_v<Policy>, meta_any> meta_construct(meta_any *const args) {
    return meta_construct<Type, Candidate, Policy>(locator<meta_ctx>::value_or(), args);
}

} // namespace entt

#endif

//////////////////// END OF external/entt/meta/utility.hpp /////////////////////

/////////////////// START OF external/entt/meta/factory.hpp ////////////////////

#ifndef ENTT_META_FACTORY_HPP
#define ENTT_META_FACTORY_HPP

#include <cstddef>
#include <functional>
#include <memory>
#include <tuple>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

[[nodiscard]] inline decltype(auto) owner(meta_ctx &ctx, const type_info &info) {
    auto &&context = internal::meta_context::from(ctx);
    ENTT_ASSERT(context.value.contains(info.hash()), "Type not available");
    return context.value[info.hash()];
}

inline meta_data_node &meta_extend(internal::meta_type_node &parent, const id_type id, meta_data_node node) {
    return parent.details->data.insert_or_assign(id, std::move(node)).first->second;
}

inline meta_func_node &meta_extend(internal::meta_type_node &parent, const id_type id, meta_func_node node) {
    if(auto it = parent.details->func.find(id); it != parent.details->func.end()) {
        for(auto *curr = &it->second; curr; curr = curr->next.get()) {
            if(curr->invoke == node.invoke) {
                node.next = std::move(curr->next);
                *curr = std::move(node);
                return *curr;
            }
        }

        // locally overloaded function
        node.next = std::make_shared<meta_func_node>(std::move(parent.details->func[id]));
    }

    return parent.details->func.insert_or_assign(id, std::move(node)).first->second;
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Basic meta factory to be used for reflection purposes.
 * @tparam Type Reflected type for which the factory was created.
 */
template<typename Type>
class meta_factory {
    template<typename Setter, auto Getter, typename Policy, std::size_t... Index>
    void data(const id_type id, std::index_sequence<Index...>) noexcept {
        using data_type = std::invoke_result_t<decltype(Getter), Type &>;
        using args_type = type_list<typename meta_function_helper_t<Type, decltype(value_list_element_v<Index, Setter>)>::args_type...>;
        static_assert(Policy::template value<data_type>, "Invalid return type for the given policy");

        auto &&elem = internal::meta_extend(
            internal::owner(*ctx, *info),
            id,
            internal::meta_data_node{
                /* this is never static */
                (std::is_member_object_pointer_v<decltype(value_list_element_v<Index, Setter>)> && ... && std::is_const_v<std::remove_reference_t<data_type>>) ? internal::meta_traits::is_const : internal::meta_traits::is_none,
                Setter::size,
                &internal::resolve<std::remove_cv_t<std::remove_reference_t<data_type>>>,
                &meta_arg<type_list<type_list_element_t<type_list_element_t<Index, args_type>::size != 1u, type_list_element_t<Index, args_type>>...>>,
                +[](meta_handle instance, meta_any value) { return (meta_setter<Type, value_list_element_v<Index, Setter>>(*instance.operator->(), value.as_ref()) || ...); },
                &meta_getter<Type, Getter, Policy>});

        bucket = &elem.prop;
    }

public:
    /*! @brief Default constructor. */
    meta_factory() noexcept
        : meta_factory{locator<meta_ctx>::value_or()} {}

    /**
     * @brief Context aware constructor.
     * @param area The context into which to construct meta types.
     */
    meta_factory(meta_ctx &area) noexcept
        : ctx{&area},
          bucket{},
          info{&type_id<Type>()} {
        auto &&elem = internal::owner(*ctx, *info);

        if(!elem.details) {
            elem.details = std::make_shared<internal::meta_type_descriptor>();
        }

        bucket = &elem.details->prop;
    }

    /**
     * @brief Assigns a custom unique identifier to a meta type.
     * @param id A custom unique identifier.
     * @return An extended meta factory for the given type.
     */
    auto type(const id_type id) noexcept {
        auto &&elem = internal::owner(*ctx, *info);
        ENTT_ASSERT(elem.id == id || !resolve(*ctx, id), "Duplicate identifier");
        bucket = &elem.details->prop;
        elem.id = id;
        return *this;
    }

    /**
     * @brief Assigns a meta base to a meta type.
     *
     * A reflected base class must be a real base class of the reflected type.
     *
     * @tparam Base Type of the base class to assign to the meta type.
     * @return A meta factory for the parent type.
     */
    template<typename Base>
    auto base() noexcept {
        static_assert(!std::is_same_v<Type, Base> && std::is_base_of_v<Base, Type>, "Invalid base type");
        auto *const op = +[](const void *instance) noexcept { return static_cast<const void *>(static_cast<const Base *>(static_cast<const Type *>(instance))); };
        internal::owner(*ctx, *info).details->base.insert_or_assign(type_id<Base>().hash(), internal::meta_base_node{&internal::resolve<Base>, op});
        bucket = nullptr;
        return *this;
    }

    /**
     * @brief Assigns a meta conversion function to a meta type.
     *
     * Conversion functions can be either free functions or member
     * functions.<br/>
     * In case of free functions, they must accept a const reference to an
     * instance of the parent type as an argument. In case of member functions,
     * they should have no arguments at all.
     *
     * @tparam Candidate The actual function to use for the conversion.
     * @return A meta factory for the parent type.
     */
    template<auto Candidate>
    auto conv() noexcept {
        using conv_type = std::remove_cv_t<std::remove_reference_t<std::invoke_result_t<decltype(Candidate), Type &>>>;
        auto *const op = +[](const meta_ctx &area, const void *instance) { return forward_as_meta(area, std::invoke(Candidate, *static_cast<const Type *>(instance))); };
        internal::owner(*ctx, *info).details->conv.insert_or_assign(type_id<conv_type>().hash(), internal::meta_conv_node{op});
        bucket = nullptr;
        return *this;
    }

    /**
     * @brief Assigns a meta conversion function to a meta type.
     *
     * The given type must be such that an instance of the reflected type can be
     * converted to it.
     *
     * @tparam To Type of the conversion function to assign to the meta type.
     * @return A meta factory for the parent type.
     */
    template<typename To>
    auto conv() noexcept {
        using conv_type = std::remove_cv_t<std::remove_reference_t<To>>;
        auto *const op = +[](const meta_ctx &area, const void *instance) { return forward_as_meta(area, static_cast<To>(*static_cast<const Type *>(instance))); };
        internal::owner(*ctx, *info).details->conv.insert_or_assign(type_id<conv_type>().hash(), internal::meta_conv_node{op});
        bucket = nullptr;
        return *this;
    }

    /**
     * @brief Assigns a meta constructor to a meta type.
     *
     * Both member functions and free function can be assigned to meta types in
     * the role of constructors. All that is required is that they return an
     * instance of the underlying type.<br/>
     * From a client's point of view, nothing changes if a constructor of a meta
     * type is a built-in one or not.
     *
     * @tparam Candidate The actual function to use as a constructor.
     * @tparam Policy Optional policy (no policy set by default).
     * @return An extended meta factory for the parent type.
     */
    template<auto Candidate, typename Policy = as_is_t>
    auto ctor() noexcept {
        using descriptor = meta_function_helper_t<Type, decltype(Candidate)>;
        static_assert(Policy::template value<typename descriptor::return_type>, "Invalid return type for the given policy");
        static_assert(std::is_same_v<std::remove_cv_t<std::remove_reference_t<typename descriptor::return_type>>, Type>, "The function doesn't return an object of the required type");
        internal::owner(*ctx, *info).details->ctor.insert_or_assign(type_id<typename descriptor::args_type>().hash(), internal::meta_ctor_node{descriptor::args_type::size, &meta_arg<typename descriptor::args_type>, &meta_construct<Type, Candidate, Policy>});
        bucket = nullptr;
        return *this;
    }

    /**
     * @brief Assigns a meta constructor to a meta type.
     *
     * A meta constructor is uniquely identified by the types of its arguments
     * and is such that there exists an actual constructor of the underlying
     * type that can be invoked with parameters whose types are those given.
     *
     * @tparam Args Types of arguments to use to construct an instance.
     * @return An extended meta factory for the parent type.
     */
    template<typename... Args>
    auto ctor() noexcept {
        // default constructor is already implicitly generated, no need for redundancy
        if constexpr(sizeof...(Args) != 0u) {
            using descriptor = meta_function_helper_t<Type, Type (*)(Args...)>;
            internal::owner(*ctx, *info).details->ctor.insert_or_assign(type_id<typename descriptor::args_type>().hash(), internal::meta_ctor_node{descriptor::args_type::size, &meta_arg<typename descriptor::args_type>, &meta_construct<Type, Args...>});
        }

        bucket = nullptr;
        return *this;
    }

    /**
     * @brief Assigns a meta destructor to a meta type.
     *
     * Both free functions and member functions can be assigned to meta types in
     * the role of destructors.<br/>
     * The signature of a free function should be identical to the following:
     *
     * @code{.cpp}
     * void(Type &);
     * @endcode
     *
     * Member functions should not take arguments instead.<br/>
     * The purpose is to give users the ability to free up resources that
     * require special treatment before an object is actually destroyed.
     *
     * @tparam Func The actual function to use as a destructor.
     * @return A meta factory for the parent type.
     */
    template<auto Func>
    auto dtor() noexcept {
        static_assert(std::is_invocable_v<decltype(Func), Type &>, "The function doesn't accept an object of the type provided");
        auto *const op = +[](void *instance) { std::invoke(Func, *static_cast<Type *>(instance)); };
        internal::owner(*ctx, *info).dtor = internal::meta_dtor_node{op};
        bucket = nullptr;
        return *this;
    }

    /**
     * @brief Assigns a meta data to a meta type.
     *
     * Both data members and static and global variables, as well as constants
     * of any kind, can be assigned to a meta type.<br/>
     * From a client's point of view, all the variables associated with the
     * reflected object will appear as if they were part of the type itself.
     *
     * @tparam Data The actual variable to attach to the meta type.
     * @tparam Policy Optional policy (no policy set by default).
     * @param id Unique identifier.
     * @return An extended meta factory for the parent type.
     */
    template<auto Data, typename Policy = as_is_t>
    auto data(const id_type id) noexcept {
        if constexpr(std::is_member_object_pointer_v<decltype(Data)>) {
            using data_type = std::invoke_result_t<decltype(Data), Type &>;
            static_assert(Policy::template value<data_type>, "Invalid return type for the given policy");

            auto &&elem = internal::meta_extend(
                internal::owner(*ctx, *info),
                id,
                internal::meta_data_node{
                    /* this is never static */
                    std::is_const_v<std::remove_reference_t<data_type>> ? internal::meta_traits::is_const : internal::meta_traits::is_none,
                    1u,
                    &internal::resolve<std::remove_cv_t<std::remove_reference_t<data_type>>>,
                    &meta_arg<type_list<std::remove_cv_t<std::remove_reference_t<data_type>>>>,
                    &meta_setter<Type, Data>,
                    &meta_getter<Type, Data, Policy>});

            bucket = &elem.prop;
        } else {
            using data_type = std::remove_pointer_t<decltype(Data)>;

            if constexpr(std::is_pointer_v<decltype(Data)>) {
                static_assert(Policy::template value<decltype(*Data)>, "Invalid return type for the given policy");
            } else {
                static_assert(Policy::template value<data_type>, "Invalid return type for the given policy");
            }

            auto &&elem = internal::meta_extend(
                internal::owner(*ctx, *info),
                id,
                internal::meta_data_node{
                    ((std::is_same_v<Type, std::remove_cv_t<std::remove_reference_t<data_type>>> || std::is_const_v<std::remove_reference_t<data_type>>) ? internal::meta_traits::is_const : internal::meta_traits::is_none) | internal::meta_traits::is_static,
                    1u,
                    &internal::resolve<std::remove_cv_t<std::remove_reference_t<data_type>>>,
                    &meta_arg<type_list<std::remove_cv_t<std::remove_reference_t<data_type>>>>,
                    &meta_setter<Type, Data>,
                    &meta_getter<Type, Data, Policy>});

            bucket = &elem.prop;
        }

        return *this;
    }

    /**
     * @brief Assigns a meta data to a meta type by means of its setter and
     * getter.
     *
     * Setters and getters can be either free functions, member functions or a
     * mix of them.<br/>
     * In case of free functions, setters and getters must accept a reference to
     * an instance of the parent type as their first argument. A setter has then
     * an extra argument of a type convertible to that of the parameter to
     * set.<br/>
     * In case of member functions, getters have no arguments at all, while
     * setters has an argument of a type convertible to that of the parameter to
     * set.
     *
     * @tparam Setter The actual function to use as a setter.
     * @tparam Getter The actual function to use as a getter.
     * @tparam Policy Optional policy (no policy set by default).
     * @param id Unique identifier.
     * @return An extended meta factory for the parent type.
     */
    template<auto Setter, auto Getter, typename Policy = as_is_t>
    auto data(const id_type id) noexcept {
        using data_type = std::invoke_result_t<decltype(Getter), Type &>;
        static_assert(Policy::template value<data_type>, "Invalid return type for the given policy");

        if constexpr(std::is_same_v<decltype(Setter), std::nullptr_t>) {
            auto &&elem = internal::meta_extend(
                internal::owner(*ctx, *info),
                id,
                internal::meta_data_node{
                    /* this is never static */
                    internal::meta_traits::is_const,
                    0u,
                    &internal::resolve<std::remove_cv_t<std::remove_reference_t<data_type>>>,
                    &meta_arg<type_list<>>,
                    &meta_setter<Type, Setter>,
                    &meta_getter<Type, Getter, Policy>});

            bucket = &elem.prop;
        } else {
            using args_type = typename meta_function_helper_t<Type, decltype(Setter)>::args_type;

            auto &&elem = internal::meta_extend(
                internal::owner(*ctx, *info),
                id,
                internal::meta_data_node{
                    /* this is never static nor const */
                    internal::meta_traits::is_none,
                    1u,
                    &internal::resolve<std::remove_cv_t<std::remove_reference_t<data_type>>>,
                    &meta_arg<type_list<type_list_element_t<args_type::size != 1u, args_type>>>,
                    &meta_setter<Type, Setter>,
                    &meta_getter<Type, Getter, Policy>});

            bucket = &elem.prop;
        }

        return *this;
    }

    /**
     * @brief Assigns a meta data to a meta type by means of its setters and
     * getter.
     *
     * Multi-setter support for meta data members. All setters are tried in the
     * order of definition before returning to the caller.<br/>
     * Setters can be either free functions, member functions or a mix of them
     * and are provided via a `value_list` type.
     *
     * @sa data
     *
     * @tparam Setter The actual functions to use as setters.
     * @tparam Getter The actual getter function.
     * @tparam Policy Optional policy (no policy set by default).
     * @param id Unique identifier.
     * @return An extended meta factory for the parent type.
     */
    template<typename Setter, auto Getter, typename Policy = as_is_t>
    auto data(const id_type id) noexcept {
        data<Setter, Getter, Policy>(id, std::make_index_sequence<Setter::size>{});
        return *this;
    }

    /**
     * @brief Assigns a meta function to a meta type.
     *
     * Both member functions and free functions can be assigned to a meta
     * type.<br/>
     * From a client's point of view, all the functions associated with the
     * reflected object will appear as if they were part of the type itself.
     *
     * @tparam Candidate The actual function to attach to the meta type.
     * @tparam Policy Optional policy (no policy set by default).
     * @param id Unique identifier.
     * @return An extended meta factory for the parent type.
     */
    template<auto Candidate, typename Policy = as_is_t>
    auto func(const id_type id) noexcept {
        using descriptor = meta_function_helper_t<Type, decltype(Candidate)>;
        static_assert(Policy::template value<typename descriptor::return_type>, "Invalid return type for the given policy");

        auto &&elem = internal::meta_extend(
            internal::owner(*ctx, *info),
            id,
            internal::meta_func_node{
                (descriptor::is_const ? internal::meta_traits::is_const : internal::meta_traits::is_none) | (descriptor::is_static ? internal::meta_traits::is_static : internal::meta_traits::is_none),
                descriptor::args_type::size,
                &internal::resolve<std::conditional_t<std::is_same_v<Policy, as_void_t>, void, std::remove_cv_t<std::remove_reference_t<typename descriptor::return_type>>>>,
                &meta_arg<typename descriptor::args_type>,
                &meta_invoke<Type, Candidate, Policy>});

        bucket = &elem.prop;
        return *this;
    }

    /**
     * @brief Assigns a property to the last meta object created.
     *
     * Both the key and the value (if any) must be at least copy constructible.
     *
     * @tparam Value Optional type of the property value.
     * @param id Property key.
     * @param value Optional property value.
     * @return An extended meta factory for the given type.
     */
    template<typename... Value>
    meta_factory prop(id_type id, [[maybe_unused]] Value &&...value) {
        ENTT_ASSERT(bucket != nullptr, "Meta object does not support properties");

        if constexpr(sizeof...(Value) == 0u) {
            (*bucket)[id] = internal::meta_prop_node{&internal::resolve<void>};
        } else {
            (*bucket)[id] = internal::meta_prop_node{
                &internal::resolve<std::decay_t<Value>>...,
                std::make_shared<std::decay_t<Value>>(std::forward<Value>(value))...};
        }

        return *this;
    }

private:
    meta_ctx *ctx;
    dense_map<id_type, internal::meta_prop_node, identity> *bucket;
    const type_info *info;
};

/**
 * @brief Utility function to use for reflection.
 *
 * This is the point from which everything starts.<br/>
 * By invoking this function with a type that is not yet reflected, a meta type
 * is created to which it will be possible to attach meta objects through a
 * dedicated factory.
 *
 * @tparam Type Type to reflect.
 * @param ctx The context into which to construct meta types.
 * @return A meta factory for the given type.
 */
template<typename Type>
[[nodiscard]] auto meta(meta_ctx &ctx) noexcept {
    auto &&context = internal::meta_context::from(ctx);
    // make sure the type exists in the context before returning a factory
    context.value.try_emplace(type_id<Type>().hash(), internal::resolve<Type>(context));
    return meta_factory<Type>{ctx};
}

/**
 * @brief Utility function to use for reflection.
 *
 * This is the point from which everything starts.<br/>
 * By invoking this function with a type that is not yet reflected, a meta type
 * is created to which it will be possible to attach meta objects through a
 * dedicated factory.
 *
 * @tparam Type Type to reflect.
 * @return A meta factory for the given type.
 */
template<typename Type>
[[nodiscard]] auto meta() noexcept {
    return meta<Type>(locator<meta_ctx>::value_or());
}

/**
 * @brief Resets a type and all its parts.
 *
 * Resets a type and all its data members, member functions and properties, as
 * well as its constructors, destructors and conversion functions if any.<br/>
 * Base classes aren't reset but the link between the two types is removed.
 *
 * The type is also removed from the set of searchable types.
 *
 * @param id Unique identifier.
 * @param ctx The context from which to reset meta types.
 */
inline void meta_reset(meta_ctx &ctx, const id_type id) noexcept {
    auto &&context = internal::meta_context::from(ctx);

    for(auto it = context.value.begin(); it != context.value.end();) {
        if(it->second.id == id) {
            it = context.value.erase(it);
        } else {
            ++it;
        }
    }
}

/**
 * @brief Resets a type and all its parts.
 *
 * Resets a type and all its data members, member functions and properties, as
 * well as its constructors, destructors and conversion functions if any.<br/>
 * Base classes aren't reset but the link between the two types is removed.
 *
 * The type is also removed from the set of searchable types.
 *
 * @param id Unique identifier.
 */
inline void meta_reset(const id_type id) noexcept {
    meta_reset(locator<meta_ctx>::value_or(), id);
}

/**
 * @brief Resets a type and all its parts.
 *
 * @sa meta_reset
 *
 * @tparam Type Type to reset.
 * @param ctx The context from which to reset meta types.
 */
template<typename Type>
void meta_reset(meta_ctx &ctx) noexcept {
    internal::meta_context::from(ctx).value.erase(type_id<Type>().hash());
}

/**
 * @brief Resets a type and all its parts.
 *
 * @sa meta_reset
 *
 * @tparam Type Type to reset.
 */
template<typename Type>
void meta_reset() noexcept {
    meta_reset<Type>(locator<meta_ctx>::value_or());
}

/**
 * @brief Resets all meta types.
 *
 * @sa meta_reset
 *
 * @param ctx The context from which to reset meta types.
 */
inline void meta_reset(meta_ctx &ctx) noexcept {
    internal::meta_context::from(ctx).value.clear();
}

/**
 * @brief Resets all meta types.
 *
 * @sa meta_reset
 */
inline void meta_reset() noexcept {
    meta_reset(locator<meta_ctx>::value_or());
}

} // namespace entt

#endif

//////////////////// END OF external/entt/meta/factory.hpp /////////////////////

/////////////// START OF src/Utilities/AssertComponentsEqual.hpp ///////////////

#ifdef POKESIM_DEBUG_CHECK_UTILITIES


namespace pokesim {
struct ParentEntity;
namespace types {
class registry;
}
namespace internal {
template <typename T, std::uint8_t N>
class maxSizedVector;
}
}  // namespace pokesim

namespace pokesim::debug {
struct TypesToIgnore : private entt::dense_set<entt::id_type> {
  TypesToIgnore() : entt::dense_set<entt::id_type>() { add<ParentEntity>(); }

  template <typename... Types>
  void add() {
    (emplace(entt::type_hash<Types>()), ...);
  }

  using entt::dense_set<entt::id_type>::contains;
};

inline types::entity createEntityCopy(types::entity entity, const types::registry& src, types::registry& dst);

inline void hasSameComponents(
  const types::registry& currReg, types::entity currEntity, const types::registry& initReg, types::entity initEntity,
  const TypesToIgnore& typesToIgnore = {});

inline void areEntitiesEqual(
  const types::registry& currReg, types::entity currEntity, const types::registry& initReg, types::entity initEntity,
  const TypesToIgnore& typesToIgnore = {});

inline types::entity findCopyParent(
  const entt::dense_map<types::entity, types::entity>& initialEntities, const types::registry& registry,
  types::entity entity);

inline bool checkIfCopyParent(types::entity current, types::entity initial, const types::registry& registry);

template <typename Type>
class AssertComponentsEqual {
  template <typename, typename = void>
  struct val : std::false_type {};
  template <typename T>
  struct val<T, std::void_t<decltype(T::val)>> : std::true_type {};

  template <typename, typename = void>
  struct name : std::false_type {};
  template <typename T>
  struct name<T, std::void_t<decltype(T::name)>> : std::true_type {};

  template <class, class = void>
  struct equals : std::false_type {};
  template <class T>
  struct equals<T, std::void_t<decltype(&T::operator==)>> : std::true_type {};

  template <typename T>
  using hasEqualTo = std::disjunction<equals<T>, std::is_scalar<T>>;

  template <typename>
  struct isList;
  template <typename T, std::uint8_t N>
  struct isList<internal::maxSizedVector<T, N>> {};
  template <typename... Args>
  struct isList<std::vector<Args...>> {};
  template <typename T, auto N>
  struct isList<std::array<T, N>> {};

  template <typename Member>
  static void compareMember(const Member& current, const Member& initial, const types::registry& registry) {
    if constexpr (std::is_same_v<types::entity, Member>) {
      if (current == initial) {
        return;
      }

      bool initialIsParent = checkIfCopyParent(current, initial, registry);
      bool currentIsParent = checkIfCopyParent(initial, current, registry);
      POKESIM_ASSERT_NM((initialIsParent && !currentIsParent));
    }
    else if constexpr (entt::is_complete_v<isList<Member>>) {
      POKESIM_ASSERT_NM(current.size() == initial.size());
      for (std::size_t i = 0; i < current.size(); i++) {
        compareMember(current[i], initial[i], registry);
      }
    }
    else if constexpr (hasEqualTo<Member>::value) {
      POKESIM_ASSERT_NM(current == initial);
    }
    else {
      // Not a static_assert so this only fails on types that actually get copied
      POKESIM_ASSERT_FAIL("There's a type that needs a dedicated equals function.");
    }
  }

 public:
  static void check(const Type& current, const Type& initial, const types::registry& registry) {
    if constexpr (hasEqualTo<Type>::value) {
      compareMember(current, initial, registry);
      return;
    }
    else if constexpr (val<Type>::value) {
      compareMember(current.val, initial.val, registry);
      if constexpr (sizeof(current.val) == sizeof(current)) {
        return;
      }
    }
    else if constexpr (name<Type>::value) {
      compareMember(current.name, initial.name, registry);
      if constexpr (sizeof(current.name) == sizeof(current)) {
        return;
      }
    }

    // Not a static_assert so this only fails on types that actually get copied
    POKESIM_ASSERT_FAIL("This component needs a dedicated equals function.");
  }
};
}  // namespace pokesim::debug

#endif

//////////////// END OF src/Utilities/AssertComponentsEqual.hpp ////////////////

/////////////////////// START OF src/Types/Registry.hpp ////////////////////////

#ifndef POKESIM_DEBUG_CHECK_UTILITIES
#include <memory>

#ifndef ENTT_ID_TYPE
#include <cstdint>
#define ENTT_ID_TYPE std::uint32_t
#endif

namespace entt {
enum class entity : ENTT_ID_TYPE;
template <typename, typename>
class basic_registry;
using registry = basic_registry<entity, std::allocator<entity> >;

template <typename, typename...>
struct basic_handle;
}  // namespace entt

namespace pokesim::types {
using registry = entt::registry;
using handle = entt::basic_handle<registry>;
}  // namespace pokesim::types
#else

#include <type_traits>

namespace pokesim::types::internal {
using BackingRegistry = entt::registry;
template <typename Registry>
using BackingHandle = entt::basic_handle<Registry>;
}  // namespace pokesim::types::internal
#endif

namespace pokesim::types {
class registry : public internal::BackingRegistry {
 public:
  enum MetaFunctions : entt::id_type {
    COPY_TO_OTHER_REGISTRY,
    ENTITY_COMPONENTS_EQUAL,
  };

 private:
  using entt::registry::emplace;
  using entt::registry::emplace_or_replace;
  using entt::registry::get_or_emplace;
  using entt::registry::insert;

  template <typename Type>
  static void copyToOtherRegistry(
    const registry* srcReg, types::entity srcEntity, registry* dstReg, types::entity dstEntity) {
    if constexpr (std::is_empty_v<Type>) {
      dstReg->emplace<Type>(dstEntity);
    }
    else {
      const Type& value = srcReg->get<Type>(srcEntity);
      dstReg->emplace<Type>(dstEntity, value);
    }
  }

  template <typename Type>
  static void entityComponentsEqual(
    const registry* currReg, types::entity currEntity, const registry* initReg, types::entity initEntity) {
    if constexpr (!std::is_empty_v<Type>) {
      const Type& currValue = currReg->get<Type>(currEntity);
      const Type& initValue = initReg->get<Type>(initEntity);
      debug::AssertComponentsEqual<Type>::check(currValue, initValue, *currReg);
    }
  }

  template <typename Type>
  void createMetaFunctions() const {
    static_assert(std::is_class_v<Type>, "Only classes or structs should be added to an entity.");
    entt::meta<Type>()
      .template func<&registry::copyToOtherRegistry<Type> >(MetaFunctions::COPY_TO_OTHER_REGISTRY)
      .template func<&registry::entityComponentsEqual<Type> >(MetaFunctions::ENTITY_COMPONENTS_EQUAL);
  }

 public:
  template <typename Type, typename... Args>
  decltype(auto) emplace(const entity_type entt, Args&&... args) {
    createMetaFunctions<Type>();
    return entt::registry::emplace<Type>(entt, std::forward<Args>(args)...);
  }

  template <typename Type, typename... Args>
  decltype(auto) emplace_or_replace(const entity_type entt, Args&&... args) {
    createMetaFunctions<Type>();
    return entt::registry::emplace_or_replace<Type>(entt, std::forward<Args>(args)...);
  }

  template <typename Type, typename... Args>
  [[nodiscard]] decltype(auto) get_or_emplace(const entity_type entt, Args&&... args) {
    createMetaFunctions<Type>();
    return entt::registry::get_or_emplace<Type>(entt, std::forward<Args>(args)...);
  }

  template <typename Type, typename It>
  void insert(It first, It last, const Type& value = {}) {
    createMetaFunctions<Type>();
    entt::registry::insert<Type>(std::move(first), std::move(last), value);
  }

  template <
    typename Type, typename EIt, typename CIt,
    typename = std::enable_if_t<std::is_same_v<typename std::iterator_traits<CIt>::value_type, Type> > >
  void insert(EIt first, EIt last, CIt from) {
    createMetaFunctions<Type>();
    entt::registry::insert<Type>(first, last, from);
  }
};

using handle = internal::BackingHandle<registry>;
}  // namespace pokesim::types

//////////////////////// END OF src/Types/Registry.hpp /////////////////////////

/////////////// START OF src/Utilities/AssertComponentsEqual.cpp ///////////////

#ifdef POKESIM_DEBUG_CHECK_UTILITIES

#include <vector>


namespace pokesim::debug {
inline types::entity createEntityCopy(types::entity entity, const types::registry& src, types::registry& dst) {
  types::entity dstEntity = dst.create();
  for (auto [id, storage] : src.storage()) {
    if (storage.contains(entity)) {
      entt::resolve(storage.type())
        .invoke(types::registry::MetaFunctions::COPY_TO_OTHER_REGISTRY, {}, &src, entity, &dst, dstEntity);
    }
  }
  return dstEntity;
}

inline void hasSameComponents(
  const types::registry& currReg, types::entity currEntity, const types::registry& initReg, types::entity initEntity,
  const TypesToIgnore& typesToIgnore) {
  for (auto [id, currStorage] : currReg.storage()) {
    if (typesToIgnore.contains(id)) continue;

    if (currStorage.contains(currEntity)) {
      std::string typeName{currStorage.type().name()};
      const auto* const initStorage = initReg.storage(id);
      POKESIM_ASSERT(initStorage != nullptr, "The inital registry never contained this component: " + typeName);
      POKESIM_ASSERT(
        initStorage->contains(initEntity),
        "The inital registry doesn't contain the current's component: " + typeName);
    }
  }

  for (auto [id, initStorage] : initReg.storage()) {
    if (typesToIgnore.contains(id)) continue;

    if (initStorage.contains(initEntity)) {
      std::string typeName{initStorage.type().name()};
      const auto* const currStorage = currReg.storage(id);
      POKESIM_ASSERT(currStorage != nullptr, "The current registry never contained this component: " + typeName);
      POKESIM_ASSERT(
        currStorage->contains(currEntity),
        "The current registry doesn't contain the inital's component: " + typeName);
    }
  }
}

inline void areEntitiesEqual(
  const types::registry& currReg, types::entity currEntity, const types::registry& initReg, types::entity initEntity,
  const TypesToIgnore& typesToIgnore) {
  hasSameComponents(currReg, currEntity, initReg, initEntity, typesToIgnore);
  for (auto [id, storage] : currReg.storage()) {
    if (typesToIgnore.contains(id)) continue;

    if (storage.contains(currEntity)) {
      entt::resolve(storage.type())
        .invoke(
          types::registry::MetaFunctions::ENTITY_COMPONENTS_EQUAL,
          {},
          &currReg,
          currEntity,
          &initReg,
          initEntity);
    }
  }
}

inline types::entity findCopyParent(
  const entt::dense_map<types::entity, types::entity>& initialEntities, const types::registry& registry,
  types::entity entity) {
  if (initialEntities.contains(entity)) {
    return entity;
  }

  const ParentEntity* parentEntity = registry.try_get<ParentEntity>(entity);
  for (std::size_t i = 0; parentEntity != nullptr; i++) {
    if (i >= registry.storage<types::registry::entity_type>()->size()) {
      POKESIM_ASSERT_FAIL("A loop in the battle tree caused an infinite loop.");
    }

    for (auto [original, _] : initialEntities) {
      if (original == parentEntity->val) {
        return original;
      }
    }
    parentEntity = registry.try_get<ParentEntity>(parentEntity->val);
  }

  POKESIM_ASSERT_FAIL("Could not find original entity of a clone.");
}

inline bool checkIfCopyParent(types::entity current, types::entity initial, const types::registry& registry) {
  const ParentEntity* parentEntity = registry.try_get<ParentEntity>(current);
  for (std::size_t i = 0; parentEntity != nullptr; i++) {
    if (i >= registry.storage<types::registry::entity_type>()->size()) {
      POKESIM_ASSERT_FAIL("A loop in the battle tree caused an infinite loop.");
    }

    if (parentEntity->val == initial) {
      return true;
    }
    parentEntity = registry.try_get<ParentEntity>(parentEntity->val);
  }

  return false;
}
}  // namespace pokesim::debug

#endif

//////////////// END OF src/Utilities/AssertComponentsEqual.cpp ////////////////

/////////////////// START OF external/entt/entity/handle.hpp ///////////////////

#ifndef ENTT_ENTITY_HANDLE_HPP
#define ENTT_ENTITY_HANDLE_HPP

#include <iterator>
#include <tuple>
#include <type_traits>
#include <utility>

namespace entt {

/**
 * @cond TURN_OFF_DOXYGEN
 * Internal details not to be documented.
 */

namespace internal {

template<typename It>
class handle_storage_iterator final {
    template<typename Other>
    friend class handle_storage_iterator;

    using underlying_type = std::remove_reference_t<typename It::value_type::second_type>;
    using entity_type = typename underlying_type::entity_type;

public:
    using value_type = typename std::iterator_traits<It>::value_type;
    using pointer = input_iterator_pointer<value_type>;
    using reference = value_type;
    using difference_type = std::ptrdiff_t;
    using iterator_category = std::input_iterator_tag;

    constexpr handle_storage_iterator() noexcept
        : entt{null},
          it{},
          last{} {}

    constexpr handle_storage_iterator(entity_type value, It from, It to) noexcept
        : entt{value},
          it{from},
          last{to} {
        while(it != last && !it->second.contains(entt)) {
            ++it;
        }
    }

    constexpr handle_storage_iterator &operator++() noexcept {
        while(++it != last && !it->second.contains(entt)) {}
        return *this;
    }

    constexpr handle_storage_iterator operator++(int) noexcept {
        handle_storage_iterator orig = *this;
        return ++(*this), orig;
    }

    [[nodiscard]] constexpr reference operator*() const noexcept {
        return *it;
    }

    [[nodiscard]] constexpr pointer operator->() const noexcept {
        return operator*();
    }

    template<typename ILhs, typename IRhs>
    friend constexpr bool operator==(const handle_storage_iterator<ILhs> &, const handle_storage_iterator<IRhs> &) noexcept;

private:
    entity_type entt;
    It it;
    It last;
};

template<typename ILhs, typename IRhs>
[[nodiscard]] constexpr bool operator==(const handle_storage_iterator<ILhs> &lhs, const handle_storage_iterator<IRhs> &rhs) noexcept {
    return lhs.it == rhs.it;
}

template<typename ILhs, typename IRhs>
[[nodiscard]] constexpr bool operator!=(const handle_storage_iterator<ILhs> &lhs, const handle_storage_iterator<IRhs> &rhs) noexcept {
    return !(lhs == rhs);
}

} // namespace internal

/**
 * Internal details not to be documented.
 * @endcond
 */

/**
 * @brief Non-owning handle to an entity.
 *
 * Tiny wrapper around a registry and an entity.
 *
 * @tparam Registry Basic registry type.
 * @tparam Scope Types to which to restrict the scope of a handle.
 */
template<typename Registry, typename... Scope>
struct basic_handle {
    /*! @brief Type of registry accepted by the handle. */
    using registry_type = Registry;
    /*! @brief Underlying entity identifier. */
    using entity_type = typename registry_type::entity_type;
    /*! @brief Underlying version type. */
    using version_type = typename registry_type::version_type;
    /*! @brief Unsigned integer type. */
    using size_type = typename registry_type::size_type;

    /*! @brief Constructs an invalid handle. */
    basic_handle() noexcept
        : reg{},
          entt{null} {}

    /**
     * @brief Constructs a handle from a given registry and entity.
     * @param ref An instance of the registry class.
     * @param value A valid identifier.
     */
    basic_handle(registry_type &ref, entity_type value) noexcept
        : reg{&ref},
          entt{value} {}

    /**
     * @brief Returns an iterable object to use to _visit_ a handle.
     *
     * The iterable object returns a pair that contains the name and a reference
     * to the current storage.<br/>
     * Returned storage are those that contain the entity associated with the
     * handle.
     *
     * @return An iterable object to use to _visit_ the handle.
     */
    [[nodiscard]] auto storage() const noexcept {
        auto iterable = reg->storage();
        using iterator_type = internal::handle_storage_iterator<typename decltype(iterable)::iterator>;
        return iterable_adaptor{iterator_type{entt, iterable.begin(), iterable.end()}, iterator_type{entt, iterable.end(), iterable.end()}};
    }

    /**
     * @brief Constructs a const handle from a non-const one.
     * @tparam Other A valid entity type.
     * @tparam Args Scope of the handle to construct.
     * @return A const handle referring to the same registry and the same
     * entity.
     */
    template<typename Other, typename... Args>
    operator basic_handle<Other, Args...>() const noexcept {
        static_assert(std::is_same_v<Other, Registry> || std::is_same_v<std::remove_const_t<Other>, Registry>, "Invalid conversion between different handles");
        static_assert((sizeof...(Scope) == 0 || ((sizeof...(Args) != 0 && sizeof...(Args) <= sizeof...(Scope)) && ... && (type_list_contains_v<type_list<Scope...>, Args>))), "Invalid conversion between different handles");

        return reg ? basic_handle<Other, Args...>{*reg, entt} : basic_handle<Other, Args...>{};
    }

    /**
     * @brief Converts a handle to its underlying entity.
     * @return The contained identifier.
     */
    [[nodiscard]] operator entity_type() const noexcept {
        return entity();
    }

    /**
     * @brief Checks if a handle refers to non-null registry pointer and entity.
     * @return True if the handle refers to non-null registry and entity, false otherwise.
     */
    [[nodiscard]] explicit operator bool() const noexcept {
        return reg && reg->valid(entt);
    }

    /**
     * @brief Checks if a handle refers to a valid entity or not.
     * @return True if the handle refers to a valid entity, false otherwise.
     */
    [[nodiscard]] bool valid() const {
        return reg->valid(entt);
    }

    /**
     * @brief Returns a pointer to the underlying registry, if any.
     * @return A pointer to the underlying registry, if any.
     */
    [[nodiscard]] registry_type *registry() const noexcept {
        return reg;
    }

    /**
     * @brief Returns the entity associated with a handle.
     * @return The entity associated with the handle.
     */
    [[nodiscard]] entity_type entity() const noexcept {
        return entt;
    }

    /*! @brief Destroys the entity associated with a handle. */
    void destroy() {
        reg->destroy(std::exchange(entt, null));
    }

    /**
     * @brief Destroys the entity associated with a handle.
     * @param version A desired version upon destruction.
     */
    void destroy(const version_type version) {
        reg->destroy(std::exchange(entt, null), version);
    }

    /**
     * @brief Assigns the given component to a handle.
     * @tparam Component Type of component to create.
     * @tparam Args Types of arguments to use to construct the component.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the newly created component.
     */
    template<typename Component, typename... Args>
    decltype(auto) emplace(Args &&...args) const {
        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
        return reg->template emplace<Component>(entt, std::forward<Args>(args)...);
    }

    /**
     * @brief Assigns or replaces the given component for a handle.
     * @tparam Component Type of component to assign or replace.
     * @tparam Args Types of arguments to use to construct the component.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the newly created component.
     */
    template<typename Component, typename... Args>
    decltype(auto) emplace_or_replace(Args &&...args) const {
        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
        return reg->template emplace_or_replace<Component>(entt, std::forward<Args>(args)...);
    }

    /**
     * @brief Patches the given component for a handle.
     * @tparam Component Type of component to patch.
     * @tparam Func Types of the function objects to invoke.
     * @param func Valid function objects.
     * @return A reference to the patched component.
     */
    template<typename Component, typename... Func>
    decltype(auto) patch(Func &&...func) const {
        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
        return reg->template patch<Component>(entt, std::forward<Func>(func)...);
    }

    /**
     * @brief Replaces the given component for a handle.
     * @tparam Component Type of component to replace.
     * @tparam Args Types of arguments to use to construct the component.
     * @param args Parameters to use to initialize the component.
     * @return A reference to the component being replaced.
     */
    template<typename Component, typename... Args>
    decltype(auto) replace(Args &&...args) const {
        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
        return reg->template replace<Component>(entt, std::forward<Args>(args)...);
    }

    /**
     * @brief Removes the given components from a handle.
     * @tparam Component Types of components to remove.
     * @return The number of components actually removed.
     */
    template<typename... Component>
    size_type remove() const {
        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Component> && ...), "Invalid type");
        return reg->template remove<Component...>(entt);
    }

    /**
     * @brief Erases the given components from a handle.
     * @tparam Component Types of components to erase.
     */
    template<typename... Component>
    void erase() const {
        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Component> && ...), "Invalid type");
        reg->template erase<Component...>(entt);
    }

    /**
     * @brief Checks if a handle has all the given components.
     * @tparam Component Components for which to perform the check.
     * @return True if the handle has all the components, false otherwise.
     */
    template<typename... Component>
    [[nodiscard]] decltype(auto) all_of() const {
        return reg->template all_of<Component...>(entt);
    }

    /**
     * @brief Checks if a handle has at least one of the given components.
     * @tparam Component Components for which to perform the check.
     * @return True if the handle has at least one of the given components,
     * false otherwise.
     */
    template<typename... Component>
    [[nodiscard]] decltype(auto) any_of() const {
        return reg->template any_of<Component...>(entt);
    }

    /**
     * @brief Returns references to the given components for a handle.
     * @tparam Component Types of components to get.
     * @return References to the components owned by the handle.
     */
    template<typename... Component>
    [[nodiscard]] decltype(auto) get() const {
        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Component> && ...), "Invalid type");
        return reg->template get<Component...>(entt);
    }

    /**
     * @brief Returns a reference to the given component for a handle.
     * @tparam Component Type of component to get.
     * @tparam Args Types of arguments to use to construct the component.
     * @param args Parameters to use to initialize the component.
     * @return Reference to the component owned by the handle.
     */
    template<typename Component, typename... Args>
    [[nodiscard]] decltype(auto) get_or_emplace(Args &&...args) const {
        static_assert(((sizeof...(Scope) == 0) || ... || std::is_same_v<Component, Scope>), "Invalid type");
        return reg->template get_or_emplace<Component>(entt, std::forward<Args>(args)...);
    }

    /**
     * @brief Returns pointers to the given components for a handle.
     * @tparam Component Types of components to get.
     * @return Pointers to the components owned by the handle.
     */
    template<typename... Component>
    [[nodiscard]] auto try_get() const {
        static_assert(sizeof...(Scope) == 0 || (type_list_contains_v<type_list<Scope...>, Component> && ...), "Invalid type");
        return reg->template try_get<Component...>(entt);
    }

    /**
     * @brief Checks if a handle has components assigned.
     * @return True if the handle has no components assigned, false otherwise.
     */
    [[nodiscard]] bool orphan() const {
        return reg->orphan(entt);
    }

private:
    registry_type *reg;
    entity_type entt;
};

/**
 * @brief Compares two handles.
 * @tparam Args Scope of the first handle.
 * @tparam Other Scope of the second handle.
 * @param lhs A valid handle.
 * @param rhs A valid handle.
 * @return True if both handles refer to the same registry and the same
 * entity, false otherwise.
 */
template<typename... Args, typename... Other>
[[nodiscard]] bool operator==(const basic_handle<Args...> &lhs, const basic_handle<Other...> &rhs) noexcept {
    return lhs.registry() == rhs.registry() && lhs.entity() == rhs.entity();
}

/**
 * @brief Compares two handles.
 * @tparam Args Scope of the first handle.
 * @tparam Other Scope of the second handle.
 * @param lhs A valid handle.
 * @param rhs A valid handle.
 * @return False if both handles refer to the same registry and the same
 * entity, true otherwise.
 */
template<typename... Args, typename... Other>
[[nodiscard]] bool operator!=(const basic_handle<Args...> &lhs, const basic_handle<Other...> &rhs) noexcept {
    return !(lhs == rhs);
}

} // namespace entt

#endif

//////////////////// END OF external/entt/entity/handle.hpp ////////////////////

////////////////// START OF src/Types/Enums/PseudoWeather.hpp //////////////////

#include <cstdint>

namespace pokesim::dex {
enum class PseudoWeather : std::uint8_t {
  // clang-format off
  NO_PSEUDO_WEATHER = 0,
  // clang-format on
};
}  // namespace pokesim::dex

/////////////////// END OF src/Types/Enums/PseudoWeather.hpp ///////////////////

////////////////// START OF src/Types/Enums/SideCondition.hpp //////////////////

#include <cstdint>

namespace pokesim::dex {
enum class SideCondition : std::uint8_t {
  // clang-format off
  NO_SIDE_CONDITION = 0
  // clang-format on
};
}  // namespace pokesim::dex

/////////////////// END OF src/Types/Enums/SideCondition.hpp ///////////////////

///////////////////// START OF src/Types/Enums/Status.hpp //////////////////////

#include <cstdint>

namespace pokesim::dex {
// Pokemon status condition name
enum class Status : std::uint8_t {
  NO_STATUS = 0,
  BRN,
  FRZ,
  PAR,
  PSN,
  SLP,
  TOX,
  /*, FRB, DRO, */ STATUS_TOTAL,
};

static constexpr std::size_t TOTAL_STATUS_COUNT = (std::size_t)Status::STATUS_TOTAL;
}  // namespace pokesim::dex

////////////////////// END OF src/Types/Enums/Status.hpp ///////////////////////

///////////////////// START OF src/Types/Enums/Terrain.hpp /////////////////////

#include <cstdint>

namespace pokesim::dex {
enum class Terrain : std::uint8_t {
  // clang-format off
  NO_TERRAIN = 0
  // clang-format on
};
}  // namespace pokesim::dex

////////////////////// END OF src/Types/Enums/Terrain.hpp //////////////////////

//////////////////// START OF src/Types/Enums/Volatile.hpp /////////////////////

#include <cstdint>

namespace pokesim::dex {
enum class Volatile : std::uint8_t {
  // clang-format off
  NO_VOLATILE = 0,
  CHOICE_LOCK,
  // clang-format on
};
}  // namespace pokesim::dex

///////////////////// END OF src/Types/Enums/Volatile.hpp //////////////////////

///////////////////// START OF src/Types/Enums/Weather.hpp /////////////////////

#include <cstdint>

namespace pokesim::dex {
enum class Weather : std::uint8_t {
  // clang-format off
  NO_WEATHER = 0
  // clang-format on
};
}  // namespace pokesim::dex

////////////////////// END OF src/Types/Enums/Weather.hpp //////////////////////

////////////////////// START OF src/Utilities/Variant.hpp //////////////////////

#include <variant>

namespace pokesim::internal {
template <typename... Types>
class variant : public std::variant<Types...> {
 public:
  using std::variant<Types...>::variant;

  template <typename T>
  variant& operator=(T&& rhs) {
    std::variant<Types...>::operator=(rhs);
    return *this;
  }

  bool empty() const { return holds<std::monostate>(); }

  template <typename Type>
  bool holds() const {
    return std::holds_alternative<Type>(*this);
  }

  template <typename Type>
  auto& get() const {
    return std::get<Type>(*this);
  }

  template <typename Type>
  auto& get() {
    return std::get<Type>(*this);
  }
};
}  // namespace pokesim::internal

/////////////////////// END OF src/Utilities/Variant.hpp ///////////////////////

//////////////////////// START OF src/Types/Effect.hpp /////////////////////////

namespace pokesim::types {
using effectEnum = pokesim::internal::variant<
  std::monostate, dex::PseudoWeather, dex::SideCondition, dex::Status, dex::Terrain, dex::Volatile, dex::Weather>;
}  // namespace pokesim::types

///////////////////////// END OF src/Types/Effect.hpp //////////////////////////

////////////////////// START OF src/Types/Enums/Move.hpp ///////////////////////

#include <cstdint>

namespace pokesim::dex {
// Pokemon move name
enum class Move : std::uint16_t {
  // clang-format off
  NO_MOVE = 0, ONE_MILLION_VOLT_THUNDERBOLT, ABSORB, ACCELEROCK, ACID, ACID_ARMOR, ACID_DOWNPOUR, ACID_SPRAY, ACROBATICS, ACUPRESSURE, AERIAL_ACE, AEROBLAST, AFTER_YOU, AGILITY, AIR_CUTTER, AIR_SLASH, ALL_OUT_PUMMELING, ALLY_SWITCH, AMNESIA, ANCHOR_SHOT, ANCIENT_POWER, APPLE_ACID, AQUA_CUTTER, AQUA_JET, AQUA_RING, AQUA_STEP, AQUA_TAIL, ARMOR_CANNON, ARM_THRUST, AROMATHERAPY, AROMATIC_MIST, ASSIST, ASSURANCE, ASTONISH, ASTRAL_BARRAGE, ATTACK_ORDER, ATTRACT, AURA_SPHERE, AURA_WHEEL, AURORA_BEAM, AURORA_VEIL, AUTOTOMIZE, AVALANCHE, AXE_KICK, BABY_DOLL_EYES, BADDY_BAD, BANEFUL_BUNKER, BARB_BARRAGE, BARRAGE, BARRIER, BATON_PASS, BEAK_BLAST, BEAT_UP, BEHEMOTH_BASH, BEHEMOTH_BLADE, BELCH, BELLY_DRUM, BESTOW, BIDE, BIND, BITE, BITTER_BLADE, BITTER_MALICE, BLACK_HOLE_ECLIPSE, BLAST_BURN, BLAZE_KICK, BLAZING_TORQUE, BLEAKWIND_STORM, BLIZZARD, BLOCK, BLOOM_DOOM, BLUE_FLARE, BODY_PRESS, BODY_SLAM, BOLT_BEAK, BOLT_STRIKE, BONE_CLUB, BONEMERANG, BONE_RUSH, BOOMBURST, BOUNCE, BOUNCY_BUBBLE, BRANCH_POKE, BRAVE_BIRD, BREAKING_SWIPE, BREAKNECK_BLITZ, BRICK_BREAK, BRINE, BRUTAL_SWING, BUBBLE, BUBBLE_BEAM, BUG_BITE, BUG_BUZZ, BULK_UP, BULLDOZE, BULLET_PUNCH, BULLET_SEED, BURNING_JEALOUSY, BURN_UP, BUZZY_BUZZ, CALM_MIND, CAMOUFLAGE, CAPTIVATE, CATASTROPIKA, CEASELESS_EDGE, CELEBRATE, CHARGE, CHARGE_BEAM, CHARM, CHATTER, CHILLING_WATER, CHILLY_RECEPTION, CHIP_AWAY, CHLOROBLAST, CIRCLE_THROW, CLAMP, CLANGING_SCALES, CLANGOROUS_SOUL, CLANGOROUS_SOULBLAZE, CLEAR_SMOG, CLOSE_COMBAT, COACHING, COIL, COLLISION_COURSE, COMBAT_TORQUE, COMET_PUNCH, COMEUPPANCE, CONFIDE, CONFUSE_RAY, CONFUSION, CONSTRICT, CONTINENTAL_CRUSH, CONVERSION, CONVERSION_2, COPYCAT, CORE_ENFORCER, CORKSCREW_CRASH, CORROSIVE_GAS, COSMIC_POWER, COTTON_GUARD, COTTON_SPORE, COUNTER, COURT_CHANGE, COVET, CRABHAMMER, CRAFTY_SHIELD, CROSS_CHOP, CROSS_POISON, CRUNCH, CRUSH_CLAW, CRUSH_GRIP, CURSE, CUT, DARKEST_LARIAT, DARK_PULSE, DARK_VOID, DAZZLING_GLEAM, DECORATE, DEFEND_ORDER, DEFENSE_CURL, DEFOG, DESTINY_BOND, DETECT, DEVASTATING_DRAKE, DIAMOND_STORM, DIG, DISABLE, DISARMING_VOICE, DISCHARGE, DIRE_CLAW, DIVE, DIZZY_PUNCH, DOODLE, DOOM_DESIRE, DOUBLE_EDGE, DOUBLE_HIT, DOUBLE_IRON_BASH, DOUBLE_KICK, DOUBLE_SHOCK, DOUBLE_SLAP, DOUBLE_TEAM, DRACO_METEOR, DRAGON_ASCENT, DRAGON_BREATH, DRAGON_CLAW, DRAGON_DANCE, DRAGON_DARTS, DRAGON_ENERGY, DRAGON_HAMMER, DRAGON_PULSE, DRAGON_RAGE, DRAGON_RUSH, DRAGON_TAIL, DRAINING_KISS, DRAIN_PUNCH, DREAM_EATER, DRILL_PECK, DRILL_RUN, DRUM_BEATING, DUAL_CHOP, DUAL_WINGBEAT, DYNAMAX_CANNON, DYNAMIC_PUNCH, EARTH_POWER, EARTHQUAKE, ECHOED_VOICE, EERIE_IMPULSE, EERIE_SPELL, EGG_BOMB, ELECTRIC_TERRAIN, ELECTRIFY, ELECTRO_BALL, ELECTRO_DRIFT, ELECTROWEB, EMBARGO, EMBER, ENCORE, ENDEAVOR, ENDURE, ENERGY_BALL, ENTRAINMENT, ERUPTION, ESPER_WING, ETERNABEAM, EXPANDING_FORCE, EXPLOSION, EXTRASENSORY, EXTREME_EVOBOOST, EXTREME_SPEED, FACADE, FAIRY_LOCK, FAIRY_WIND, FAKE_OUT, FAKE_TEARS, FALSE_SURRENDER, FALSE_SWIPE, FEATHER_DANCE, FEINT, FEINT_ATTACK, FELL_STINGER, FIERY_DANCE, FIERY_WRATH, FILLET_AWAY, FINAL_GAMBIT, FIRE_BLAST, FIRE_FANG, FIRE_LASH, FIRE_PLEDGE, FIRE_PUNCH, FIRE_SPIN, FIRST_IMPRESSION, FISHIOUS_REND, FISSURE, FLAIL, FLAME_BURST, FLAME_CHARGE, FLAME_WHEEL, FLAMETHROWER, FLARE_BLITZ, FLASH, FLASH_CANNON, FLATTER, FLEUR_CANNON, FLING, FLIP_TURN, FLOATY_FALL, FLORAL_HEALING, FLOWER_SHIELD, FLOWER_TRICK, FLY, FLYING_PRESS, FOCUS_BLAST, FOCUS_ENERGY, FOCUS_PUNCH, FOLLOW_ME, FORCE_PALM, FORESIGHT, FORESTS_CURSE, FOUL_PLAY, FREEZE_DRY, FREEZE_SHOCK, FREEZING_GLARE, FREEZY_FROST, FRENZY_PLANT, FROST_BREATH, FRUSTRATION, FURY_ATTACK, FURY_CUTTER, FURY_SWIPES, FUSION_BOLT, FUSION_FLARE, FUTURE_SIGHT, GASTRO_ACID, GEAR_GRIND, GEAR_UP, GENESIS_SUPERNOVA, GEOMANCY, GIGA_DRAIN, GIGA_IMPACT, GIGATON_HAMMER, GIGAVOLT_HAVOC, GLACIAL_LANCE, GLACIATE, GLAIVE_RUSH, GLARE, GLITZY_GLOW, G_MAX_BEFUDDLE, G_MAX_CANNONADE, G_MAX_CENTIFERNO, G_MAX_CHI_STRIKE, G_MAX_CUDDLE, G_MAX_DEPLETION, G_MAX_DRUM_SOLO, G_MAX_FINALE, G_MAX_FIREBALL, G_MAX_FOAM_BURST, G_MAX_GOLD_RUSH, G_MAX_GRAVITAS, G_MAX_HYDROSNIPE, G_MAX_MALODOR, G_MAX_MELTDOWN, G_MAX_ONE_BLOW, G_MAX_RAPID_FLOW, G_MAX_REPLENISH, G_MAX_RESONANCE, G_MAX_SANDBLAST, G_MAX_SMITE, G_MAX_SNOOZE, G_MAX_STEELSURGE, G_MAX_STONESURGE, G_MAX_STUN_SHOCK, G_MAX_SWEETNESS, G_MAX_TARTNESS, G_MAX_TERROR, G_MAX_VINE_LASH, G_MAX_VOLCALITH, G_MAX_VOLT_CRASH, G_MAX_WILDFIRE, G_MAX_WIND_RAGE, GRASS_KNOT, GRASS_PLEDGE, GRASS_WHISTLE, GRASSY_GLIDE, GRASSY_TERRAIN, GRAV_APPLE, GRAVITY, GROWL, GROWTH, GRUDGE, GUARDIAN_OF_ALOLA, GUARD_SPLIT, GUARD_SWAP, GUILLOTINE, GUNK_SHOT, GUST, GYRO_BALL, HAIL, HAMMER_ARM, HAPPY_HOUR, HARDEN, HAZE, HEADBUTT, HEAD_CHARGE, HEADLONG_RUSH, HEAD_SMASH, HEAL_BELL, HEAL_BLOCK, HEALING_WISH, HEAL_ORDER, HEAL_PULSE, HEART_STAMP, HEART_SWAP, HEAT_CRASH, HEAT_WAVE, HEAVY_SLAM, HELPING_HAND, HEX, HIDDEN_POWER, HIDDEN_POWER_BUG, HIDDEN_POWER_DARK, HIDDEN_POWER_DRAGON, HIDDEN_POWER_ELECTRIC, HIDDEN_POWER_FIGHTING, HIDDEN_POWER_FIRE, HIDDEN_POWER_FLYING, HIDDEN_POWER_GHOST, HIDDEN_POWER_GRASS, HIDDEN_POWER_GROUND, HIDDEN_POWER_ICE, HIDDEN_POWER_POISON, HIDDEN_POWER_PSYCHIC, HIDDEN_POWER_ROCK, HIDDEN_POWER_STEEL, HIDDEN_POWER_WATER, HIGH_HORSEPOWER, HIGH_JUMP_KICK, HOLD_BACK, HOLD_HANDS, HONE_CLAWS, HORN_ATTACK, HORN_DRILL, HORN_LEECH, HOWL, HURRICANE, HYDRO_CANNON, HYDRO_PUMP, HYDRO_STEAM, HYDRO_VORTEX, HYPER_BEAM, HYPER_DRILL, HYPER_FANG, HYPERSPACE_FURY, HYPERSPACE_HOLE, HYPER_VOICE, HYPNOSIS, ICE_BALL, ICE_BEAM, ICE_BURN, ICE_FANG, ICE_HAMMER, ICE_PUNCH, ICE_SHARD, ICE_SPINNER, ICICLE_CRASH, ICICLE_SPEAR, ICY_WIND, IMPRISON, INCINERATE, INFERNAL_PARADE, INFERNO, INFERNO_OVERDRIVE, INFESTATION, INGRAIN, INSTRUCT, ION_DELUGE, IRON_DEFENSE, IRON_HEAD, IRON_TAIL, JAW_LOCK, JET_PUNCH, JUDGMENT, JUMP_KICK, JUNGLE_HEALING, KARATE_CHOP, KINESIS, KINGS_SHIELD, KNOCK_OFF, KOWTOW_CLEAVE, LANDS_WRATH, LASER_FOCUS, LASH_OUT, LAST_RESORT, LAST_RESPECTS, LAVA_PLUME, LEAFAGE, LEAF_BLADE, LEAF_STORM, LEAF_TORNADO, LEECH_LIFE, LEECH_SEED, LEER, LETS_SNUGGLE_FOREVER, LICK, LIFE_DEW, LIGHT_OF_RUIN, LIGHT_SCREEN, LIGHT_THAT_BURNS_THE_SKY, LIQUIDATION, LOCK_ON, LOVELY_KISS, LOW_KICK, LOW_SWEEP, LUCKY_CHANT, LUMINA_CRASH, LUNAR_BLESSING, LUNAR_DANCE, LUNGE, LUSTER_PURGE, MACH_PUNCH, MAGICAL_LEAF, MAGICAL_TORQUE, MAGIC_COAT, MAGIC_POWDER, MAGIC_ROOM, MAGMA_STORM, MAGNET_BOMB, MAGNETIC_FLUX, MAGNET_RISE, MAGNITUDE, MAKE_IT_RAIN, MALICIOUS_MOONSAULT, MAT_BLOCK, MAX_AIRSTREAM, MAX_DARKNESS, MAX_FLARE, MAX_FLUTTERBY, MAX_GEYSER, MAX_GUARD, MAX_HAILSTORM, MAX_KNUCKLE, MAX_LIGHTNING, MAX_MINDSTORM, MAX_OOZE, MAX_OVERGROWTH, MAX_PHANTASM, MAX_QUAKE, MAX_ROCKFALL, MAX_STARFALL, MAX_STEELSPIKE, MAX_STRIKE, MAX_WYRMWIND, MEAN_LOOK, MEDITATE, ME_FIRST, MEGA_DRAIN, MEGAHORN, MEGA_KICK, MEGA_PUNCH, MEMENTO, MENACING_MOONRAZE_MAELSTROM, METAL_BURST, METAL_CLAW, METAL_SOUND, METEOR_ASSAULT, METEOR_BEAM, METEOR_MASH, METRONOME, MILK_DRINK, MIMIC, MIND_BLOWN, MIND_READER, MINIMIZE, MIRACLE_EYE, MIRROR_COAT, MIRROR_MOVE, MIRROR_SHOT, MIST, MIST_BALL, MISTY_EXPLOSION, MISTY_TERRAIN, MOONBLAST, MOONGEIST_BEAM, MOONLIGHT, MORNING_SUN, MORTAL_SPIN, MOUNTAIN_GALE, MUD_BOMB, MUD_SHOT, MUD_SLAP, MUD_SPORT, MUDDY_WATER, MULTI_ATTACK, MYSTICAL_FIRE, MYSTICAL_POWER, NASTY_PLOT, NATURAL_GIFT, NATURE_POWER, NATURES_MADNESS, NEEDLE_ARM, NEVER_ENDING_NIGHTMARE, NIGHT_DAZE, NIGHTMARE, NIGHT_SHADE, NIGHT_SLASH, NOBLE_ROAR, NO_RETREAT, NOXIOUS_TORQUE, NUZZLE, OBLIVION_WING, OBSTRUCT, OCEANIC_OPERETTA, OCTAZOOKA, OCTOLOCK, ODOR_SLEUTH, OMINOUS_WIND, ORDER_UP, ORIGIN_PULSE, OUTRAGE, OVERDRIVE, OVERHEAT, PAIN_SPLIT, PARABOLIC_CHARGE, PARTING_SHOT, PAYBACK, PAY_DAY, PECK, PERISH_SONG, PETAL_BLIZZARD, PETAL_DANCE, PHANTOM_FORCE, PHOTON_GEYSER, PIKA_PAPOW, PIN_MISSILE, PLASMA_FISTS, PLAY_NICE, PLAY_ROUGH, PLUCK, POISON_FANG, POISON_GAS, POISON_JAB, POISON_POWDER, POISON_STING, POISON_TAIL, POLLEN_PUFF, POLTERGEIST, POPULATION_BOMB, POUNCE, POUND, POWDER, POWDER_SNOW, POWER_GEM, POWER_SHIFT, POWER_SPLIT, POWER_SWAP, POWER_TRICK, POWER_TRIP, POWER_UP_PUNCH, POWER_WHIP, PRECIPICE_BLADES, PRESENT, PRISMATIC_LASER, PROTECT, PSYBEAM, PSYBLADE, PSYCH_UP, PSYCHIC, PSYCHIC_FANGS, PSYCHIC_TERRAIN, PSYCHO_BOOST, PSYCHO_CUT, PSYCHO_SHIFT, PSYSHIELD_BASH, PSYSHOCK, PSYSTRIKE, PSYWAVE, PULVERIZING_PANCAKE, PUNISHMENT, PURIFY, PURSUIT, PYRO_BALL, QUASH, QUICK_ATTACK, QUICK_GUARD, QUIVER_DANCE, RAGE, RAGE_FIST, RAGE_POWDER, RAGING_BULL, RAGING_FURY, RAIN_DANCE, RAPID_SPIN, RAZOR_LEAF, RAZOR_SHELL, RAZOR_WIND, RECOVER, RECYCLE, REFLECT, REFLECT_TYPE, REFRESH, RELIC_SONG, REST, RETALIATE, RETURN, REVELATION_DANCE, REVENGE, REVERSAL, REVIVAL_BLESSING, RISING_VOLTAGE, ROAR, ROAR_OF_TIME, ROCK_BLAST, ROCK_CLIMB, ROCK_POLISH, ROCK_SLIDE, ROCK_SMASH, ROCK_THROW, ROCK_TOMB, ROCK_WRECKER, ROLE_PLAY, ROLLING_KICK, ROLLOUT, ROOST, ROTOTILLER, ROUND, RUINATION, SACRED_FIRE, SACRED_SWORD, SAFEGUARD, SALT_CURE, SAND_ATTACK, SANDSEAR_STORM, SANDSTORM, SAND_TOMB, SAPPY_SEED, SAVAGE_SPIN_OUT, SCALD, SCALE_SHOT, SCARY_FACE, SCORCHING_SANDS, SCRATCH, SCREECH, SEARING_SHOT, SEARING_SUNRAZE_SMASH, SECRET_POWER, SECRET_SWORD, SEED_BOMB, SEED_FLARE, SEISMIC_TOSS, SELF_DESTRUCT, SHADOW_BALL, SHADOW_BONE, SHADOW_CLAW, SHADOW_FORCE, SHADOW_PUNCH, SHADOW_SNEAK, SHARPEN, SHATTERED_PSYCHE, SHED_TAIL, SHEER_COLD, SHELL_SIDE_ARM, SHELL_SMASH, SHELL_TRAP, SHELTER, SHIFT_GEAR, SHOCK_WAVE, SHORE_UP, SIGNAL_BEAM, SILK_TRAP, SILVER_WIND, SIMPLE_BEAM, SING_MOVE /*Many math libraries define SING as a macro*/, SINISTER_ARROW_RAID, SIZZLY_SLIDE, SKETCH, SKILL_SWAP, SKITTER_SMACK, SKULL_BASH, SKY_ATTACK, SKY_DROP, SKY_UPPERCUT, SLACK_OFF, SLAM, SLASH, SLEEP_POWDER, SLEEP_TALK, SLUDGE, SLUDGE_BOMB, SLUDGE_WAVE, SMACK_DOWN, SMART_STRIKE, SMELLING_SALTS, SMOG, SMOKESCREEN, SNAP_TRAP, SNARL, SNATCH, SNIPE_SHOT, SNORE, SNOWSCAPE, SOAK, SOFT_BOILED, SOLAR_BEAM, SOLAR_BLADE, SONIC_BOOM, SOUL_STEALING_7_STAR_STRIKE, SPACIAL_REND, SPARK, SPARKLING_ARIA, SPARKLY_SWIRL, SPECTRAL_THIEF, SPEED_SWAP, SPICY_EXTRACT, SPIDER_WEB, SPIKE_CANNON, SPIKES, SPIKY_SHIELD, SPIN_OUT, SPIRIT_BREAK, SPIRIT_SHACKLE, SPIT_UP, SPITE, SPLASH, SPLINTERED_STORMSHARDS, SPLISHY_SPLASH, SPORE, SPOTLIGHT, SPRINGTIDE_STORM, STEALTH_ROCK, STEAM_ERUPTION, STEAMROLLER, STEEL_BEAM, STEEL_ROLLER, STEEL_WING, STICKY_WEB, STOCKPILE, STOKED_SPARKSURFER, STOMP, STOMPING_TANTRUM, STONE_AXE, STONE_EDGE, STORED_POWER, STORM_THROW, STRANGE_STEAM, STRENGTH, STRENGTH_SAP, STRING_SHOT, STRUGGLE, STRUGGLE_BUG, STUFF_CHEEKS, STUN_SPORE, SUBMISSION, SUBSTITUTE, SUBZERO_SLAMMER, SUCKER_PUNCH, SUNNY_DAY, SUNSTEEL_STRIKE, SUPER_FANG, SUPERPOWER, SUPERSONIC, SUPERSONIC_SKYSTRIKE, SURF, SURGING_STRIKES, SWAGGER, SWALLOW, SWEET_KISS, SWEET_SCENT, SWIFT, SWITCHEROO, SWORDS_DANCE, SYNCHRONOISE, SYNTHESIS, TACKLE, TAIL_GLOW, TAIL_SLAP, TAIL_WHIP, TAILWIND, TAKE_DOWN, TAKE_HEART, TAR_SHOT, TAUNT, TEARFUL_LOOK, TEATIME, TECHNO_BLAST, TECTONIC_RAGE, TEETER_DANCE, TELEKINESIS, TELEPORT, TERA_BLAST, TERRAIN_PULSE, THIEF, THOUSAND_ARROWS, THOUSAND_WAVES, THRASH, THROAT_CHOP, THUNDER, THUNDERBOLT, THUNDER_CAGE, THUNDER_FANG, THUNDEROUS_KICK, THUNDER_PUNCH, THUNDER_SHOCK, THUNDER_WAVE, TICKLE, TIDY_UP, TOPSY_TURVY, TORCH_SONG, TORMENT, TOXIC, TOXIC_SPIKES, TOXIC_THREAD, TRAILBLAZE, TRANSFORM, TRI_ATTACK, TRICK, TRICK_OR_TREAT, TRICK_ROOM, TRIPLE_ARROWS, TRIPLE_AXEL, TRIPLE_DIVE, TRIPLE_KICK, TROP_KICK, TRUMP_CARD, TWIN_BEAM, TWINEEDLE, TWINKLE_TACKLE, TWISTER, U_TURN, UPROAR, VACUUM_WAVE, V_CREATE, VEEVEE_VOLLEY, VENOM_DRENCH, VENOSHOCK, VICTORY_DANCE, VINE_WHIP, VISE_GRIP, VITAL_THROW, VOLT_SWITCH, VOLT_TACKLE, WAKE_UP_SLAP, WATERFALL, WATER_GUN, WATER_PLEDGE, WATER_PULSE, WATER_SHURIKEN, WATER_SPORT, WATER_SPOUT, WAVE_CRASH, WEATHER_BALL, WHIRLPOOL, WHIRLWIND, WICKED_BLOW, WICKED_TORQUE, WIDE_GUARD, WILDBOLT_STORM, WILD_CHARGE, WILL_O_WISP, WING_ATTACK, WISH, WITHDRAW, WONDER_ROOM, WOOD_HAMMER, WORK_UP, WORRY_SEED, WRAP, WRING_OUT, X_SCISSOR, YAWN, ZAP_CANNON, ZEN_HEADBUTT, ZING_ZAP, ZIPPY_ZAP, MOVE_TOTAL,
  // clang-format on
};

static constexpr std::size_t TOTAL_MOVE_COUNT = (std::size_t)Move::MOVE_TOTAL;
}  // namespace pokesim::dex

/////////////////////// END OF src/Types/Enums/Move.hpp ////////////////////////

////////////////////// START OF src/Types/Enums/Stat.hpp ///////////////////////

#include <cstdint>

namespace pokesim::dex {
// Pokemon stat abbreviated name
enum class Stat : std::uint8_t {
  HP = 0b000001,
  ATK = 0b000010,
  DEF = 0b000100,
  SPA = 0b001000,
  SPD = 0b010000,
  SPE = 0b100000,
  // SPC = SPA | SPD,
};

static constexpr std::size_t TOTAL_STAT_COUNT = 6U;
}  // namespace pokesim::dex

/////////////////////// END OF src/Types/Enums/Stat.hpp ////////////////////////

///////////////////////// START OF src/Types/Stats.hpp /////////////////////////

#include <cstdint>

namespace pokesim::types {
using level = std::uint8_t;

using stat = std::uint16_t;
using baseStat = std::uint8_t;

using ev = std::uint8_t;
using iv = std::uint8_t;

using boost = std::int8_t;
}  // namespace pokesim::types

////////////////////////// END OF src/Types/Stats.hpp //////////////////////////

///////// START OF src/AnalyzeEffect/Setup/AnalyzeEffectInputSetup.hpp /////////

#include <vector>

namespace pokesim::analyze_effect {
struct InputSetup {
 protected:
  types::handle handle;

 public:
  inline InputSetup(types::registry& registry, types::entity entity);
  InputSetup(types::registry& registry) : InputSetup(registry, registry.create()) {}

  inline void setAttacker(types::entity entity);
  inline void setEffectTarget(types::entity entity);
  inline void setDefender(types::entity entity);
  inline void setEffectMoves(const std::vector<dex::Move>& moves);
  inline void setEffect(types::effectEnum effect);
  inline void setBoostEffect(dex::Stat stat, types::boost boost);
  inline void setBattle(types::entity entity);

  types::entity entity() const { return handle.entity(); }
};
}  // namespace pokesim::analyze_effect

////////// END OF src/AnalyzeEffect/Setup/AnalyzeEffectInputSetup.hpp //////////

////////////////////// START OF src/Types/Enums/Slot.hpp ///////////////////////

#include <cstdint>

namespace pokesim {
enum class Slot : std::uint8_t {
  NONE,
  P1A,
  P2A,
  P1B,
  P2B,

  P1C,
  P2C,
  P1D,
  P2D,
  P1E,
  P2E,
  P1F,
  P2F,
};
}

/////////////////////// END OF src/Types/Enums/Slot.hpp ////////////////////////

/////////////////// START OF src/Battle/Helpers/Helpers.hpp ////////////////////

namespace pokesim {
struct Sides;
struct MoveSlots;
class Pokedex;

inline types::entity slotToSideEntity(const Sides& sides, Slot targetSlot);
inline types::entity slotToPokemonEntity(const types::registry& registry, types::entity sideEntity, Slot targetSlot);
inline types::entity slotToPokemonEntity(const types::registry& registry, const Sides& sides, Slot targetSlot);
inline types::entity slotToAllyPokemonEntity(const types::registry& registry, const Sides& sides, Slot targetSlot);
inline types::entity moveToEntity(const types::registry& registry, const MoveSlots& moveSlots, dex::Move move);

inline types::entity createActionMoveForTarget(
  types::handle targetHandle, types::entity battleEntity, types::entity sourceEntity, dex::Move move,
  const Pokedex& pokedex);
}  // namespace pokesim

//////////////////// END OF src/Battle/Helpers/Helpers.hpp /////////////////////

///////////////// START OF src/Battle/Setup/StateSetupBase.hpp /////////////////

namespace pokesim::internal {
/**
 * @brief Class that holds the shared methods used between the various battle state setup tools.
 *
 * It is intended to be extended by classes that set up the state of a battle, such as StateSetupSide.
 */
struct StateSetupBase {
 protected:
  types::handle handle;

 public:
  StateSetupBase(types::registry& registry, types::entity entity) : handle(registry, entity) {}

  /**
   * @brief Sets a property on the entity.
   *
   * @tparam Tag The tag type of the property to set.
   */
  template <typename Tag>
  void setProperty() {
    handle.emplace<Tag>();
  }

  types::entity entity() const { return handle.entity(); }
};

}  // namespace pokesim::internal

////////////////// END OF src/Battle/Setup/StateSetupBase.hpp //////////////////

////////////////////// START OF src/Components/Boosts.hpp //////////////////////

namespace pokesim {
struct AtkBoost {
  types::boost val = 0;
};

struct DefBoost {
  types::boost val = 0;
};

struct SpaBoost {
  types::boost val = 0;
};

struct SpdBoost {
  types::boost val = 0;
};

struct SpeBoost {
  types::boost val = 0;
};
}  // namespace pokesim

/////////////////////// END OF src/Components/Boosts.hpp ///////////////////////

////////////////////// START OF src/Components/EVsIVs.hpp //////////////////////

namespace pokesim {
struct Evs {
  types::ev hp = 0;
  types::ev atk = 0;
  types::ev def = 0;
  types::ev spa = 0;
  types::ev spd = 0;
  types::ev spe = 0;

  bool operator==(const Evs& other) const {
    return hp == other.hp && atk == other.atk && def == other.def && spa == other.spa && spd == other.spd &&
           spe == other.spe;
  }
};

struct Ivs {
  types::iv hp = 0;
  types::iv atk = 0;
  types::iv def = 0;
  types::iv spa = 0;
  types::iv spd = 0;
  types::iv spe = 0;

  bool operator==(const Ivs& other) const {
    return hp == other.hp && atk == other.atk && def == other.def && spa == other.spa && spd == other.spd &&
           spe == other.spe;
  }
};
}  // namespace pokesim

/////////////////////// END OF src/Components/EVsIVs.hpp ///////////////////////

////////////////////// START OF src/Types/Enums/Type.hpp ///////////////////////

#include <cstdint>

namespace pokesim::dex {
// Pokemon type name
enum class Type : std::uint8_t {
  NO_TYPE = 0,
  NORMAL,
  GRASS,
  WATER,
  FIRE,
  BUG,
  FLYING,
  POISON,
  ELECTRIC,
  GROUND,
  FIGHTING,
  PSYCHIC,
  ROCK,
  ICE,
  GHOST,
  DRAGON,
  DARK,
  STEEL,
  FAIRY,
  TYPE_TOTAL
};

static constexpr std::size_t TOTAL_TYPE_COUNT = (std::size_t)Type::TYPE_TOTAL;
}  // namespace pokesim::dex

/////////////////////// END OF src/Types/Enums/Type.hpp ////////////////////////

/////////////////// START OF src/Components/SpeciesTypes.hpp ///////////////////

#include <array>

namespace pokesim {
// Contains the types a species has
struct SpeciesTypes {
  std::array<dex::Type, 2U> val{dex::Type::NO_TYPE, dex::Type::NO_TYPE};

  dex::Type& type1() { return val[0]; };
  dex::Type& type2() { return val[1]; };
  constexpr const dex::Type& type1() const { return val[0]; };
  constexpr const dex::Type& type2() const { return val[1]; };
  constexpr std::uint8_t size() const {
    return type2() == dex::Type::NO_TYPE ? type1() == dex::Type::NO_TYPE ? 0 : 1 : 2;
  }
  constexpr bool has(dex::Type type) const { return type1() == type || type2() == type; }
};
}  // namespace pokesim

//////////////////// END OF src/Components/SpeciesTypes.hpp ////////////////////

////////////////////// START OF src/Components/Stats.hpp ///////////////////////

namespace pokesim::stat {
struct Hp {
  types::stat val = 1;
};

struct Atk {
  types::stat val = 1;
};

struct Def {
  types::stat val = 1;
};

struct Spa {
  types::stat val = 1;
};

struct Spd {
  types::stat val = 1;
};

struct Spe {
  types::stat val = 1;
};

struct CurrentHp {
  types::stat val = 1;
};

struct EffectiveAtk {
  types::stat val = 1;
};

struct EffectiveDef {
  types::stat val = 1;
};

struct EffectiveSpa {
  types::stat val = 1;
};

struct EffectiveSpd {
  types::stat val = 1;
};

struct EffectiveSpe {
  types::stat val = 1;
};
}  // namespace pokesim::stat

/////////////////////// END OF src/Components/Stats.hpp ////////////////////////

///////////////////// START OF src/Types/Enums/Ability.hpp /////////////////////

#include <cstdint>

namespace pokesim::dex {
// Pokemon ability name
enum class Ability : std::uint16_t {
  // clang-format off
  NO_ABILITY = 0, ADAPTABILITY, AERILATE, AFTERMATH, AIR_LOCK, ANALYTIC, ANGER_POINT, ANGER_SHELL, ANTICIPATION, ARENA_TRAP, ARMOR_TAIL, AROMA_VEIL, AS_ONE, AURA_BREAK, BAD_DREAMS, BALL_FETCH, BATTERY, BATTLE_ARMOR, BATTLE_BOND, BEADS_OF_RUIN, BEAST_BOOST, BERSERK, BIG_PECKS, BLAZE, BULLETPROOF, CHEEK_POUCH, CHILLING_NEIGH, CHLOROPHYLL, CLEAR_BODY, CLOUD_NINE, COLOR_CHANGE, COMATOSE, COMMANDER, COMPETITIVE, COMPOUND_EYES, CONTRARY, CORROSION, COSTAR, COTTON_DOWN, CUD_CHEW, CURIOUS_MEDICINE, CURSED_BODY, CUTE_CHARM, DAMP, DANCER, DARK_AURA, DAUNTLESS_SHIELD, DAZZLING, DEFEATIST, DEFIANT, DELTA_STREAM, DESOLATE_LAND, DISGUISE, DOWNLOAD, DRAGONS_MAW, DRIZZLE, DROUGHT, DRY_SKIN, EARTH_EATER, EARLY_BIRD, EFFECT_SPORE, ELECTRIC_SURGE, ELECTROMORPHOSIS, EMERGENCY_EXIT, FAIRY_AURA, FILTER, FLAME_BODY, FLARE_BOOST, FLASH_FIRE, FLOWER_GIFT, FLOWER_VEIL, FLUFFY, FORECAST, FOREWARN, FRIEND_GUARD, FRISK, FULL_METAL_BODY, FUR_COAT, GALE_WINGS, GALVANIZE, GLUTTONY, GOOD_AS_GOLD, GOOEY, GORILLA_TACTICS, GRASS_PELT, GRASSY_SURGE, GRIM_NEIGH, GUARD_DOG, GULP_MISSILE, GUTS, HADRON_ENGINE, HARVEST, HEALER, HEATPROOF, HEAVY_METAL, HONEY_GATHER, HUGE_POWER, HUNGER_SWITCH, HUSTLE, HYDRATION, HYPER_CUTTER, ICE_BODY, ICE_FACE, ICE_SCALES, ILLUMINATE, ILLUSION, IMMUNITY, IMPOSTER, INFILTRATOR, INNARDS_OUT, INNER_FOCUS, INSOMNIA, INTIMIDATE, INTREPID_SWORD, IRON_BARBS, IRON_FIST, JUSTIFIED, KEEN_EYE, KLUTZ, LEAF_GUARD, LEVITATE, LIBERO, LIGHT_METAL, LIGHTNING_ROD, LINGERING_AROMA, LIMBER, LIQUID_OOZE, LIQUID_VOICE, LONG_REACH, MAGIC_BOUNCE, MAGIC_GUARD, MAGICIAN, MAGMA_ARMOR, MAGNET_PULL, MARVEL_SCALE, MEGA_LAUNCHER, MERCILESS, MIMICRY, MINUS, MIRROR_ARMOR, MISTY_SURGE, MOLD_BREAKER, MOODY, MOTOR_DRIVE, MOXIE, MULTISCALE, MULTITYPE, MUMMY, MYCELIUM_MIGHT, NATURAL_CURE, NEUROFORCE, NEUTRALIZING_GAS, NO_GUARD, NORMALIZE, OBLIVIOUS, OPPORTUNIST, ORICHALCUM_PULSE, OVERCOAT, OVERGROW, OWN_TEMPO, PARENTAL_BOND, PASTEL_VEIL, PERISH_BODY, PICKPOCKET, PICKUP, PIXILATE, PLUS, POISON_HEAL, POISON_POINT, POISON_TOUCH, POWER_CONSTRUCT, POWER_OF_ALCHEMY, POWER_SPOT, PRANKSTER, PRESSURE, PRIMORDIAL_SEA, PRISM_ARMOR, PROPELLER_TAIL, PROTEAN, PROTOSYNTHESIS, PSYCHIC_SURGE, PUNK_ROCK, PURE_POWER, PURIFYING_SALT, QUARK_DRIVE, QUEENLY_MAJESTY, QUICK_DRAW, QUICK_FEET, RAIN_DISH, RATTLED, RECEIVER, RECKLESS, REFRIGERATE, REGENERATOR, RIPEN, RIVALRY, RKS_SYSTEM, ROCK_HEAD, ROCKY_PAYLOAD, ROUGH_SKIN, RUN_AWAY, SAND_FORCE, SAND_RUSH, SAND_SPIT, SAND_STREAM, SAND_VEIL, SAP_SIPPER, SCHOOLING, SCRAPPY, SCREEN_CLEANER, SEED_SOWER, SERENE_GRACE, SHADOW_SHIELD, SHADOW_TAG, SHARPNESS, SHED_SKIN, SHEER_FORCE, SHELL_ARMOR, SHIELD_DUST, SHIELDS_DOWN, SIMPLE, SKILL_LINK, SLOW_START, SLUSH_RUSH, SNIPER, SNOW_CLOAK, SNOW_WARNING, SOLAR_POWER, SOLID_ROCK, SOUL_HEART, SOUNDPROOF, SPEED_BOOST, STAKEOUT, STALL, STALWART, STAMINA, STANCE_CHANGE, STATIC, STEADFAST, STEAM_ENGINE, STEELWORKER, STEELY_SPIRIT, STENCH, STICKY_HOLD, STORM_DRAIN, STRONG_JAW, STURDY, SUCTION_CUPS, SUPER_LUCK, SUPREME_OVERLORD, SURGE_SURFER, SWARM, SWEET_VEIL, SWIFT_SWIM, SYMBIOSIS, SYNCHRONIZE, SWORD_OF_RUIN, TABLETS_OF_RUIN, TANGLED_FEET, TANGLING_HAIR, TECHNICIAN, TELEPATHY, TERAVOLT, THERMAL_EXCHANGE, THICK_FAT, TINTED_LENS, TORRENT, TOUGH_CLAWS, TOXIC_BOOST, TOXIC_DEBRIS, TRACE, TRANSISTOR, TRIAGE, TRUANT, TURBOBLAZE, UNAWARE, UNBURDEN, UNNERVE, UNSEEN_FIST, VESSEL_OF_RUIN, VICTORY_STAR, VITAL_SPIRIT, VOLT_ABSORB, WANDERING_SPIRIT, WATER_ABSORB, WATER_BUBBLE, WATER_COMPACTION, WATER_VEIL, WEAK_ARMOR, WELL_BAKED_BODY, WHITE_SMOKE, WIMP_OUT, WIND_POWER, WIND_RIDER, WONDER_GUARD, WONDER_SKIN, ZEN_MODE, ZERO_TO_HERO, ABILITY_TOTAL,
  // clang-format on
};

static constexpr std::size_t TOTAL_ABILITY_COUNT = (std::size_t)Ability::ABILITY_TOTAL;
}  // namespace pokesim::dex

////////////////////// END OF src/Types/Enums/Ability.hpp //////////////////////

///////////////////// START OF src/Types/Enums/Gender.hpp //////////////////////

#include <cstdint>

namespace pokesim::dex {
// Pokemon gender name
enum class Gender : std::uint8_t { NO_GENDER = 0, FEMALE, MALE };

static constexpr std::size_t TOTAL_GENDER_COUNT = 3U;
}  // namespace pokesim::dex

////////////////////// END OF src/Types/Enums/Gender.hpp ///////////////////////

////////////////////// START OF src/Types/Enums/Item.hpp ///////////////////////

#include <cstdint>

namespace pokesim::dex {
// Name of items in Pokemon games
enum class Item : std::uint16_t {
  // clang-format off
  NO_ITEM = 0, ABILITY_CAPSULE, ABILITY_PATCH, ABILITY_SHIELD, ABOMASITE, ABRA_CANDY, ABSOLITE, ABSORB_BULB, ACRO_BIKE, ADAMANT_CRYSTAL, ADAMANT_MINT, ADAMANT_ORB, ADRENALINE_ORB, ADVENTURE_GUIDE, AERODACTYLITE, AERODACTYL_CANDY, AGGRONITE, AGUAV_BERRY, AIR_BALLOON, AIR_MAIL, ALAKAZITE, ALORAICHIUM_Z, ALTARIANITE, AMAZE_MULCH, AMPHAROSITE, AMULET_COIN, ANTIDOTE, APICOT_BERRY, APRICORN, APRICORN_BOX, AQUA_SUIT, ARMOR_FOSSIL, ARMOR_PASS, ARMORITE_ORE, ARTICUNO_CANDY, ASPEAR_BERRY, ASSAULT_VEST, AUDINITE, AURORATICKET, AUSPICIOUS_ARMOR, AUTOGRAPH, AUX_EVASION, AUX_GUARD, AUX_POWER, AUX_POWERGUARD, AWAKENING, AZELFS_FANG, AZURE_FLUTE, BABIRI_BERRY, BALL_OF_MUD, BALM_MUSHROOM, BAND_AUTOGRAPH, BANETTITE, BASCULEGION_FOOD, BASEMENT_KEY, BEACH_GLASS, BEAD_MAIL, BEAN_CAKE, BEAST_BALL, BEEDRILLITE, BELLSPROUT_CANDY, BELUE_BERRY, BERRY, BERRY_JUICE, BERRY_POTS, BERRY_POUCH, BERRY_SWEET, BERSERK_GENE, BICYCLE, BIG_BAMBOO_SHOOT, BIG_MALASADA, BIG_MUSHROOM, BIG_NUGGET, BIG_PEARL, BIG_ROOT, BIKE_VOUCHER, BINDING_BAND, BITTER_BERRY, BLACK_APRICORN, BLACK_AUGURITE, BLACK_BELT, BLACK_FLUTE, BLACK_GLASSES, BLACK_MANE_HAIR, BLACK_SLUDGE, BLACK_TUMBLESTONE, BLANK_PLATE, BLASTOISINITE, BLAZIKENITE, BLOOM_MAIL, BLUE_APRICORN, BLUE_CARD, BLUE_FLUTE, BLUE_ORB, BLUE_PETAL, BLUE_SCARF, BLUE_SHARD, BLUESKY_MAIL, BLU_ID_BADGE, BLUK_BERRY, BLUNDER_POLICY, BOLD_MINT, BONSLY_CARD, BONSLY_PHOTO, BOOST_MULCH, BOOSTER_ENERGY, BOTTLE_CAP, BRAVE_MINT, BRICK_MAIL, BRICK_PIECE, BRIDGE_MAIL_D, BRIDGE_MAIL_M, BRIDGE_MAIL_S, BRIDGE_MAIL_T, BRIDGE_MAIL_V, BRIGHT_POWDER, BUBBLE_MAIL, BUG_GEM, BUG_MEMORY, BUG_TERA_SHARD, BUGINIUM_Z, BUGWORT, BULBASAUR_CANDY, BURN_DRIVE, BURN_HEAL, BURNT_BERRY, CAKE_LURE_BASE, CALCIUM, CALM_MINT, CAMERUPTITE, CAMPING_GEAR, CANDY_TRUFFLE, CARBOS, CARD_KEY, CAREFUL_MINT, CARROT_SEEDS, CASTELIACONE, CASTER_FERN, CATCHING_CHARM, CATERPIE_CANDY, CELESTICA_FLUTE, CELL_BATTERY, CHALKY_STONE, CHANSEY_CANDY, CHARCOAL, CHARIZARDITE_X, CHARIZARDITE_Y, CHARMANDER_CANDY, CHARTI_BERRY, CHERI_BERRY, CHERISH_BALL, CHESTO_BERRY, CHILAN_BERRY, CHILL_DRIVE, CHIPPED_POT, CHOICE_BAND, CHOICE_DUMPLING, CHOICE_SCARF, CHOICE_SPECS, CHOPLE_BERRY, CLAW_FOSSIL, CLEANSE_TAG, CLEAR_AMULET, CLEAR_BELL, CLEFAIRY_CANDY, CLEVER_FEATHER, CLOVER_SWEET, COBA_BERRY, COIN_CASE, COLBUR_BERRY, COLOGNE_CASE, COLRESS_MACHINE, COMET_SHARD, COMMON_STONE, CONTEST_COSTUME, CONTEST_PASS, CORNN_BERRY, COUPON_1, COUPON_2, COUPON_3, COURAGE_CANDY, COURAGE_CANDY_L, COURAGE_CANDY_XL, COVER_FOSSIL, COVERT_CLOAK, CRACKED_POT, CRAFTING_KIT, CROWN_PASS, CRUNCHY_SALT, CUBONE_CANDY, CRY_ANALYZER, CUSTAP_BERRY, DAMP_MULCH, DAMP_ROCK, DARK_GEM, DARK_MEMORY, DARK_STONE, DARK_TERA_SHARD, DARKINIUM_Z, DATA_CARDS, DATA_ROM, DAWN_STONE, DAZZLING_HONEY, D_DISK, DECIDIUM_Z, DEEP_SEA_SCALE, DEEP_SEA_TOOTH, DESTINY_KNOT, DEVON_PARTS, DEVON_SCOPE, DEVON_SCUBA_GEAR, DIANCITE, DIGGER_DRILL, DIGLETT_CANDY, DIRE_HIT, DIRESHROOM, DISC_CASE, DISCOUNT_COUPON, DISCOVERY_SLATE, DISTORTION_SLATE, DITTO_CANDY, DIVE_BALL, DNA_SAMPLE, DNA_SPLICERS, DODUO_CANDY, DOME_FOSSIL, DOPPEL_BONNETS, DOUSE_DRIVE, DOWN_ST_KEY, DOWSING_MACHINE, DRACO_PLATE, DRAGON_FANG, DRAGON_GEM, DRAGON_MEMORY, DRAGON_SCALE, DRAGON_SKULL, DRAGON_TERA_SHARD, DRAGONIUM_Z, DRASH_BERRY, DRATINI_CANDY, DREAD_PLATE, DREAM_BALL, DREAM_MAIL, DROPPED_ITEM, DROWZEE_CANDY, DS_SOUNDS, DUBIOUS_DISC, DURIN_BERRY, DUSK_BALL, DUSK_STONE, DYNAMAX_BAND, DYNAMAX_CANDY, DYNAMAX_CRYSTALS, DYNITE_ORE, EARTH_PLATE, EEVEE_CANDY, EEVIUM_Z, EGG_TICKET, EGGANT_BERRY, EIN_FILE_C, EIN_FILE_F, EIN_FILE_H, EIN_FILE_P, EIN_FILE_S, EJECT_BUTTON, EJECT_PACK, EKANS_CANDY, ELECTABUZZ_CANDY, ELECTIRIZER, ELECTRIC_GEM, ELECTRIC_MEMORY, ELECTRIC_SEED, ELECTRIC_TERA_SHARD, ELECTRIUM_Z, ELEVATOR_KEY, ELIXIR, ENDORSEMENT, ENERGY_POWDER, ENERGY_ROOT, ENIGMA_BERRY, ENIGMA_STONE, ENIGMATIC_CARD, EON_FLUTE, EON_MAIL, EON_TICKET, ESCAPE_ROPE, ETERNAL_ICE, ETHER, EVERSTONE, EVIOLITE, EXCITE_SCENT, EXEGGCUTE_CANDY, EXP_CANDY_L, EXP_CANDY_M, EXP_CANDY_S, EXP_CANDY_XL, EXP_CANDY_XS, EXP_CHARM, EXP_SHARE, EXPERT_BELT, EXPLORER_KIT, FAB_MAIL, FAIRIUM_Z, FAIRY_GEM, FAIRY_MEMORY, FAIRY_TERA_SHARD, FAME_CHECKER, FARFETCHD_CANDY, FASHION_CASE, FAST_BALL, FAVORED_MAIL, F_DISK, FEATHER_BALL, FESTIVAL_TICKET, FIGHTING_GEM, FIGHTING_MEMORY, FIGHTING_TERA_SHARD, FIGHTINIUM_Z, FIGY_BERRY, FINE_REMEDY, FIRE_GEM, FIRE_MEMORY, FIRE_STONE, FIRE_TERA_SHARD, FIRIUM_Z, FISHING_ROD, FIST_PLATE, FLAME_MAIL, FLAME_ORB, FLAME_PLATE, FLOAT_STONE, FLOWER_MAIL, FLOWER_SWEET, FLUFFY_TAIL, FLYING_GEM, FLYING_MEMORY, FLYING_TERA_SHARD, FLYINIUM_Z, FOCUS_BAND, FOCUS_SASH, FORAGE_BAG, FOREST_BALM, FOSSILIZED_BIRD, FOSSILIZED_DINO, FOSSILIZED_DRAKE, FOSSILIZED_FISH, FRESH_WATER, FRIEND_BALL, FULL_HEAL, FULL_INCENSE, FULL_RESTORE, GALACTIC_KEY, GALARICA_CUFF, GALARICA_TWIG, GALARICA_WREATH, GALLADITE, GANLON_BERRY, GARCHOMPITE, GARDEVOIRITE, GASTLY_CANDY, GB_SOUNDS, GEAR, GENGARITE, GENIUS_FEATHER, GENOME_SLATE, GENTLE_MINT, GEODUDE_CANDY, GHOST_GEM, GHOST_MEMORY, GHOST_TERA_SHARD, GHOSTIUM_Z, GIGATON_BALL, GINEMA_BERRY, GLALITITE, GLITTER_MAIL, GO_GOGGLES, GOD_STONE, GOLD_BERRY, GOLD_BOTTLE_CAP, GOLD_LEAF, GOLD_TEETH, GOLDEEN_CANDY, GONZAPS_KEY, GOLDEN_NANAB_BERRY, GOLDEN_PINAP_BERRY, GOLDEN_RAZZ_BERRY, GOOD_ROD, GOOEY_MULCH, GORGEOUS_BOX, GRACIDEA, GRAIN_CAKE, GRAM_1, GRAM_2, GRAM_3, GRASS_GEM, GRASS_MEMORY, GRASS_TERA_SHARD, GRASSIUM_Z, GRASS_MAIL, GRASSY_SEED, GREAT_BALL, GREEN_APRICORN, GREEN_PETAL, GREEN_SCARF, GREEN_SHARD, GREET_MAIL, GREPA_BERRY, GRIMER_CANDY, GRIP_CLAW, GRIT_DUST, GRIT_GRAVEL, GRIT_PEBBLE, GRIT_ROCK, GRISEOUS_CORE, GRISEOUS_ORB, GRN_ID_BADGE, GROUND_GEM, GROUND_MEMORY, GROUND_TERA_SHARD, GROUNDIUM_Z, GROWLITHE_CANDY, GROWTH_MULCH, GRUBBY_HANKY, GS_BALL, GUARD_SPEC, GUIDEBOOK, GYARADOSITE, HABAN_BERRY, HARBOR_MAIL, HARD_STONE, HASTY_MINT, HEAL_BALL, HEAL_POWDER, HEALTH_CANDY, HEALTH_CANDY_L, HEALTH_CANDY_XL, HEALTH_FEATHER, HEART_MAIL, HEART_SCALE, HEARTY_GRAINS, HEAT_ROCK, HEAVY_BALL, HEAVY_DUTY_BOOTS, HELIX_FOSSIL, HERACRONITE, HI_TECH_EARBUDS, HITMONCHAN_CANDY, HITMONLEE_CANDY, HM01, HM02, HM03, HM04, HM05, HM06, HM07, HM08, HOLO_CASTER, HOMETOWN_MUFFIN, HONDEW_BERRY, HONEY, HONEY_CAKE, HONOR_OF_KALOS, HOPO_BERRY, HORSEA_CANDY, HOUNDOOMINITE, HP_UP, HYPER_POTION, IAPAPA_BERRY, ICE_BERRY, ICE_GEM, ICE_HEAL, ICE_MEMORY, ICE_STONE, ICE_TERA_SHARD, ICEROOT_CARROT, ICICLE_PLATE, ICIUM_Z, ICY_ROCK, ID_CARD, ILIMAS_NORMALIUM_Z, IMPISH_MINT, INCINIUM_Z, INQUIRY_MAIL, INSECT_PLATE, INTRIGUING_STONE, IRON, IRON_BALL, IRON_BARKTONGUE, IRON_CHUNK, IRON_PLATE, JABOCA_BERRY, JADE_ORB, JAIL_KEY, JAW_FOSSIL, JET_BALL, JIGGLYPUFF_CANDY, JOHTO_SLATE, JOLLY_MINT, JOY_SCENT, JUBILIFE_MUFFIN, JYNX_CANDY, KABUTO_CANDY, KANGASKHAN_CANDY, KANGASKHANITE, KANTO_SLATE, KASIB_BERRY, KEBIA_BERRY, KEE_BERRY, KELPSY_BERRY, KEY_STONE, KEY_TO_ROOM_1, KEY_TO_ROOM_2, KEY_TO_ROOM_4, KEY_TO_ROOM_6, KINGS_LEAF, KINGS_ROCK, KOFFING_CANDY, KOFUS_BOOK, KOMMONIUM_Z, KORAIDONS_POKE_BALL, KRABBY_CANDY, KRANE_MEMO_1, KRANE_MEMO_2, KRANE_MEMO_3, KRANE_MEMO_4, KRANE_MEMO_5, KUO_BERRY, LAGGING_TAIL, LANSAT_BERRY, LAPRAS_CANDY, LATIASITE, LATIOSITE, LAVA_COOKIE, LAX_INCENSE, LAX_MINT, L_DISK, LEADEN_BALL, LEADERS_CREST, LEAF_LETTER, LEAF_STONE, LEEK, LEFT_POKE_BALL, LEFTOVERS, LEGEND_PLATE, LEGENDARY_CLUE_1, LEGENDARY_CLUE_2, LEGENDARY_CLUE_3, LEGENDARY_CLUE, LEMONADE, LENS_CASE, LEPPA_BERRY, LETTER, LEVEL_BALL, LIBERTY_PASS, LICKITUNG_CANDY, LIECHI_BERRY, LIFE_ORB, LIFT_KEY, LIGHT_BALL, LIGHT_CLAY, LIGHT_STONE, LIKE_MAIL, LINKING_CORD, LITEBLUEMAIL, LOADED_DICE, LOCK_CAPSULE, LONE_EARRING, LONELY_MINT, LOOKER_TICKET, LOOT_SACK, LOPUNNITE, LOST_ITEM, LOST_SATCHEL, LOVE_BALL, LOVE_SWEET, LOVELY_MAIL, LUCARIONITE, LUCK_INCENSE, LUCKY_EGG, LUCKY_PUNCH, LUM_BERRY, LUMINOUS_MOSS, LUMIOSE_GALETTE, LUNALIUM_Z, LUNAR_FEATHER, LURE, LURE_BALL, LUSTROUS_GLOBE, LUSTROUS_ORB, LUXURY_BALL, LYCANIUM_Z, MACH_BIKE, MACHINE_PART, MACHO_BRACE, MACHOP_CANDY, MAGIKARP_CANDY, MAGMA_EMBLEM, MAGMA_STONE, MAGMA_SUIT, MAGMAR_CANDY, MAGMARIZER, MAGNEMITE_CANDY, MAGNET, MAGO_BERRY, MAGOST_BERRY, MAINGATE_KEY, MAKEUP_BAG, MALICIOUS_ARMOR, MANECTITE, MANKEY_CANDY, MARANGA_BERRY, MARBLE, MARK_CHARM, MARSHADIUM_Z, MARSH_BALM, MASTER_BALL, MAWILITE, MAX_ELIXIR, MAX_ETHER, MAX_LURE, MAX_HONEY, MAX_MUSHROOMS, MAX_POTION, MAX_REPEL, MAX_REVIVE, MAYORS_NOTE, MEADOW_PLATE, MECH_MAIL, MECHANICAL_BOX, MECHANICAL_CABINET, MECHANICAL_CIRCULAR_SAW, MECHANICAL_PINWHEEL, MECHANICAL_TUB, MEDAL_BOX, MEDICHAMITE, MEDICINAL_LEEK, MEGA_BRACELET, MEGA_RING, MELTAN_CANDY, MEMBER_CARD, MENTAL_HERB, MEOWTH_CANDY, MESPRITS_PLUME, METAGROSSITE, METAL_COAT, METAL_POWDER, METEORITE, METEORITE_SHARD, METRONOME, MEW_CANDY, MEWNIUM_Z, MEWTWO_CANDY, MEWTWONITE_X, MEWTWONITE_Y, MICLE_BERRY, MIGHTY_CANDY, MIGHTY_CANDY_L, MIGHTY_CANDY_XL, MILD_MINT, MIMIKIUM_Z, MIND_PLATE, MINT_BERRY, MIRACLEBERRY, MIRACLE_SEED, MIRAGE_MAIL, MIRAIDONS_POKE_BALL, MIROR_RADAR, MIRROR_HERB, MISTY_SEED, MODEST_MINT, MOLTRES_CANDY, MOOMOO_MILK, MOON_BALL, MOON_FLUTE, MOON_SHARD, MOON_STONE, MORPH_MAIL, MOSAIC_MAIL, MOUNTAIN_BALM, MR_MIME_CANDY, MUSCLE_BAND, MUSCLE_FEATHER, MUSHROOM_CAKE, MUSIC_DISC, MUSIC_MAIL, MYSTERIOUS_BALM, MYSTERIOUS_SHARD_S, MYSTERIOUS_SHARD_L, MYSTERYBERRY, MYSTERY_EGG, MYSTIC_WATER, MYSTICTICKET, NAIVE_MINT, NANAB_BERRY, NAUGHTY_MINT, NEST_BALL, NET_BALL, NEVER_MELT_ICE, NIDORAN_MALE_CANDY, NIDORAN_FEMALE_CANDY, NINIKU_BERRY, N_LUNARIZER, NOMEL_BERRY, NORMAL_BOX, NORMAL_GEM, NORMAL_TERA_SHARD, NORMALIUM_Z, N_SOLARIZER, NUGGET, NUTPEA_BERRY, OAKS_LETTER, OAKS_PARCEL, OCCA_BERRY, OCEANIC_SLATE, ODD_INCENSE, ODD_KEYSTONE, ODDISH_CANDY, OLD_AMBER, OLD_CHARM, OLD_GATEAU, OLD_JOURNAL, OLD_LETTER, OLD_ROD, OLD_SEA_MAP, OLD_VERSES, OMANYTE_CANDY, ONIX_CANDY, ORAN_BERRY, ORANGE_MAIL, ORANGE_PETAL, ORIGIN_BALL, ORIGIN_ORE, OVAL_CHARM, OVAL_STONE, PAIR_OF_TICKETS, PAL_PAD, PAMTRE_BERRY, PARALYZE_HEAL, PARAS_CANDY, PARCEL, PARK_BALL, PASS, PASS_ORB, PASSHO_BERRY, PAYAPA_BERRY, PEARL, PEARL_STRING, PEAT_BLOCK, PECHA_BERRY, PEP_UP_PLANT, PERMIT, PERSIM_BERRY, PETAYA_BERRY, PEWTER_CRUNCHIES, PICNIC_SET, PIDGEOTITE, PIDGEY_CANDY, PIKACHU_CANDY, PIKANIUM_Z, PIKASHUNIUM_Z, PINAP_BERRY, PINK_APRICORN, PINK_BOW, PINK_NECTAR, PINK_PETAL, PINK_SCARF, PINSIR_CANDY, PINSIRITE, PIXIE_PLATE, PLASMA_CARD, PLUME_FOSSIL, PLUMP_BEANS, POFFIN_CASE, POINT_CARD, POISON_BARB, POISON_GEM, POISON_MEMORY, POISON_TERA_SHARD, POISONIUM_Z, POKE_BALL, POKE_DOLL, POKE_FLUTE, POKE_RADAR, POKE_SNACK, POKE_TOY, POKEBLOCK_CASE, POKEBLOCK_KIT, POKEDEX, POKEMON_BOX_LINK, POKESHI_DOLL, POLKADOT_BOW, POLISHED_MUD_BALL, POLIWAG_CANDY, POMEG_BERRY, PONYTA_CANDY, POP_POD, PORTRAITMAIL, PORYGON_CANDY, POTION, POWER_ANKLET, POWER_BAND, POWER_BELT, POWER_BRACER, POWER_HERB, POWER_LENS, POWER_PLANT_PASS, POWER_WEIGHT, POWERUP_PART, POWDER_JAR, PP_MAX, PP_UP, PREMIER_BALL, PRETTY_FEATHER, PRIMARIUM_Z, PRISM_SCALE, PRISON_BOTTLE, PROFS_LETTER, PROFESSORS_MASK, PROP_CASE, PROTECTIVE_PADS, PROTECTOR, PROTEIN, PRZCUREBERRY, PSNCUREBERRY, PSYCHIC_GEM, PSYCHIC_MEMORY, PSYCHIC_SEED, PSYCHIC_TERA_SHARD, PSYCHIUM_Z, PSYDUCK_CANDY, PUMKIN_BERRY, PUNCHING_GLOVE, PURE_INCENSE, PURPLE_NECTAR, PURPLE_PETAL, QUALOT_BERRY, QUICK_BALL, QUICK_CANDY, QUICK_CANDY_L, QUICK_CANDY_XL, QUICK_CLAW, QUICK_POWDER, QUIET_MINT, RABUTA_BERRY, RADIANT_PETAL, RAGECANDYBAR, RAINBOW_FLOWER, RAINBOW_PASS, RAINBOW_SLATE, RAINBOW_WING, RARE_BONE, RARE_CANDY, RASH_MINT, RATTATA_CANDY, RAWST_BERRY, RAZOR_CLAW, RAZOR_FANG, RAZZ_BERRY, R_DISK, REAPER_CLOTH, RECIPES, RED_APRICORN, RED_CARD, RED_CHAIN, RED_FLUTE, RED_ID_BADGE, RED_NECTAR, RED_ORB, RED_PETAL, RED_SCALE, RED_SCARF, RED_SHARD, REINS_OF_UNITY, RELAXED_MINT, RELIC_BAND, RELIC_COPPER, RELIC_CROWN, RELIC_GOLD, RELIC_SILVER, RELIC_STATUE, RELIC_VASE, REMEDY, REPEAT_BALL, REPEL, REPLY_MAIL, RESIST_FEATHER, RETRO_MAIL, REVEAL_GLASS, REVIVAL_HERB, REVIVE, RHYHORN_CANDY, RIBBON_SWEET, RICH_MULCH, RIDE_PAGER, RINDO_BERRY, RING_TARGET, ROCK_GEM, ROCK_INCENSE, ROCK_MEMORY, ROCK_TERA_SHARD, ROCKIUM_Z, ROCKY_HELMET, ROLLER_SKATES, ROOM_SERVICE, ROOT_FOSSIL, ROSE_INCENSE, ROSELI_BERRY, ROTO_BARGAIN, ROTO_BOOST, ROTO_CATCH, ROTO_ENCOUNTER, ROTO_EXP_POINTS, ROTO_FRIENDSHIP, ROTO_HATCH, ROTO_HP_RESTORE, ROTO_PP_RESTORE, ROTO_PRIZE_MONEY, ROTO_STEALTH, ROTOM_BIKE, ROTOM_CATALOG, ROTOM_PHONE, ROWAP_BERRY, RSVP_MAIL, RUBY, RUNNING_SHOES, RUSTED_SHIELD, RUSTED_SWORD, S_S_TICKET, SABLENITE, SACHET, SACRED_ASH, SAFARI_BALL, SAFETY_GOGGLES, SAIL_FOSSIL, SALAC_BERRY, SALAMENCITE, SALT_CAKE, SAND_RADISH, SANDSHREW_CANDY, SANDWICH, SAPPHIRE, SASSY_MINT, SCANNER, SCARLET_BOOK, SCATTER_BANG, SCEPTILITE, SCIZORITE, SCOPE_LENS, SCROLL_OF_DARKNESS, SCROLL_OF_WATERS, SCYTHER_CANDY, SEA_INCENSE, SEAL_CASE, SECRET_KEY, SECRET_MEDICINE, SEED_OF_MASTERY, SEEL_CANDY, SERIOUS_MINT, SHADOW_MAIL, SHADEROOT_CARROT, SHALOUR_SABLE, SHARP_BEAK, SHARPEDONITE, SHED_SHELL, SHELL_BELL, SHELLDER_CANDY, SHINY_CHARM, SHINY_LEAF, SHINY_STONE, SHOAL_SALT, SHOAL_SHELL, SHOCK_DRIVE, SHUCA_BERRY, SILK_SCARF, SILPH_SCOPE, SILVER_LEAF, SILVER_NANAB_BERRY, SILVER_PINAP_BERRY, SILVER_POWDER, SILVER_RAZZ_BERRY, SILVER_WING, SITRUS_BERRY, SKULL_FOSSIL, SKY_PLATE, SKY_TUMBLESTONE, SLOWBRONITE, SLOWPOKE_CANDY, SLOWPOKE_TAIL, SMALL_BOUQUET, SMALL_TABLET, SMART_CANDY, SMART_CANDY_L, SMART_CANDY_XL, SMOKE_BALL, SMOKE_BOMB, SMOOTH_ROCK, SNORLAX_CANDY, SNORLIUM_Z, SNOWBALL, SNOW_BALM, SNOW_MAIL, SODA_POP, SOFT_SAND, SOLGANIUM_Z, SONIAS_BOOK, SOOT_SACK, SOOTFOOT_ROOT, SOOTHE_BELL, SOUL_DEW, SOUL_SLATE, SPACE_BALM, SPACE_MAIL, SPARKLING_STONE, SPEAROW_CANDY, SPELL_TAG, SPELON_BERRY, SPLASH_PLATE, SPOILED_APRICORN, SPOOKY_PLATE, SPORT_BALL, SPRAYDUCK, SPRINGY_MUSHROOM, SPRINKLOTAD, SQUALL_SLATE, SQUIRT_BOTTLE, SQUIRTLE_CANDY, STABLE_MULCH, STAR_PIECE, STAR_SWEET, STARDUST, STARF_BERRY, STARYU_CANDY, STEALTH_SPRAY, STEEL_GEM, STEEL_MAIL, STEEL_MEMORY, STEEL_TEETH, STEEL_TERA_SHARD, STEELIUM_Z, STEELIXITE, STICKY_BARB, STICKY_GLOB, STONE_PLATE, STORAGE_KEY, STRANGE_BALL, STRANGE_SOUVENIR, STRATOSPHERIC_SLATE, STRAWBERRY_SWEET, STRETCHY_SPRING, STRIB_BERRY, STYLE_CARD, SUBWAY_KEY, SUITE_KEY, SUN_FLUTE, SUN_SHARD, SUN_STONE, SUPER_LURE, SUPER_POTION, SUPER_REPEL, SUPER_ROD, SUPERB_REMEDY, SURFBOARD, SURF_MAIL, SURGE_BADGE, SURPRISE_MULCH, SURVIVAL_CHARM_B, SURVIVAL_CHARM_P, SURVIVAL_CHARM_R, SURVIVAL_CHARM_T, SURVIVAL_CHARM_Y, SWAMPERTITE, SWAP_SNACK, SWEET_APPLE, SWEET_HEART, SWIFT_FEATHER, SWORDCAP, SYSTEM_LEVER, TAMATO_BERRY, TANGA_BERRY, TANGELA_CANDY, TAPUNIUM_Z, TART_APPLE, TAUROS_CANDY, TEA, TEACHY_TV, TECTONIC_SLATE, TEMPTING_CHARM_B, TEMPTING_CHARM_P, TEMPTING_CHARM_R, TEMPTING_CHARM_T, TEMPTING_CHARM_Y, TENTACOOL_CANDY, TERA_ORB, TERRAIN_EXTENDER, TERU_SAMA, THANKS_MAIL, THICK_CLUB, THROAT_SPRAY, THUNDER_STONE, TIDAL_BELL, TIME_BALM, TIME_FLUTE, TIMER_BALL, TIMID_MINT, TINY_BAMBOO_SHOOT, TINY_MUSHROOM, TM01, TM02, TM03, TM04, TM05, TM06, TM07, TM08, TM09, TM10, TM11, TM12, TM13, TM14, TM15, TM16, TM17, TM18, TM19, TM20, TM21, TM22, TM23, TM24, TM25, TM26, TM27, TM28, TM29, TM30, TM31, TM32, TM33, TM34, TM35, TM36, TM37, TM38, TM39, TM40, TM41, TM42, TM43, TM44, TM45, TM46, TM47, TM48, TM49, TM50, TM51, TM52, TM53, TM54, TM55, TM56, TM57, TM58, TM59, TM60, TM61, TM62, TM63, TM64, TM65, TM66, TM67, TM68, TM69, TM70, TM71, TM72, TM73, TM74, TM75, TM76, TM77, TM78, TM79, TM80, TM81, TM82, TM83, TM84, TM85, TM86, TM87, TM88, TM89, TM90, TM91, TM92, TM93, TM94, TM95, TM96, TM97, TM98, TM99, TM_CASE, TM_MATERIALS, TR01, TR02, TR03, TR04, TR05, TR06, TR07, TR08, TR09, TR10, TR11, TR12, TR13, TR14, TR15, TR16, TR17, TR18, TR19, TR20, TR21, TR22, TR23, TR24, TR25, TR26, TR27, TR28, TR29, TR30, TR31, TR32, TR33, TR34, TR35, TR36, TR37, TR38, TR39, TR40, TR41, TR42, TR43, TR44, TR45, TR46, TR47, TR48, TR49, TR50, TR51, TR52, TR53, TR54, TR55, TR56, TR57, TR58, TR59, TR60, TR61, TR62, TR63, TR64, TR65, TR66, TR67, TR68, TR69, TR70, TR71, TR72, TR73, TR74, TR75, TR76, TR77, TR78, TR79, TR80, TR81, TR82, TR83, TR84, TR85, TR86, TR87, TR88, TR89, TR90, TR91, TR92, TR93, TR94, TR95, TR96, TR97, TR98, TR99, TMV_PASS, TOPO_BERRY, TORN_JOURNAL, TOUGA_BERRY, TOUGH_CANDY, TOUGH_CANDY_L, TOUGH_CANDY_XL, TOWN_MAP, TOXIC_ORB, TOXIC_PLATE, TRAVEL_TRUNK, TRI_PASS, TROPIC_MAIL, TROPICAL_SHELL, TUMBLESTONE, TUNNEL_MAIL, TWICE_SPICED_RADISH, TWISTED_SPOON, TYRANITARITE, U_DISK, ULTRA_BALL, ULTRANECROZIUM_Z, UNOWN_REPORT, UNUSUAL_SHOES, UPGRADE, UTILITY_UMBRELLA, UXIES_CLAW, VENONAT_CANDY, VENUSAURITE, VIOLET_BOOK, VIVICHOKE, VIVID_SCENT, VOICE_CASE_1, VOICE_CASE_2, VOICE_CASE_3, VOICE_CASE_4, VOICE_CASE_5, VOLCANO_BALM, VOLTORB_CANDY, VS_RECORDER, VS_SEEKER, VULPIX_CANDY, WACAN_BERRY, WAILMER_PAIL, WALL_FRAGMENT, WARDING_CHARM_B, WARDING_CHARM_P, WARDING_CHARM_R, WARDING_CHARM_T, WARDING_CHARM_Y, WATER_GEM, WATER_MEMORY, WATER_STONE, WATER_TERA_SHARD, WATERIUM_Z, WATMEL_BERRY, WAVE_INCENSE, WAVE_MAIL, WEAKNESS_POLICY, WEEDLE_CANDY, WEPEAR_BERRY, WHIPPED_DREAM, WHITE_APRICORN, WHITE_FLUTE, WHITE_HERB, WHITE_MANE_HAIR, WIDE_LENS, WIKI_BERRY, WING_BALL, WISE_GLASSES, WISHING_CHIP, WISHING_PIECE, WISHING_STAR, WOOD, WOOD_MAIL, WOODEN_CROWN, WORKS_KEY, X_ACCURACY, X_ATTACK, X_DEFENSE, X_SP_ATK, X_SP_DEF, X_SPEED, XTRANSCEIVER, YACHE_BERRY, YAGO_BERRY, YELLOW_APRICORN, YELLOW_FLUTE, YELLOW_NECTAR, YELLOW_PETAL, YELLOW_SCARF, YELLOW_SHARD, YLW_ID_BADGE, ZAP_PLATE, ZAPDOS_CANDY, ZINC, ZOOM_LENS, Z_POWER_RING, Z_RING, ZUBAT_CANDY, ZYGARDE_CUBE, ITEM_TOTAL
  // clang-format on
};

static constexpr std::size_t TOTAL_ITEM_COUNT = (std::size_t)Item::ITEM_TOTAL;
}  // namespace pokesim::dex

/////////////////////// END OF src/Types/Enums/Item.hpp ////////////////////////

///////////////////// START OF src/Types/Enums/Nature.hpp //////////////////////

#include <cstdint>

namespace pokesim::dex {
// Pokemon nature name
enum class Nature : std::uint8_t {
  // clang-format off
  NO_NATURE = 0, ADAMANT, BASHFUL, BOLD, BRAVE, CALM, CAREFUL, DOCILE, GENTLE, HARDY, HASTY, IMPISH, JOLLY, LAX, LONELY, MILD, MODEST, NAIVE, NAUGHTY, QUIET, QUIRKY, RASH, RELAXED, SASSY, SERIOUS, TIMID, NATURE_TOTAL
  // clang-format on
};

static constexpr std::size_t TOTAL_NATURE_COUNT = (std::size_t)Nature::NATURE_TOTAL;
}  // namespace pokesim::dex

////////////////////// END OF src/Types/Enums/Nature.hpp ///////////////////////

///////////////////// START OF src/Types/Enums/Species.hpp /////////////////////

#include <cstdint>

namespace pokesim::dex {

/**
 * @brief Pokemon and Pokemon form name.
 *
 * @details Pokemon that have multiple forms will have their base form and alternate forms listed here.
 * However, if none of a Pokemon's forms are cosmetic (i.e. change nothing expect appearance), the forms cannot be
 * changed during battle, and no true base form exists, then the Pokemon's species name without a form specifier is
 * omitted. For example:
 *  - `VENUSAUR`, `MEGA_VENUSAUR`, and `GIGANTAMAX_VENUSAUR` are all listed because Venusaur changes into the other
 * forms mid-battle
 *  - `GASTRODON`, `WEST_SEA_GASTRODON`, and `EAST_SEA_GASTRODON` are all listed because although Gastrodon's forms
 * are permanent, their only difference is how they look
 *  - `PLANT_CLOAK_WORMADAM`, `SANDY_CLOAK_WORMADAM`, and `TRASH_CLOAK_WORMADAM` listed while `WORMADAM` is not
 * because the Wormadam forms have different types, stats, and moves; their forms are permanent; and there is no base
 * Wormadam.
 */
enum class Species : std::uint16_t {
  // clang-format off
  MISSING_NO = 0, BULBASAUR, IVYSAUR, VENUSAUR, MEGA_VENUSAUR, GIGANTAMAX_VENUSAUR, CHARMANDER, CHARMELEON, CHARIZARD, MEGA_CHARIZARD_X, MEGA_CHARIZARD_Y, GIGANTAMAX_CHARIZARD, SQUIRTLE, WARTORTLE, BLASTOISE, MEGA_BLASTOISE, GIGANTAMAX_BLASTOISE, CATERPIE, METAPOD, BUTTERFREE, GIGANTAMAX_BUTTERFREE, WEEDLE, KAKUNA, BEEDRILL, MEGA_BEEDRILL, PIDGEY, PIDGEOTTO, PIDGEOT, MEGA_PIDGEOT, RATTATA, ALOLAN_RATTATA, RATICATE, ALOLAN_RATICATE, TOTEM_ALOLAN_RATICATE, SPEAROW, FEAROW, EKANS, ARBOK, PIKACHU, COSPLAY_PIKACHU, PIKACHU_ROCK_STAR, PIKACHU_BELLE, PIKACHU_POP_STAR, PIKACHU_PHD, PIKACHU_LIBRE, ORIGINAL_CAP_PIKACHU, HOENN_CAP_PIKACHU, SINNOH_CAP_PIKACHU, UNOVA_CAP_PIKACHU, KALOS_CAP_PIKACHU, ALOLA_CAP_PIKACHU, PARTNER_CAP_PIKACHU, STARTER_PIKACHU, GIGANTAMAX_PIKACHU, WORLD_CAP_PIKACHU, RAICHU, ALOLAN_RAICHU, SANDSHREW, ALOLAN_SANDSHREW, SANDSLASH, ALOLAN_SANDSLASH, NIDORAN_FEMALE, NIDORINA, NIDOQUEEN, NIDORAN_MALE, NIDORINO, NIDOKING, CLEFAIRY, CLEFABLE, VULPIX, ALOLAN_VULPIX, NINETALES, ALOLAN_NINETALES, JIGGLYPUFF, WIGGLYTUFF, ZUBAT, GOLBAT, ODDISH, GLOOM, VILEPLUME, PARAS, PARASECT, VENONAT, VENOMOTH, DIGLETT, ALOLAN_DIGLETT, DUGTRIO, ALOLAN_DUGTRIO, MEOWTH, ALOLAN_MEOWTH, GALARIAN_MEOWTH, GIGANTAMAX_MEOWTH, PERSIAN, ALOLAN_PERSIAN, PSYDUCK, GOLDUCK, MANKEY, PRIMEAPE, HISUIAN_GROWLITHE, GROWLITHE, HISUIAN_ARCANINE, ARCANINE, POLIWAG, POLIWHIRL, POLIWRATH, ABRA, KADABRA, ALAKAZAM, MEGA_ALAKAZAM, MACHOP, MACHOKE, MACHAMP, GIGANTAMAX_MACHAMP, BELLSPROUT, WEEPINBELL, VICTREEBEL, TENTACOOL, TENTACRUEL, GEODUDE, ALOLAN_GEODUDE, GRAVELER, ALOLAN_GRAVELER, GOLEM, ALOLAN_GOLEM, PONYTA, GALARIAN_PONYTA, RAPIDASH, GALARIAN_RAPIDASH, SLOWPOKE, GALARIAN_SLOWPOKE, SLOWBRO, MEGA_SLOWBRO, GALARIAN_SLOWBRO, MAGNEMITE, MAGNETON, FARFETCH_D, GALARIAN_FARFETCH_D, DODUO, DODRIO, SEEL, DEWGONG, GRIMER, ALOLAN_GRIMER, MUK, ALOLAN_MUK, SHELLDER, CLOYSTER, GASTLY, HAUNTER, GENGAR, MEGA_GENGAR, GIGANTAMAX_GENGAR, ONIX, DROWZEE, HYPNO, KRABBY, KINGLER, GIGANTAMAX_KINGLER, VOLTORB, HISUIAN_VOLTORB, ELECTRODE, HISUIAN_ELECTRODE, EXEGGCUTE, EXEGGUTOR, ALOLAN_EXEGGUTOR, CUBONE, MAROWAK, ALOLAN_MAROWAK, TOTEM_ALOLAN_MAROWAK, HITMONLEE, HITMONCHAN, LICKITUNG, KOFFING, WEEZING, GALARIAN_WEEZING, RHYHORN, RHYDON, CHANSEY, TANGELA, KANGASKHAN, MEGA_KANGASKHAN, HORSEA, SEADRA, GOLDEEN, SEAKING, STARYU, STARMIE, MR_MIME, GALARIAN_MR_MIME, SCYTHER, JYNX, ELECTABUZZ, MAGMAR, PINSIR, MEGA_PINSIR, TAUROS, PALDEAN_TAUROS_COMBAT_BREAD, PALDEAN_TAUROS_BLAZE_BREAD, PALDEAN_TAUROS_AQUA_BREAD, MAGIKARP, GYARADOS, MEGA_GYARADOS, LAPRAS, GIGANTAMAX_LAPRAS, DITTO, EEVEE, STARTER_EEVEE, GIGANTAMAX_EEVEE, VAPOREON, JOLTEON, FLAREON, PORYGON, OMANYTE, OMASTAR, KABUTO, KABUTOPS, AERODACTYL, MEGA_AERODACTYL, SNORLAX, GIGANTAMAX_SNORLAX, ARTICUNO, GALARIAN_ARTICUNO, ZAPDOS, GALARIAN_ZAPDOS, MOLTRES, GALARIAN_MOLTRES, DRATINI, DRAGONAIR, DRAGONITE, MEWTWO, MEGA_MEWTWO_X, MEGA_MEWTWO_Y, MEW, CHIKORITA, BAYLEEF, MEGANIUM, CYNDAQUIL, QUILAVA, HISUIAN_TYPHLOSION, TYPHLOSION, TOTODILE, CROCONAW, FERALIGATR, SENTRET, FURRET, HOOTHOOT, NOCTOWL, LEDYBA, LEDIAN, SPINARAK, ARIADOS, CROBAT, CHINCHOU, LANTURN, PICHU, SPIKY_EARED_PICHU, CLEFFA, IGGLYBUFF, TOGEPI, TOGETIC, NATU, XATU, MAREEP, FLAAFFY, AMPHAROS, MEGA_AMPHAROS, BELLOSSOM, MARILL, AZUMARILL, SUDOWOODO, POLITOED, HOPPIP, SKIPLOOM, JUMPLUFF, AIPOM, SUNKERN, SUNFLORA, YANMA, WOOPER, PALDEAN_WOOPER, QUAGSIRE, ESPEON, UMBREON, MURKROW, SLOWKING, GALARIAN_SLOWKING, MISDREAVUS, UNOWN, UNOWN_A, UNOWN_B, UNOWN_C, UNOWN_D, UNOWN_E, UNOWN_F, UNOWN_G, UNOWN_H, UNOWN_I, UNOWN_J, UNOWN_K, UNOWN_L, UNOWN_M, UNOWN_N, UNOWN_O, UNOWN_P, UNOWN_Q, UNOWN_R, UNOWN_S, UNOWN_T, UNOWN_U, UNOWN_V, UNOWN_W, UNOWN_X, UNOWN_Y, UNOWN_Z, UNOWN_EXCLAMATION, UNOWN_QUESTION, WOBBUFFET, GIRAFARIG, PINECO, FORRETRESS, DUNSPARCE, GLIGAR, STEELIX, MEGA_STEELIX, SNUBBULL, GRANBULL, QWILFISH, HISUIAN_QWILFISH, SCIZOR, MEGA_SCIZOR, SHUCKLE, HERACROSS, MEGA_HERACROSS, HISUIAN_SNEASEL, SNEASEL, TEDDIURSA, URSARING, SLUGMA, MAGCARGO, SWINUB, PILOSWINE, CORSOLA, GALARIAN_CORSOLA, REMORAID, OCTILLERY, DELIBIRD, MANTINE, SKARMORY, HOUNDOUR, HOUNDOOM, MEGA_HOUNDOOM, KINGDRA, PHANPY, DONPHAN, PORYGON2, STANTLER, SMEARGLE, TYROGUE, HITMONTOP, SMOOCHUM, ELEKID, MAGBY, MILTANK, BLISSEY, RAIKOU, ENTEI, SUICUNE, LARVITAR, PUPITAR, TYRANITAR, MEGA_TYRANITAR, LUGIA, HO_OH, CELEBI, TREECKO, GROVYLE, SCEPTILE, MEGA_SCEPTILE, TORCHIC, COMBUSKEN, BLAZIKEN, MEGA_BLAZIKEN, MUDKIP, MARSHTOMP, SWAMPERT, MEGA_SWAMPERT, POOCHYENA, MIGHTYENA, ZIGZAGOON, GALARIAN_ZIGZAGOON, LINOONE, GALARIAN_LINOONE, WURMPLE, SILCOON, BEAUTIFLY, CASCOON, DUSTOX, LOTAD, LOMBRE, LUDICOLO, SEEDOT, NUZLEAF, SHIFTRY, TAILLOW, SWELLOW, WINGULL, PELIPPER, RALTS, KIRLIA, GARDEVOIR, MEGA_GARDEVOIR, SURSKIT, MASQUERAIN, SHROOMISH, BRELOOM, SLAKOTH, VIGOROTH, SLAKING, NINCADA, NINJASK, SHEDINJA, WHISMUR, LOUDRED, EXPLOUD, MAKUHITA, HARIYAMA, AZURILL, NOSEPASS, SKITTY, DELCATTY, SABLEYE, MEGA_SABLEYE, MAWILE, MEGA_MAWILE, ARON, LAIRON, AGGRON, MEGA_AGGRON, MEDITITE, MEDICHAM, MEGA_MEDICHAM, ELECTRIKE, MANECTRIC, MEGA_MANECTRIC, PLUSLE, MINUN, VOLBEAT, ILLUMISE, ROSELIA, GULPIN, SWALOT, CARVANHA, SHARPEDO, MEGA_SHARPEDO, WAILMER, WAILORD, NUMEL, CAMERUPT, MEGA_CAMERUPT, TORKOAL, SPOINK, GRUMPIG, SPINDA, TRAPINCH, VIBRAVA, FLYGON, CACNEA, CACTURNE, SWABLU, ALTARIA, MEGA_ALTARIA, ZANGOOSE, SEVIPER, LUNATONE, SOLROCK, BARBOACH, WHISCASH, CORPHISH, CRAWDAUNT, BALTOY, CLAYDOL, LILEEP, CRADILY, ANORITH, ARMALDO, FEEBAS, MILOTIC, CASTFORM, SUNNY_CASTFORM, RAINY_CASTFORM, SNOWY_CASTFORM, KECLEON, SHUPPET, BANETTE, MEGA_BANETTE, DUSKULL, DUSCLOPS, TROPIUS, CHIMECHO, ABSOL, MEGA_ABSOL, WYNAUT, SNORUNT, GLALIE, MEGA_GLALIE, SPHEAL, SEALEO, WALREIN, CLAMPERL, HUNTAIL, GOREBYSS, RELICANTH, LUVDISC, BAGON, SHELGON, SALAMENCE, MEGA_SALAMENCE, BELDUM, METANG, METAGROSS, MEGA_METAGROSS, REGIROCK, REGICE, REGISTEEL, LATIAS, MEGA_LATIAS, LATIOS, MEGA_LATIOS, KYOGRE, PRIMAL_KYOGRE, GROUDON, PRIMAL_GROUDON, RAYQUAZA, MEGA_RAYQUAZA, JIRACHI, DEOXYS, ATTACK_DEOXYS, DEFENSE_DEOXYS, SPEED_DEOXYS, TURTWIG, GROTLE, TORTERRA, CHIMCHAR, MONFERNO, INFERNAPE, PIPLUP, PRINPLUP, EMPOLEON, STARLY, STARAVIA, STARAPTOR, BIDOOF, BIBAREL, KRICKETOT, KRICKETUNE, SHINX, LUXIO, LUXRAY, BUDEW, ROSERADE, CRANIDOS, RAMPARDOS, SHIELDON, BASTIODON, BURMY, PLANT_CLOAK_BURMY, SANDY_CLOAK_BURMY, TRASH_CLOAK_BURMY, PLANT_CLOAK_WORMADAM, SANDY_CLOAK_WORMADAM, TRASH_CLOAK_WORMADAM, MOTHIM, COMBEE, VESPIQUEN, PACHIRISU, BUIZEL, FLOATZEL, CHERUBI, CHERRIM, CHERRIM_OVERCAST, CHERRIM_SUNSHINE, SHELLOS, WEST_SEA_SHELLOS, EAST_SEA_SHELLOS, GASTRODON, WEST_SEA_GASTRODON, EAST_SEA_GASTRODON, AMBIPOM, DRIFLOON, DRIFBLIM, BUNEARY, LOPUNNY, MEGA_LOPUNNY, MISMAGIUS, HONCHKROW, GLAMEOW, PURUGLY, CHINGLING, STUNKY, SKUNTANK, BRONZOR, BRONZONG, BONSLY, MIME_JR, HAPPINY, CHATOT, SPIRITOMB, GIBLE, GABITE, GARCHOMP, MEGA_GARCHOMP, MUNCHLAX, RIOLU, LUCARIO, MEGA_LUCARIO, HIPPOPOTAS, HIPPOWDON, SKORUPI, DRAPION, CROAGUNK, TOXICROAK, CARNIVINE, FINNEON, LUMINEON, MANTYKE, SNOVER, ABOMASNOW, MEGA_ABOMASNOW, WEAVILE, MAGNEZONE, LICKILICKY, RHYPERIOR, TANGROWTH, ELECTIVIRE, MAGMORTAR, TOGEKISS, YANMEGA, LEAFEON, GLACEON, GLISCOR, MAMOSWINE, PORYGON_Z, GALLADE, MEGA_GALLADE, PROBOPASS, DUSKNOIR, FROSLASS, ROTOM, HEAT_ROTOM, WASH_ROTOM, FROST_ROTOM, FAN_ROTOM, MOW_ROTOM, UXIE, MESPRIT, AZELF, DIALGA, DIALGA_ORIGIN, PALKIA, PALKIA_ORIGIN, HEATRAN, REGIGIGAS, GIRATINA_ALTERED, GIRATINA_ORIGIN, CRESSELIA, PHIONE, MANAPHY, DARKRAI, SHAYMIN, SHAYMIN_LAND, SHAYMIN_SKY, ARCEUS, ARCEUS_BUG, ARCEUS_DARK, ARCEUS_DRAGON, ARCEUS_ELECTRIC, ARCEUS_FAIRY, ARCEUS_FIGHTING, ARCEUS_FIRE, ARCEUS_FLYING, ARCEUS_GHOST, ARCEUS_GRASS, ARCEUS_GROUND, ARCEUS_ICE, ARCEUS_POISON, ARCEUS_PSYCHIC, ARCEUS_ROCK, ARCEUS_STEEL, ARCEUS_WATER, VICTINI, SNIVY, SERVINE, SERPERIOR, TEPIG, PIGNITE, EMBOAR, OSHAWOTT, DEWOTT, HISUIAN_SAMUROTT, SAMUROTT, PATRAT, WATCHOG, LILLIPUP, HERDIER, STOUTLAND, PURRLOIN, LIEPARD, PANSAGE, SIMISAGE, PANSEAR, SIMISEAR, PANPOUR, SIMIPOUR, MUNNA, MUSHARNA, PIDOVE, TRANQUILL, UNFEZANT, BLITZLE, ZEBSTRIKA, ROGGENROLA, BOLDORE, GIGALITH, WOOBAT, SWOOBAT, DRILBUR, EXCADRILL, AUDINO, MEGA_AUDINO, TIMBURR, GURDURR, CONKELDURR, TYMPOLE, PALPITOAD, SEISMITOAD, THROH, SAWK, SEWADDLE, SWADLOON, LEAVANNY, VENIPEDE, WHIRLIPEDE, SCOLIPEDE, COTTONEE, WHIMSICOTT, PETILIL, LILLIGANT, HISUIAN_LILLIGANT, RED_STRIPED_BASCULIN, BLUE_STRIPED_BASCULIN, WHITE_STRIPED_BASCULIN, SANDILE, KROKOROK, KROOKODILE, DARUMAKA, GALARIAN_DARUMAKA, DARMANITAN, ZEN_MODE_DARMANITAN, GALARIAN_DARMANITAN, GALARIAN_ZEN_MODE_DARMANITAN, MARACTUS, DWEBBLE, CRUSTLE, SCRAGGY, SCRAFTY, SIGILYPH, YAMASK, GALARIAN_YAMASK, COFAGRIGUS, TIRTOUGA, CARRACOSTA, ARCHEN, ARCHEOPS, TRUBBISH, GARBODOR, GIGANTAMAX_GARBODOR, ZORUA, HISUIAN_ZORUA, HISUIAN_ZOROARK, ZOROARK, MINCCINO, CINCCINO, GOTHITA, GOTHORITA, GOTHITELLE, SOLOSIS, DUOSION, REUNICLUS, DUCKLETT, SWANNA, VANILLITE, VANILLISH, VANILLUXE, DEERLING, DEERLING_SPRING, DEERLING_SUMMER, DEERLING_AUTUMN, DEERLING_WINTER, SAWSBUCK, SAWSBUCK_SPRING, SAWSBUCK_SUMMER, SAWSBUCK_AUTUMN, SAWSBUCK_WINTER, EMOLGA, KARRABLAST, ESCAVALIER, FOONGUS, AMOONGUSS, FRILLISH, JELLICENT, ALOMOMOLA, JOLTIK, GALVANTULA, FERROSEED, FERROTHORN, KLINK, KLANG, KLINKLANG, TYNAMO, EELEKTRIK, EELEKTROSS, ELGYEM, BEHEEYEM, LITWICK, LAMPENT, CHANDELURE, AXEW, FRAXURE, HAXORUS, CUBCHOO, BEARTIC, CRYOGONAL, SHELMET, ACCELGOR, STUNFISK, GALARIAN_STUNFISK, MIENFOO, MIENSHAO, DRUDDIGON, GOLETT, GOLURK, PAWNIARD, BISHARP, BOUFFALANT, RUFFLET, HISUIAN_BRAVIARY, BRAVIARY, VULLABY, MANDIBUZZ, HEATMOR, DURANT, DEINO, ZWEILOUS, HYDREIGON, LARVESTA, VOLCARONA, COBALION, TERRAKION, VIRIZION, INCARNATE_TORNADUS, TORNADUS_THERIAN, INCARNATE_THUNDURUS, THUNDURUS_THERIAN, RESHIRAM, ZEKROM, INCARNATE_LANDORUS, LANDORUS_THERIAN, KYUREM, BLACK_KYUREM, WHITE_KYUREM, KELDEO, RESOLUTE_KELDEO, ARIA_MELOETTA, PIROUETTE_MELOETTA, GENESECT, DOUSE_DRIVE_GENESECT, SHOCK_DRIVE_GENESECT, BURN_DRIVE_GENESECT, CHILL_DRIVE_GENESECT, CHESPIN, QUILLADIN, CHESNAUGHT, FENNEKIN, BRAIXEN, DELPHOX, FROAKIE, FROGADIER, GRENINJA, ASH_GRENINJA, BUNNELBY, DIGGERSBY, FLETCHLING, FLETCHINDER, TALONFLAME, SCATTERBUG, SPEWPA, VIVILLON, MEADOW_PATTERN_VIVILLON, ARCHIPELAGO_PATTERN_VIVILLON, CONTINENTAL_PATTERN_VIVILLON, ELEGANT_PATTERN_VIVILLON, GARDEN_PATTERN_VIVILLON, HIGH_PLAINS_PATTERN_VIVILLON, ICY_SNOW_PATTERN_VIVILLON, JUNGLE_PATTERN_VIVILLON, MARINE_PATTERN_VIVILLON, MODERN_PATTERN_VIVILLON, MONSOON_PATTERN_VIVILLON, OCEAN_PATTERN_VIVILLON, POLAR_PATTERN_VIVILLON, RIVER_PATTERN_VIVILLON, SANDSTORM_PATTERN_VIVILLON, SAVANNA_PATTERN_VIVILLON, SUN_PATTERN_VIVILLON, TUNDRA_PATTERN_VIVILLON, FANCY_PATTERN_VIVILLON, POKEBALL_PATTERN_VIVILLON, LITLEO, PYROAR, FLABEBE, RED_FLOWER_FLABEBE, BLUE_FLOWER_FLABEBE, ORANGE_FLOWER_FLABEBE, WHITE_FLOWER_FLABEBE, YELLOW_FLOWER_FLABEBE, FLOETTE, RED_FLOWER_FLOETTE, BLUE_FLOWER_FLOETTE, ORANGE_FLOWER_FLOETTE, WHITE_FLOWER_FLOETTE, YELLOW_FLOWER_FLOETTE, ETERNAL_FLOWER_FLOETTE, FLORGES, RED_FLOWER_FLORGES, BLUE_FLOWER_FLORGES, ORANGE_FLOWER_FLORGES, WHITE_FLOWER_FLORGES, YELLOW_FLOWER_FLORGES, SKIDDO, GOGOAT, PANCHAM, PANGORO, FURFROU, NATURAL_FURFROU, DANDY_TRIM_FURFROU, DEBUTANTE_TRIM_FURFROU, DIAMOND_TRIM_FURFROU, HEART_TRIM_FURFROU, KABUKI_TRIM_FURFROU, LA_REINE_TRIM_FURFROU, MATRON_TRIM_FURFROU, PHARAOH_TRIM_FURFROU, STAR_TRIM_FURFROU, ESPURR, MALE_MEOWSTIC, FEMALE_MEOWSTIC, HONEDGE, DOUBLADE, AEGISLASH, SHIELD_AEGISLASH, BLADE_AEGISLASH, SPRITZEE, AROMATISSE, SWIRLIX, SLURPUFF, INKAY, MALAMAR, BINACLE, BARBARACLE, SKRELP, DRAGALGE, CLAUNCHER, CLAWITZER, HELIOPTILE, HELIOLISK, TYRUNT, TYRANTRUM, AMAURA, AURORUS, SYLVEON, HAWLUCHA, DEDENNE, CARBINK, GOOMY, HISUIAN_SLIGGOO, SLIGGOO, HISUIAN_GOODRA, GOODRA, KLEFKI, PHANTUMP, TREVENANT, AVERAGE_SIZE_PUMPKABOO, SMALL_SIZE_PUMPKABOO, LARGE_SIZE_PUMPKABOO, SUPER_SIZE_PUMPKABOO, AVERAGE_SIZE_GOURGEIST, SMALL_SIZE_GOURGEIST, LARGE_SIZE_GOURGEIST, SUPER_SIZE_GOURGEIST, BERGMITE, AVALUGG, HISUIAN_AVALUGG, NOIBAT, NOIVERN, XERNEAS, YVELTAL, ZYGARDE_50, ZYGARDE_10, ZYGARDE_COMPLETE, DIANCIE, MEGA_DIANCIE, HOOPA_CONFINED, HOOPA_UNBOUND, VOLCANION, ROWLET, DARTRIX, HISUIAN_DECIDUEYE, DECIDUEYE, LITTEN, TORRACAT, INCINEROAR, POPPLIO, BRIONNE, PRIMARINA, PIKIPEK, TRUMBEAK, TOUCANNON, YUNGOOS, GUMSHOOS, TOTEM_GUMSHOOS, GRUBBIN, CHARJABUG, VIKAVOLT, TOTEM_VIKAVOLT, CRABRAWLER, CRABOMINABLE, BAILE_STYLE_ORICORIO, POM_POM_STYLE_ORICORIO, PA_U_STYLE_ORICORIO, SENSU_STYLE_ORICORIO, CUTIEFLY, RIBOMBEE, TOTEM_RIBOMBEE, ROCKRUFF, MIDDAY_ROCKRUFF, MIDDAY_LYCANROC, MIDNIGHT_LYCANROC, DUSK_LYCANROC, WISHIWASHI, SOLO_WISHIWASHI, SCHOOL_WISHIWASHI, MAREANIE, TOXAPEX, MUDBRAY, MUDSDALE, DEWPIDER, ARAQUANID, TOTEM_ARAQUANID, FOMANTIS, LURANTIS, TOTEM_LURANTIS, MORELULL, SHIINOTIC, SALANDIT, SALAZZLE, TOTEM_SALAZZLE, STUFFUL, BEWEAR, BOUNSWEET, STEENEE, TSAREENA, COMFEY, ORANGURU, PASSIMIAN, WIMPOD, GOLISOPOD, SANDYGAST, PALOSSAND, PYUKUMUKU, TYPE_NULL, SILVALLY, SILVALLY_BUG, SILVALLY_DARK, SILVALLY_DRAGON, SILVALLY_ELECTRIC, SILVALLY_FAIRY, SILVALLY_FIGHTING, SILVALLY_FIRE, SILVALLY_FLYING, SILVALLY_GHOST, SILVALLY_GRASS, SILVALLY_GROUND, SILVALLY_ICE, SILVALLY_POISON, SILVALLY_PSYCHIC, SILVALLY_ROCK, SILVALLY_STEEL, SILVALLY_WATER, MINIOR, CORE_MINIOR, RED_CORE_MINIOR, ORANGE_CORE_MINIOR, YELLOW_CORE_MINIOR, GREEN_CORE_MINIOR, BLUE_CORE_MINIOR, INDIGO_CORE_MINIOR, VIOLET_CORE_MINIOR, METEOR_MINIOR, KOMALA, TURTONATOR, TOGEDEMARU, TOTEM_TOGEDEMARU, MIMIKYU, MIMIKYU_BUSTED, TOTEM_MIMIKYU, BUSTED_TOTEM_MIMIKYU, BRUXISH, DRAMPA, DHELMISE, JANGMO_O, HAKAMO_O, KOMMO_O, TOTEM_KOMMO_O, TAPU_KOKO, TAPU_LELE, TAPU_BULU, TAPU_FINI, COSMOG, COSMOEM, SOLGALEO, LUNALA, NIHILEGO, BUZZWOLE, PHEROMOSA, XURKITREE, CELESTEELA, KARTANA, GUZZLORD, NECROZMA, DUSK_MANE_NECROZMA, DAWN_WINGS_NECROZMA, ULTRA_NECROZMA, MAGEARNA, ORIGINAL_COLOR_MAGEARNA, MARSHADOW, POIPOLE, NAGANADEL, STAKATAKA, BLACEPHALON, ZERAORA, MELTAN, MELMETAL, GIGANTAMAX_MELMETAL, GROOKEY, THWACKEY, RILLABOOM, GIGANTAMAX_RILLABOOM, SCORBUNNY, RABOOT, CINDERACE, GIGANTAMAX_CINDERACE, SOBBLE, DRIZZILE, INTELEON, GIGANTAMAX_INTELEON, SKWOVET, GREEDENT, ROOKIDEE, CORVISQUIRE, CORVIKNIGHT, GIGANTAMAX_CORVIKNIGHT, BLIPBUG, DOTTLER, ORBEETLE, GIGANTAMAX_ORBEETLE, NICKIT, THIEVUL, GOSSIFLEUR, ELDEGOSS, WOOLOO, DUBWOOL, CHEWTLE, DREDNAW, GIGANTAMAX_DREDNAW, YAMPER, BOLTUND, ROLYCOLY, CARKOL, COALOSSAL, GIGANTAMAX_COALOSSAL, APPLIN, FLAPPLE, GIGANTAMAX_FLAPPLE, APPLETUN, GIGANTAMAX_APPLETUN, SILICOBRA, SANDACONDA, GIGANTAMAX_SANDACONDA, CRAMORANT, CRAMORANT_GULPING, CRAMORANT_GORGING, ARROKUDA, BARRASKEWDA, TOXEL, TOXTRICITY_AMPED, TOXTRICITY_LOW_KEY, GIGANTAMAX_TOXTRICITY_AMPED, GIGANTAMAX_TOXTRICITY_LOW_KEY, SIZZLIPEDE, CENTISKORCH, GIGANTAMAX_CENTISKORCH, CLOBBOPUS, GRAPPLOCT, SINISTEA, ANTIQUE_SINISTEA, POLTEAGEIST, ANTIQUE_POLTEAGEIST, HATENNA, HATTREM, HATTERENE, GIGANTAMAX_HATTERENE, IMPIDIMP, MORGREM, GRIMMSNARL, GIGANTAMAX_GRIMMSNARL, OBSTAGOON, PERRSERKER, CURSOLA, SIRFETCH_D, MR_RIME, RUNERIGUS, MILCERY, ALCREMIE, VANILLA_CREAM_ALCREMIE, RUBY_CREAM_ALCREMIE, MATCHA_CREAM_ALCREMIE, MINT_CREAM_ALCREMIE, LEMON_CREAM_ALCREMIE, SALTED_CREAM_ALCREMIE, RUBY_SWIRL_ALCREMIE, CARAMEL_SWIRL_ALCREMIE, RAINBOW_SWIRL_ALCREMIE, GIGANTAMAX_ALCREMIE, FALINKS, PINCURCHIN, SNOM, FROSMOTH, STONJOURNER, EISCUE, ICE_FACE_EISCUE, NOICE_FACE_EISCUE, MALE_INDEEDEE, FEMALE_INDEEDEE, MORPEKO, FULL_BELLY_MODE_MORPEKO, HANGRY_MODE_MORPEKO, CUFANT, COPPERAJAH, GIGANTAMAX_COPPERAJAH, DRACOZOLT, ARCTOZOLT, DRACOVISH, ARCTOVISH, DURALUDON, GIGANTAMAX_DURALUDON, DREEPY, DRAKLOAK, DRAGAPULT, HERO_OF_MANY_BATTLES_ZACIAN, CROWNED_SWORD_ZACIAN, HERO_OF_MANY_BATTLES_ZAMAZENTA, CROWNED_SHIELD_ZAMAZENTA, ETERNATUS, ETERNAMAX_ETERNATUS, KUBFU, SINGLE_STRIKE_STYLE_URSHIFU, RAPID_STRIKE_STYLE_URSHIFU, GIGANTAMAX_SINGLE_STRIKE_STYLE_URSHIFU, GIGANTAMAX_RAPID_STRIKE_STYLE_URSHIFU, ZARUDE, DADA_ZARUDE, REGIELEKI, REGIDRAGO, GLASTRIER, SPECTRIER, CALYREX, ICE_RIDER_CALYREX, SHADOW_RIDER_CALYREX, WYRDEER, KLEAVOR, URSALUNA, MALE_BASCULEGION, FEMALE_BASCULEGION, SNEASLER, OVERQWIL, INCARNATE_ENAMORUS, ENAMORUS_THERIAN, SPRIGATITO, FLORAGATO, MEOWSCARADA, FUECOCO, CROCALOR, SKELEDIRGE, QUAXLY, QUAXWELL, QUAQUAVAL, LECHONK, MALE_OINKOLOGNE, FEMALE_OINKOLOGNE, TAROUNTULA, SPIDOPS, NYMBLE, LOKIX, PAWMI, PAWMO, PAWMOT, TANDEMAUS, MAUSHOLD, FAMILY_OF_THREE_MAUSHOLD, FAMILY_OF_FOUR_MAUSHOLD, FIDOUGH, DACHSBUN, SMOLIV, DOLLIV, ARBOLIVA, GREEN_PLUMAGE_SQUAWKABILLY, BLUE_PLUMAGE_SQUAWKABILLY, YELLOW_PLUMAGE_SQUAWKABILLY, WHITE_PLUMAGE_SQUAWKABILLY, NACLI, NACLSTACK, GARGANACL, CHARCADET, ARMAROUGE, CERULEDGE, TADBULB, BELLIBOLT, WATTREL, KILOWATTREL, MASCHIFF, MABOSSTIFF, SHROODLE, GRAFAIAI, BRAMBLIN, BRAMBLEGHAST, TOEDSCOOL, TOEDSCRUEL, KLAWF, CAPSAKID, SCOVILLAIN, RELLOR, RABSCA, FLITTLE, ESPATHRA, TINKATINK, TINKATUFF, TINKATON, WIGLETT, WUGTRIO, BOMBIRDIER, FINIZEN, ZERO_PALAFIN, HERO_PALAFIN, VAROOM, REVAVROOM, CYCLIZAR, ORTHWORM, GLIMMET, GLIMMORA, GREAVARD, HOUNDSTONE, FLAMIGO, CETODDLE, CETITAN, VELUZA, DONDOZO, TATSUGIRI, CURLY_TATSUGIRI, DROOPY_TATSUGIRI, STRETCHY_TATSUGIRI, ANNIHILAPE, CLODSIRE, FARIGIRAF, DUDUNSPARCE, TWO_SEGMENT_DUDUNSPARCE, THREE_SEGMENT_DUDUNSPARCE, KINGAMBIT, GREAT_TUSK, SCREAM_TAIL, BRUTE_BONNET, FLUTTER_MANE, SLITHER_WING, SANDY_SHOCKS, IRON_TREADS, IRON_BUNDLE, IRON_HANDS, IRON_JUGULIS, IRON_MOTH, IRON_THORNS, FRIGIBAX, ARCTIBAX, BAXCALIBUR, CHEST_GIMMIGHOUL, ROAMING_GIMMIGHOUL, GHOLDENGO, WO_CHIEN, CHIEN_PAO, TING_LU, CHI_YU, ROARING_MOON, IRON_VALIANT, KORAIDON, MIRAIDON, WALKING_WAKE, IRON_LEAVES, SPECIES_TOTAL
  // clang-format on
};

static constexpr std::size_t TOTAL_SPECIES_COUINT = (std::size_t)Species::SPECIES_TOTAL;
}  // namespace pokesim::dex

////////////////////// END OF src/Types/Enums/Species.hpp //////////////////////

//////////////// START OF src/Types/Enums/TypeEffectiveness.hpp ////////////////

#include <cstdint>

namespace pokesim {
enum class TypeEffectiveness : std::uint8_t {
  IMMUNE,
  NOT_VERY_EFFECTIVE,
  NEUTRAL,
  SUPER_EFFECTIVE,
};
}  // namespace pokesim

///////////////// END OF src/Types/Enums/TypeEffectiveness.hpp /////////////////

//////////////////////// START OF src/Types/Random.hpp /////////////////////////

#include <cstdint>

namespace pokesim::types {
using probability = float;
using rngState = std::uint64_t;
using rngResult = std::uint32_t;
using percentChance = std::uint8_t;
using eventPossibilities = std::uint8_t;
}  // namespace pokesim::types

///////////////////////// END OF src/Types/Random.hpp //////////////////////////

///////////////////// START OF src/Utilities/TypeChart.hpp /////////////////////

#include <array>
#include <cstdint>
#include <initializer_list>

namespace pokesim::internal {
using TypeChartBase =
  std::array<std::array<pokesim::TypeEffectiveness, pokesim::dex::TOTAL_TYPE_COUNT>, pokesim::dex::TOTAL_TYPE_COUNT>;

struct TypeChart : private TypeChartBase {
 private:
  using constructorType = std::initializer_list<
    std::pair<pokesim::dex::Type, std::initializer_list<std::pair<pokesim::dex::Type, pokesim::TypeEffectiveness>>>>;

 public:
  constexpr TypeChart(const constructorType partialChart) : TypeChartBase() {
    for (auto& ratios : *this) {
      for (auto& effectiveness : ratios) {
        effectiveness = pokesim::TypeEffectiveness::NEUTRAL;
      }
    }

    for (const auto& [defending, ratios] : partialChart) {
      for (const auto& [attacking, effectiveness] : ratios) {
        at((std::uint8_t)attacking).at((std::uint8_t)defending) = effectiveness;
      }
    }
  }

  constexpr pokesim::TypeEffectiveness effectiveness(pokesim::dex::Type attacking, pokesim::dex::Type defending) const {
    return at((std::uint8_t)attacking).at((std::uint8_t)defending);
  }
};
}  // namespace pokesim::internal

////////////////////// END OF src/Utilities/TypeChart.hpp //////////////////////

/////////////////// START OF src/Types/MechanicConstants.hpp ///////////////////

#include <array>
#include <cmath>
#include <cstdint>

namespace pokesim {
struct MechanicConstants {
  static constexpr std::array<types::percentChance, 4U> CRIT_CHANCE_DIVISORS{24U, 8U, 2U, 1U};
  static constexpr std::uint8_t MAX_DAMAGE_ROLL_COUNT = 16U;

  static constexpr std::uint8_t MAX_TEAM_SIZE = 6U;
  static constexpr std::uint8_t MAX_ACTIVE_POKEMON_SLOTS = 2U;
  static constexpr std::uint8_t MAX_MOVE_SLOTS = 4U;
  static constexpr std::uint8_t MAX_TARGETS = 3U;

  static constexpr float CRIT_MULTIPLIER = 1.5F;
  static constexpr float STAB_MULTIPLIER = 1.5F;

  static constexpr std::uint8_t FIXED_POINT_SCALING_FACTOR = 12U;
  static constexpr std::uint16_t FIXED_POINT_SCALE = 1U << FIXED_POINT_SCALING_FACTOR;
  static constexpr std::uint16_t FIXED_POINT_HALF_SCALE = FIXED_POINT_SCALE / 2U;

  static constexpr internal::TypeChart TYPE_CHART{
    {dex::Type::NORMAL,
     {
       {dex::Type::GHOST, TypeEffectiveness::IMMUNE},

       {dex::Type::FIGHTING, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::GRASS,
     {
       {dex::Type::WATER, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::ELECTRIC, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::GRASS, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::GROUND, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::FIRE, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::ICE, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::POISON, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::FLYING, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::BUG, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::WATER,
     {
       {dex::Type::FIRE, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::WATER, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::ICE, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::STEEL, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::ELECTRIC, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::GRASS, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::FIRE,
     {
       {dex::Type::FIRE, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::GRASS, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::ICE, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::BUG, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::STEEL, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FAIRY, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::WATER, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::GROUND, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::ROCK, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::BUG,
     {
       {dex::Type::GRASS, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FIGHTING, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::GROUND, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::FIRE, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::FLYING, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::ROCK, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::FLYING,
     {
       {dex::Type::GROUND, TypeEffectiveness::IMMUNE},

       {dex::Type::GRASS, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FIGHTING, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::BUG, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::ELECTRIC, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::ICE, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::ROCK, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::POISON,
     {
       {dex::Type::GRASS, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FIGHTING, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::POISON, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::BUG, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FAIRY, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::GROUND, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::PSYCHIC, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::ELECTRIC,
     {
       {dex::Type::ELECTRIC, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FLYING, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::STEEL, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::GROUND, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::GROUND,
     {
       {dex::Type::ELECTRIC, TypeEffectiveness::IMMUNE},

       {dex::Type::POISON, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::ROCK, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::WATER, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::GRASS, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::ICE, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::FIGHTING,
     {
       {dex::Type::BUG, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::ROCK, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::DARK, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::FLYING, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::PSYCHIC, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::FAIRY, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::PSYCHIC,
     {
       {dex::Type::FIGHTING, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::PSYCHIC, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::BUG, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::GHOST, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::DARK, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::ROCK,
     {
       {dex::Type::NORMAL, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FIGHTING, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::POISON, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FLYING, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::WATER, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::GRASS, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::FIGHTING, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::GROUND, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::STEEL, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::ICE,
     {
       {dex::Type::ICE, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::FIRE, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::FIGHTING, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::ROCK, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::STEEL, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::GHOST,
     {
       {dex::Type::NORMAL, TypeEffectiveness::IMMUNE},
       {dex::Type::FIGHTING, TypeEffectiveness::IMMUNE},

       {dex::Type::POISON, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::BUG, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::GHOST, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::DARK, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::DRAGON,
     {
       {dex::Type::FIRE, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::WATER, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::ELECTRIC, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::GRASS, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::ICE, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::DRAGON, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::FAIRY, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::DARK,
     {
       {dex::Type::PSYCHIC, TypeEffectiveness::IMMUNE},

       {dex::Type::GHOST, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::DARK, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::FIGHTING, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::BUG, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::FAIRY, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::STEEL,
     {
       {dex::Type::POISON, TypeEffectiveness::IMMUNE},

       {dex::Type::NORMAL, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::GRASS, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::ICE, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FLYING, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::PSYCHIC, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::BUG, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::ROCK, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::DRAGON, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::STEEL, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::FAIRY, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::FIRE, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::FIGHTING, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::GROUND, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
    {dex::Type::FAIRY,
     {
       {dex::Type::DRAGON, TypeEffectiveness::IMMUNE},

       {dex::Type::FIGHTING, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::BUG, TypeEffectiveness::NOT_VERY_EFFECTIVE},
       {dex::Type::DARK, TypeEffectiveness::NOT_VERY_EFFECTIVE},

       {dex::Type::POISON, TypeEffectiveness::SUPER_EFFECTIVE},
       {dex::Type::STEEL, TypeEffectiveness::SUPER_EFFECTIVE},
     }},
  };
};
}  // namespace pokesim

//////////////////// END OF src/Types/MechanicConstants.hpp ////////////////////

////////////////// START OF src/Utilities/MaxSizedVector.hpp ///////////////////

#include <array>
#include <cassert>
#include <cstdint>
#include <initializer_list>

namespace pokesim::internal {
template <typename T, std::uint8_t N>
class maxSizedVector : private std::array<T, N> {
  using base = std::array<T, N>;
  std::uint8_t used = 0;

 public:
  using base::begin;
  using base::cbegin;
  using base::crbegin;
  using base::max_size;

  maxSizedVector() : base() {}
  maxSizedVector(std::initializer_list<T> list) : base() {
    for (const T& item : list) {
      push_back(item);
    }
  }

  constexpr std::uint8_t size() const noexcept { return used; }
  constexpr bool empty() const noexcept { return used == 0; }
  constexpr typename base::const_reference front() const noexcept { return *base::begin(); }
  constexpr typename base::const_reference back() const noexcept { return N ? *(end() - 1) : *end(); }

  constexpr typename base::const_reference at(std::uint8_t pos) const {
    POKESIM_ASSERT(pos < used, "Accessing value that isn't used.");
    return base::at(pos);
  }

  constexpr typename base::const_reference operator[](std::uint8_t pos) const {
    POKESIM_ASSERT(pos < used, "Accessing value that isn't used.");
    return base::operator[](pos);
  }

  typename base::reference at(std::uint8_t pos) {
    POKESIM_ASSERT(pos < used, "Accessing value that isn't used.");
    return base::at(pos);
  }

  typename base::reference operator[](std::uint8_t pos) {
    POKESIM_ASSERT(pos < used, "Accessing value that isn't used.");
    return base::operator[](pos);
  }

  void push_back(const T& value) {
    base::at(used) = value;
    used++;
  }

  void pop_back() {
    if (empty()) return;
    used--;
  }

  void pop_count(std::uint8_t remove) {
    POKESIM_ASSERT(remove <= used, "Removing more values than are used.");
    used -= remove;
  }

  template <class... Args>
  void emplace_back(Args&&... args) {
    base::at(used) = {args...};
    used++;
  }

  bool operator==(const maxSizedVector<T, N>& other) const noexcept {
    return used == other.used && std::equal(begin(), end(), other.begin());
  }

  typename base::const_iterator end() const noexcept { return base::begin() + used; }
  typename base::const_iterator cend() const noexcept { return end(); }
  typename base::const_reverse_iterator rend() const noexcept { return const_reverse_iterator(end()); }
  typename base::const_reverse_iterator crend() const noexcept { return rend(); }
};
}  // namespace pokesim::internal

/////////////////// END OF src/Utilities/MaxSizedVector.hpp ////////////////////

///////////////////////// START OF src/Types/State.hpp /////////////////////////

#include <cstdint>
#include <optional>
#include <type_traits>


namespace pokesim {
class Simulation;

namespace types {
using stateId = std::underlying_type_t<entity>;

using battleTurn = std::uint16_t;

using cloneIndex = std::underlying_type_t<entity>;

using teamPositionIndex = std::uint8_t;
using moveSlotPosition = std::uint8_t;

template <typename T>
using teamPositions = pokesim::internal::maxSizedVector<T, MechanicConstants::MAX_TEAM_SIZE>;
using teamOrder = types::teamPositions<types::teamPositionIndex>;

template <typename T>
using moveSlots = pokesim::internal::maxSizedVector<T, MechanicConstants::MAX_MOVE_SLOTS>;

template <typename T>
using sideSlots = pokesim::internal::maxSizedVector<T, MechanicConstants::MAX_ACTIVE_POKEMON_SLOTS>;

template <typename T>
using targets = pokesim::internal::maxSizedVector<T, MechanicConstants::MAX_TARGETS>;

using callback = void (*)(Simulation&);
using optionalCallback = std::optional<void (*)(Simulation&)>;
}  // namespace types
}  // namespace pokesim

////////////////////////// END OF src/Types/State.hpp //////////////////////////

/////////////// START OF src/Battle/Setup/PokemonStateSetup.hpp ////////////////

#include <type_traits>
#include <vector>


namespace pokesim {
// Tool to set properties of a Pokemon's state to an entity.
struct PokemonStateSetup : internal::StateSetupBase {
  PokemonStateSetup(types::registry& registry) : PokemonStateSetup(registry, registry.create()) {}
  inline PokemonStateSetup(types::registry& registry, types::entity entity);

  operator types::entity() const { return entity(); }

  /**
   * @brief Applies the defaults to the required properties for a Pokemon state.
   *
   * Some of the required properties are a blank `SpeciesName`, `Side`, and `Battle` component along with an
   * automatically set Id.
   */
  inline void initBlank();

  inline void setAutoID();
  inline void setID(types::stateId id);
  inline void setSpecies(dex::Species speciesName);

  inline void setSide(types::entity entity);
  inline void setBattle(types::entity entity);

  inline void setHp(types::stat hp);
  inline void setTypes(SpeciesTypes types);
  inline void setLevel(types::level level);
  inline void setGender(dex::Gender gender);
  inline void setAbility(dex::Ability ability);
  inline void setItem(dex::Item item);
  inline void setMoves(const std::vector<types::entity>& moveSlots);

  inline void setPostion(types::teamPositionIndex position);
  inline void setStatus(dex::Status status);

  inline void setNature(dex::Nature nature);
  inline void setEVs(types::ev hp, types::ev atk, types::ev def, types::ev spa, types::ev spd, types::ev spe);
  inline void setEVs(const Evs& evs);
  inline void setIVs(types::iv hp, types::iv atk, types::iv def, types::iv spa, types::iv spd, types::iv spe);
  inline void setIVs(const Ivs& ivs);

  template <typename BoostType>
  void setBoost(types::boost boost) {
    static_assert(
      std::is_same<AtkBoost, BoostType>() || std::is_same<DefBoost, BoostType>() ||
        std::is_same<SpaBoost, BoostType>() || std::is_same<SpdBoost, BoostType>() ||
        std::is_same<SpeBoost, BoostType>(),
      "Boosts can only be applied to a Pokemon boost stat struct (excluding HP).");
    handle.emplace<BoostType>(boost);
  };

  template <typename StatType>
  void setStat(types::stat stat) {
    static_assert(
      std::is_same<stat::Hp, StatType>() || std::is_same<stat::Atk, StatType>() ||
        std::is_same<stat::Def, StatType>() || std::is_same<stat::Spa, StatType>() ||
        std::is_same<stat::Spd, StatType>() || std::is_same<stat::Spe, StatType>(),
      "Stats can only be applied to a Pokemon stat struct.");
    handle.emplace<StatType>(stat);
  };
};
}  // namespace pokesim

//////////////// END OF src/Battle/Setup/PokemonStateSetup.hpp /////////////////

//////////////// START OF src/Battle/Setup/BattleStateSetup.hpp ////////////////

#include <optional>
#include <vector>


namespace pokesim {
struct SimulateTurnOptions;
struct CalculateDamageOptions;
struct AnalyzeEffectOptions;

// Tool to set properties of a battle's state to an entity.
struct BattleStateSetup : internal::StateSetupBase {
  BattleStateSetup(types::registry& registry) : BattleStateSetup(registry, registry.create()) {}
  inline BattleStateSetup(types::registry& registry, types::entity entity);

  /**
   * @brief Applies the defaults to the required properties for a battle state.
   *
   * @details Some of the required properties and their defaults:
   * - Turn: 0
   * - Probability: 1
   * - Id: The number of existing battle states
   * - Sides: Unassigned entities for P1 and P2
   * - ActionQueue: An empty queue
   */
  inline void initBlank();

  inline void setAutoID();
  inline void setID(types::stateId id);
  inline void setSide(types::entity sideEntity);

  // If a seed is not provided, the seed is set to a random number based on the current time in nanoseconds.
  inline void setRNGSeed(std::optional<types::rngState> seed = std::nullopt);
  inline void setActionQueue(const std::vector<types::entity>& queue);
  inline void setTurn(types::battleTurn turn);
  inline void setCurrentActionTarget(types::targets<types::entity> actionTargets);
  inline void setCurrentActionSource(types::entity actionSource);
  inline void setCurrentActionMove(types::entity actionMove);
  inline void setProbability(types::probability probability);

  inline std::vector<BattleStateSetup> clone(std::optional<types::cloneIndex> cloneCount = std::nullopt);
};
}  // namespace pokesim

///////////////// END OF src/Battle/Setup/BattleStateSetup.hpp /////////////////

/////////////////// START OF src/Battle/Setup/EnumToTag.hpp ////////////////////

namespace pokesim {
namespace ability::tags {
// Assigns an ability's tag to a handle
inline void enumToTag(dex::Ability ability, types::handle handle);
}  // namespace ability::tags

namespace item::tags {
// Assigns an item's tag to a handle
inline void enumToTag(dex::Item item, types::handle handle);
}  // namespace item::tags

namespace nature::tags {
// Assigns a nature's tag to a handle
inline void enumToTag(dex::Nature nature, types::handle handle);
}  // namespace nature::tags

namespace status::tags {
// Assigns a status' tag to a handle
inline void enumToTag(dex::Status status, types::handle& handle);
}  // namespace status::tags
}  // namespace pokesim

//////////////////// END OF src/Battle/Setup/EnumToTag.hpp /////////////////////

///////////////////////// START OF src/Types/Move.hpp //////////////////////////

#include <cstdint>

namespace pokesim::types {
using pp = std::uint8_t;
using basePower = std::uint8_t;
using baseAccuracy = std::uint8_t;
using moveHits = std::uint8_t;
using baseEffectChance = std::uint8_t;

using priority = std::int8_t;
using fractionalPriority = bool;
}  // namespace pokesim::types

////////////////////////// END OF src/Types/Move.hpp ///////////////////////////

///////////////// START OF src/Battle/Setup/MoveStateSetup.hpp /////////////////

namespace pokesim {
// Tool to set properties of a move's state to an entity.
struct MoveStateSetup : internal::StateSetupBase {
  MoveStateSetup(types::registry& registry) : MoveStateSetup(registry, registry.create()) {}
  MoveStateSetup(types::registry& registry, types::entity entity) : StateSetupBase(registry, entity) {}

  /**
   * @brief Applies the defaults to the required properties for a move state.
   *
   * Some of the required properties are a blank `MoveName`, `Pp`, and `MaxPp` component.
   */
  inline void initBlank();

  inline void setName(dex::Move moveName);
  inline void setPP(types::pp pp);
  inline void setMaxPP(types::pp maxPp);
};
}  // namespace pokesim

////////////////// END OF src/Battle/Setup/MoveStateSetup.hpp //////////////////

////////////////// START OF src/Types/Enums/PlayerSideId.hpp ///////////////////

#include <cstdint>

namespace pokesim {
enum class PlayerSideId : std::uint8_t {
  NONE = 0,
  P1 = 1,
  P2 = 2,
};
}

/////////////////// END OF src/Types/Enums/PlayerSideId.hpp ////////////////////

///////////////// START OF src/Battle/Setup/SideStateSetup.hpp /////////////////

#include <vector>


namespace pokesim {
struct PokemonStateSetup;

// Tool to set properties of a player's side state to an entity.
struct SideStateSetup : internal::StateSetupBase {
  SideStateSetup(types::registry& registry, PlayerSideId playerSideId)
      : SideStateSetup(registry, registry.create(), playerSideId) {}
  inline SideStateSetup(types::registry& registry, types::entity entity, PlayerSideId playerSideId);
  /**
   * @brief Applies the defaults to the required properties for a player side's state.
   *
   * Some of the required properties are a blank `Battle`, `Side`, and `FoeSide` component.
   */
  inline void initBlank();

  inline void setTeam(std::vector<PokemonStateSetup>& team);
  inline void setOpponent(types::entity entity);
  inline void setBattle(types::entity entity);
  inline void setPlayerSide(PlayerSideId playerSideId);
};
}  // namespace pokesim

////////////////// END OF src/Battle/Setup/SideStateSetup.hpp //////////////////

//////////// START OF src/CalcDamage/Setup/CalcDamageInputSetup.hpp ////////////

namespace pokesim {
class Pokedex;

namespace calc_damage {
struct InputSetup {
 protected:
  types::registry& registry;
  types::entity moveEntity = entt::null;

 public:
  inline InputSetup(types::registry& registry);

  inline void setup(
    types::entity battleEntity, types::entity sourceEntity, types::entity targetEntity, dex::Move move,
    const Pokedex& pokedex);

  inline types::entity entity() const;
};
}  // namespace calc_damage
}  // namespace pokesim

///////////// END OF src/CalcDamage/Setup/CalcDamageInputSetup.hpp /////////////

////////////// START OF src/Components/EntityHolders/Current.hpp ///////////////

#include <vector>

namespace pokesim {
struct CurrentAction {
  types::entity val{};
};

struct NextAction {
  types::entity val{};
};

struct CurrentActionTargets {
  types::targets<types::entity> val{};
  const types::entity& only() const {
    POKESIM_ASSERT(
      val.size() == 1,
      "This method is supposed to get the first target when there's only one target stored.");
    return val[0];
  };
};

struct CurrentActionSource {
  types::entity val{};
};

struct CurrentActionMoves {
  std::vector<types::entity> val{};
};

struct CurrentActionMoveSlot {
  types::entity val{};
};
}  // namespace pokesim

/////////////// END OF src/Components/EntityHolders/Current.hpp ////////////////

/////////////////// START OF src/Components/Tags/Current.hpp ///////////////////

namespace pokesim::tags {
// Current Action Tag: The move that is being processed by the simulator
struct CurrentActionMove {};
// Current Action Tag: The move slot the current action's move was chosen and will deduct PP from
struct CurrentActionMoveSlot {};
// Current Action Tag: The target of the active move
struct CurrentActionMoveTarget {};
// Current Action Tag: The user of the active move
struct CurrentActionMoveSource {};
}  // namespace pokesim::tags

//////////////////// END OF src/Components/Tags/Current.hpp ////////////////////

//////////////// START OF src/Components/CalcDamage/Aliases.hpp ////////////////

namespace pokesim::calc_damage {
using Attacker = CurrentActionSource;
using Defenders = CurrentActionTargets;
using UsedMoves = CurrentActionMoves;

namespace tags {
using Attacker = pokesim::tags::CurrentActionMoveSource;
using Defender = pokesim::tags::CurrentActionMoveTarget;
using UsedMove = pokesim::tags::CurrentActionMove;
}  // namespace tags
}  // namespace pokesim::calc_damage

///////////////// END OF src/Components/CalcDamage/Aliases.hpp /////////////////

//////////////////// START OF src/Components/Decisions.hpp /////////////////////

#include <optional>

namespace pokesim {
struct SlotDecision {
  Slot sourceSlot = Slot::NONE;
  Slot targetSlot = Slot::NONE;

  bool megaEvolve = false;
  bool primalRevert = false;
  bool dynamax = false;
  bool terastallize = false;

  std::optional<dex::Move> moveChoice = std::nullopt;
  std::optional<dex::Item> itemChoice = std::nullopt;

  bool operator==(const SlotDecision& other) const {
    return sourceSlot == other.sourceSlot && targetSlot == other.targetSlot && megaEvolve == other.megaEvolve &&
           primalRevert == other.primalRevert && dynamax == other.dynamax && terastallize == other.terastallize &&
           moveChoice == other.moveChoice && itemChoice == other.itemChoice;
  }
};

namespace types {
using slotDecisions = types::sideSlots<SlotDecision>;
}

struct SideDecision {
  PlayerSideId sideId = PlayerSideId::NONE;
  internal::variant<types::slotDecisions, types::teamOrder> decisions{};

  bool operator==(const SideDecision other) const { return sideId == other.sideId && decisions == other.decisions; }
};
}  // namespace pokesim

///////////////////// END OF src/Components/Decisions.hpp //////////////////////

//////////// START OF src/Components/EntityHolders/ActionQueue.hpp /////////////

#include <vector>

namespace pokesim {
// Contains the list of action entities queued up to be simulated for a battle's current turn.
struct ActionQueue {
  std::vector<types::entity> val{};
};
}  // namespace pokesim

///////////// END OF src/Components/EntityHolders/ActionQueue.hpp //////////////

//////////////// START OF src/Components/EntityHolders/Side.hpp ////////////////

namespace pokesim {
// Contains the entity pointing to the player 1 or player 2 side of a battle.
struct Side {
  types::entity val{};
};
}  // namespace pokesim

///////////////// END OF src/Components/EntityHolders/Side.hpp /////////////////

/////////////// START OF src/Components/EntityHolders/Sides.hpp ////////////////

#include <array>

namespace pokesim {
// Contains the entities pointing to the two sides of a battle.
struct Sides {
  std::array<types::entity, 2U> val{};

  types::entity& p1() { return val[0]; };
  types::entity& p2() { return val[1]; };
  const types::entity& p1() const { return val[0]; };
  const types::entity& p2() const { return val[1]; };
};
}  // namespace pokesim

//////////////// END OF src/Components/EntityHolders/Sides.hpp /////////////////

///////////////// START OF src/Components/Tags/PokemonTags.hpp /////////////////

namespace pokesim::tags {
struct Pokemon {};

// Indicates the Pokemon is currently in a battle
struct ActivePokemon {};

struct AtkStatUpdateRequired {};
struct DefStatUpdateRequired {};
struct SpdStatUpdateRequired {};
struct SpaStatUpdateRequired {};
struct SpeStatUpdateRequired {};

struct Fainted {};
}  // namespace pokesim::tags

////////////////// END OF src/Components/Tags/PokemonTags.hpp //////////////////

/////////////// START OF src/Components/Tags/SimulationTags.hpp ////////////////

namespace pokesim::tags {
struct SimulateTurn {};
struct CalculateDamage {};
struct AnalyzeEffect {};
}  // namespace pokesim::tags

//////////////// END OF src/Components/Tags/SimulationTags.hpp /////////////////

///////////// START OF src/Components/EntityHolders/MoveEffect.hpp /////////////

namespace pokesim {
// Contains the entity of what the primary or secondary effect of a move does.
struct MoveEffect {
  bool primary = true;
  types::entity val{};
};
}  // namespace pokesim

////////////// END OF src/Components/EntityHolders/MoveEffect.hpp //////////////

/////////////////// START OF src/Types/Enums/ActionOrder.hpp ///////////////////

#include <cstdint>
#include <limits>
#include <type_traits>

namespace pokesim {
enum class ActionOrder : std::uint8_t {
  NONE = std::numeric_limits<std::underlying_type_t<ActionOrder>>::max(),
  TEAM = 1,
  START = 2,
  BEFORE_TURN = 4,
  ITEM = BEFORE_TURN,

  SWITCH = 103,

  MOVE = 200,

  RESIDUAL = 254,
};
}

//////////////////// END OF src/Types/Enums/ActionOrder.hpp ////////////////////

////////////////// START OF src/Types/Enums/AddedTargets.hpp ///////////////////

#include <cstdint>

namespace pokesim {
enum class AddedTargetOptions : std::uint8_t {
  NONE = 0b00000000,
  TARGET_ALLY = 0b00000001,
  USER_ALLY = 0b00000010,
  TARGET_SIDE = 0b00000100,
  USER_SIDE = 0b00001000,
  FIELD = 0b00010000,
};
}

/////////////////// END OF src/Types/Enums/AddedTargets.hpp ////////////////////

////////////////// START OF src/Types/Enums/BattleFormat.hpp ///////////////////

#include <cstdint>

namespace pokesim {
// Denotes if the simulated battle is a single or double battle
enum class BattleFormat : std::uint8_t {
  SINGLES_BATTLE_FORMAT = 1,
  DOUBLES_BATTLE_FORMAT = 2,
};
}  // namespace pokesim

/////////////////// END OF src/Types/Enums/BattleFormat.hpp ////////////////////

///////////////// START OF src/Types/Enums/DamageRollKind.hpp //////////////////

#include <cstdint>

namespace pokesim {
enum class DamageRollKind : std::uint8_t {
  NONE = 0b00000000,
  AVERAGE_DAMAGE = 0b000000001,
  MAX_DAMAGE = 0b00000010,
  MIN_DAMAGE = 0b00000100,
  GUARANTEED_CRIT_CHANCE = 0b00001000,
  ALL_DAMAGE_ROLLS = 0b00010000,
};
}  // namespace pokesim

////////////////// END OF src/Types/Enums/DamageRollKind.hpp ///////////////////

////////////////// START OF src/Types/Enums/GameMechanics.hpp //////////////////

#include <cstdint>

namespace pokesim {
// Game the simulator is imitating the mechanics of
enum class GameMechanics : std::uint8_t {
  NONE = 0,
  SWORD_SHIELD,
  BRILLIANT_DIAMOND_SHINING_PEARL,
  SCARLET_VIOLET,
};
}  // namespace pokesim

/////////////////// END OF src/Types/Enums/GameMechanics.hpp ///////////////////

////////////////// START OF src/Types/Enums/MoveCategory.hpp ///////////////////

#include <cstdint>

namespace pokesim::dex {

enum class MoveCategory : std::uint8_t {
  PHYSICAL,
  SPECIAL,
  STATUS,
};
}  // namespace pokesim::dex

/////////////////// END OF src/Types/Enums/MoveCategory.hpp ////////////////////

/////////////////// START OF src/Types/Enums/MoveTarget.hpp ////////////////////

#include <cstdint>

namespace pokesim {
enum class MoveTarget : std::uint8_t {
  NONE = 0,
  ANY_SINGLE_TARGET,  // Targets one Pokemon other than the move's user
  ANY_SINGLE_FOE,     // Targets one foe
  ANY_SINGLE_ALLY,    // Targets one ally
  ALLY_OR_SELF,       // Targets either one ally or the move's user
  SELF,               // Targets the move's user

  ALL_FOES,         // Targets every active foe
  ALLIES_AND_FOES,  // Targets every active foe and the move user's allies
  ALLIES_AND_SELF,  // Targets the move user's allies and the user

  FOE_SIDE,   // Targets the opponent's side
  ALLY_SIDE,  // Targets the move user's side
  FIELD,      // Targets the field or all Pokemon at once

  ALLY_TEAM,    // Targets all non-fainted Pokemon on the user's team
  RETALIATION,  // Targets the last Pokemon to damage the user during a turn
  RANDOM_FOE,   // Targets a random foe
};
}

//////////////////// END OF src/Types/Enums/MoveTarget.hpp /////////////////////

////////////////// START OF src/Types/Enums/StabBoostKind.hpp //////////////////

#include <cstdint>

namespace pokesim {
enum class StabBoostKind : std::uint8_t {
  NONE = 100,
  STANDARD = 150,
  STELLAR_NON_STAB = 120,
  ADAPTABILITY_OR_STELLAR_STAB_OR_TERA_STAB = 200,
  ADAPTABILITY_AND_TERA_STAB = 225,
};
}

/////////////////// END OF src/Types/Enums/StabBoostKind.hpp ///////////////////

/////////////////////// START OF src/Pokedex/Pokedex.hpp ///////////////////////

namespace pokesim {

/**
 * @brief Holds the data of each species, item, and move in a simulation.
 *
 * @details It is designed so only one instance of this class is needed while simulating a particular battle as the
 * entirety of all the move, item, and species, information that might be needed for a battle is known when it starts.
 * In theory, all the information within the game mechanics chosen or information for multiple battles could be loaded
 * into one Pokedex instance and used repeatedly, but that is not recommended as this class is optimized for instances
 * holding a small amount of data.
 */
class Pokedex {
 private:
  types::registry dexRegistry{};

  entt::dense_map<dex::Species, types::entity> speciesMap{};
  entt::dense_map<dex::Item, types::entity> itemsMap{};
  entt::dense_map<dex::Move, types::entity> movesMap{};
  entt::dense_map<dex::Ability, types::entity> abilitiesMap{};

  template <typename Build, typename T>
  inline void load(entt::dense_map<T, types::entity>& map, const entt::dense_set<T>& list, Build build);

  inline types::entity buildSpecies(dex::Species species, types::registry& registry, bool forActiveMove) const;
  inline types::entity buildMove(dex::Move move, types::registry& registry, bool forActiveMove) const;
  inline types::entity buildItem(dex::Item item, types::registry& registry, bool forActiveMove) const;
  inline types::entity buildAbility(dex::Ability ability, types::registry& registry, bool forActiveMove) const;

 public:
  /**
   * @brief The data for the Pokedex will be based the this game's data.
   * For example, if this is set to DIAMOND_PEARL_GAME_MECHANICS, Clefable's data will list it as a Normal type, but if
   * it's set to BRILLIANT_DIAMOND_SHINING_PEARL_GAME_MECHANICS, Clefable will be listed as a Fairy type.
   */
  const GameMechanics mechanics;

  Pokedex(GameMechanics mechanics_) : mechanics(mechanics_) {}

  /**
   * @brief Calls the load functions for a set of species to add their data to a Pokedex's storage.
   *
   * @details The Pokedex class is designed to store the minimum amount of data needed to run the simulation a Pokedex
   * instance is assigned to, so if a battle is being simulated where both sides have 6 Pokemon each, then this function
   * should only be called with a set of those 12 Pokemon's species.
   *
   * @note Only call this once per species per Pokedex instance.
   */
  inline void loadSpecies(const entt::dense_set<dex::Species>& speciesSet);

  /**
   * @brief Calls the load functions for a set of items to add their data to a Pokedex's storage.
   *
   * @details The Pokedex class is designed to store the minimum amount of data needed to run the simulation a Pokedex
   * instance is assigned to, so if a battle is being simulated where both sides have 6 Pokemon each, then this function
   * should only be called with a set of those 12 Pokemon's items.
   *
   * @note Only call this once per item per Pokedex instance.
   */
  inline void loadItems(const entt::dense_set<dex::Item>& itemSet);

  /**
   * @brief Calls the load functions for a set of moves to add their data to a Pokedex's storage.
   *
   * @details The Pokedex class is designed to store the minimum amount of data needed to run the simulation a Pokedex
   * instance is assigned to, so if one turn of a single battle is being simulated and the opposing Pokemon have 4
   * moves, then this function should only be called with a set of those 8 moves.
   *
   * @note Only call this once per move per Pokedex instance.
   */
  inline void loadMoves(const entt::dense_set<dex::Move>& moveSet);

  /**
   * @brief Calls the load functions for a set of abilities to add their data to a Pokedex's storage.
   *
   * @details The Pokedex class is designed to store the minimum amount of data needed to run the simulation a Pokedex
   * instance is assigned to, so if a battle is being simulated where both sides have 6 Pokemon each, then this function
   * should only be called with a set of those 12 Pokemon's abilities.
   *
   * @note Only call this once per ability per Pokedex instance.
   */
  inline void loadAbilities(const entt::dense_set<dex::Ability>& abilitySet);

  /**
   * @brief Returns references to the given dex data components for a species
   *
   * @warning
   * Attempting to get a component from a species that doesn't own it or an unloaded species results in undefined
   * behavior.
   *
   * @tparam T Type of data to retrieve. Valid types: TODO(aed3): Add in list
   */
  template <typename... T>
  auto getSpeciesData(dex::Species species) const {
    // POKESIM_ASSERT(registry.all_of<T...>(speciesMap.at(species)), "Species does not contain at least one of the
    // component types.");
    return dexRegistry.get<T...>(speciesMap.at(species));
  }

  /**
   * @brief Returns references to the given dex data components for an item
   *
   * @warning
   * Attempting to get a component from an item that doesn't own it or an unloaded item results in undefined behavior.
   *
   * @tparam T Type of data to retrieve. Valid types: TODO(aed3): Add in list
   */
  template <typename... T>
  auto getItemData(dex::Item item) const {
    return dexRegistry.get<T...>(itemsMap.at(item));
  }

  /**
   * @brief Returns references to the given dex data components for a move
   *
   * @warning
   * Attempting to get a component from a move that doesn't own it or an unloaded item results in undefined behavior.
   *
   * @tparam T Type of data to retrieve. Valid types: TODO(aed3): Add in list
   */
  template <typename... T>
  auto getMoveData(dex::Move move) const {
    return dexRegistry.get<T...>(movesMap.at(move));
  }

  template <typename... T>
  auto getEffectData(MoveEffect effect) const {
    return dexRegistry.get<T...>(effect.val);
  }

  template <typename... T>
  bool speciesHas(dex::Species species) const {
    return dexRegistry.all_of<T...>(speciesMap.at(species));
  }

  template <typename... T>
  bool itemHas(dex::Item item) const {
    return dexRegistry.all_of<T...>(itemsMap.at(item));
  }

  template <typename... T>
  bool moveHas(dex::Move move) const {
    return dexRegistry.all_of<T...>(movesMap.at(move));
  }

  template <typename... T>
  bool effectHas(MoveEffect effect) const {
    return dexRegistry.all_of<T...>(effect.val);
  }

  inline types::entity buildActionMove(dex::Move move, types::registry& registry) const;
};
}  // namespace pokesim

//////////////////////// END OF src/Pokedex/Pokedex.hpp ////////////////////////

///////////////// START OF src/Components/Tags/BattleTags.hpp //////////////////

namespace pokesim::tags {
struct Battle {};
struct Side {};

// Battle Turn State Tag: When a battle is in the middle of a turn
struct BattleMidTurn {};
// Battle Turn State Tag: When a battle has ended
struct BattleEnded {};
}  // namespace pokesim::tags

////////////////// END OF src/Components/Tags/BattleTags.hpp ///////////////////

////////////////// START OF src/Components/Tags/Selection.hpp //////////////////

#include <cstdint>
#include <vector>

namespace pokesim::tags {
struct SelectedForViewBattle {};
struct SelectedForViewSide {};
struct SelectedForViewPokemon {};
struct SelectedForViewMove {};
}  // namespace pokesim::tags

/////////////////// END OF src/Components/Tags/Selection.hpp ///////////////////

/////////////////////// START OF src/Utilities/Tags.hpp ////////////////////////

namespace pokesim {
template <typename... T>
struct Tags {};
}  // namespace pokesim

//////////////////////// END OF src/Utilities/Tags.hpp /////////////////////////

/////////////////// START OF src/Utilities/RegistryLoop.hpp ////////////////////

#include <type_traits>


namespace pokesim::internal {
template <auto Function, typename...>
struct RegistryLoop;

template <auto Function, typename... ExtraTags, typename... Exclude, typename... Include, typename... PassedInArgs>
struct RegistryLoop<
  Function, Tags<ExtraTags...>, entt::exclude_t<Exclude...>, entt::get_t<Include...>, PassedInArgs...> {
  static_assert(
    std::conjunction_v<std::is_empty<ExtraTags>...>,
    "Tags should only be empty classes or structs that are not arguments to the function being looped over."
    "Using non-empty classes here with prevent the function from being called.");
  static_assert(
    std::conjunction_v<std::is_class<ExtraTags>...>,
    "Only classes or structs can be added to entities,"
    "so including not that as a tag will prevent the function from being called.");
  static_assert(
    std::conjunction_v<std::is_class<Exclude>...>,
    "Only classes or structs can be added to entities,"
    "so including not that as a function argument will prevent the function from being called.");
  static_assert(
    std::conjunction_v<std::is_class<Include>...>,
    "Only classes or structs can be added to entities,"
    "so including not that as a function argument will prevent the function from being called.");

 private:
  template <typename Signature>
  struct RegistryLoopInternal;
  template <bool, typename TupleFrom, typename TupleTo>
  struct ParameterShifter;

  static constexpr bool usesExclude = sizeof...(Exclude) > 0;
  static constexpr bool usesInclude = sizeof...(Include) > 0;
  static constexpr auto passedInArgsSize = sizeof...(PassedInArgs);

  template <typename TupleFromHead, typename... TupleFromTail, typename... TupleToTail>
  struct ParameterShifter<false, Tags<TupleFromHead, TupleFromTail...>, Tags<TupleToTail...>>
      : ParameterShifter<
          sizeof...(TupleFromTail) == passedInArgsSize, Tags<TupleFromTail...>, Tags<TupleToTail..., TupleFromHead>> {};

  // Separates the function argument types used to select entities from those passed in from the registry loop caller.
  template <typename... TupleFromTail, typename... RegistryArgs>
  struct ParameterShifter<true, Tags<TupleFromTail...>, Tags<RegistryArgs...>> {
   private:
    using FirstType = std::tuple_element_t<0, std::tuple<RegistryArgs...>>;
    static constexpr bool hasRegistryFirst = std::is_same_v<FirstType, types::registry&>;
    static constexpr bool hasHandleFirst = std::is_same_v<FirstType, types::handle>;

    static_assert(sizeof...(RegistryArgs) > 0, "The function must accept at least 1 argument to work here.");
    static_assert(
      !std::is_same_v<std::decay_t<FirstType>, types::registry> || hasRegistryFirst,
      "If the first argument is a registry, it must be a non-constant reference.");
    static_assert(
      !std::is_same_v<std::decay_t<FirstType>, types::handle> || hasHandleFirst,
      "If the first argument is a handle, it must be a non-constant value.");

    template <typename... Args>
    static constexpr void argChecks() {
      static_assert(
        std::conjunction_v<std::is_class<std::decay_t<Args>>...>,
        "Only classes or structs can be added to entities,"
        "so including not that as a tag will prevent the function from being called.");
      static_assert(
        !std::disjunction_v<std::is_empty<std::decay_t<Args>>...>,
        "Empty classes or structs shouldn't be passed into a function: they won't do anything.");
      static_assert(
        std::conjunction_v<std::is_copy_assignable<std::decay_t<Args>>...>,
        "Without the ability to be copied, an argument could not have been added to an entity,"
        "preventing the function from being called.");
      static_assert(
        sizeof...(Args) + sizeof...(ExtraTags) + sizeof...(Include) > 0,
        "At least 1 type must be present to pick the entities to loop over.");
    }

    template <typename... ViewArgs>
    static auto getView(types::registry& registry) {
      argChecks<ViewArgs...>();

      if constexpr (usesExclude) {
        return registry.view<ExtraTags..., std::decay_t<ViewArgs>..., Include...>(entt::exclude<Exclude...>);
      }
      else {
        return registry.view<ExtraTags..., std::decay_t<ViewArgs>..., Include...>();
      }
    }

    template <typename... GroupArgs>
    static auto getGroup(types::registry& registry) {
      argChecks<GroupArgs...>();

      if constexpr (usesExclude) {
        return registry.group<ExtraTags..., std::decay_t<GroupArgs>...>(
          entt::exclude<Exclude...>,
          entt::get<Include...>);
      }
      else if constexpr (usesInclude) {
        return registry.group<ExtraTags..., std::decay_t<GroupArgs>...>(entt::get<Include...>);
      }
      else {
        return registry.group<ExtraTags..., std::decay_t<GroupArgs>...>();
      }
    }

    template <auto getList>
    static auto run(types::registry& registry, const PassedInArgs&... passedInArgs) {
      auto list = getList(registry);
      list.each([&registry, &passedInArgs...](types::entity entity, auto&&... args) {
        (void)entity;
        if constexpr (hasRegistryFirst) {
          Function(registry, args..., passedInArgs...);
        }
        else if constexpr (hasHandleFirst) {
          Function(types::handle{registry, entity}, args..., passedInArgs...);
        }
        else {
          Function(args..., passedInArgs...);
        }
      });
      return list;
    }

    template <typename, typename... Rest>
    static auto runViewNoFirstArg(types::registry& registry, const PassedInArgs&... passedInArgs) {
      return run<getView<Rest...>>(registry, passedInArgs...);
    }

    template <typename, typename... Rest>
    static auto runGroupNoFirstArg(types::registry& registry, const PassedInArgs&... passedInArgs) {
      return run<getGroup<Rest...>>(registry, passedInArgs...);
    }

    static constexpr void paramShiftCheck() {
      static_assert(
        sizeof...(TupleFromTail) == passedInArgsSize,
        "The parameter shifter works if TupleFromTail is the same as the PassedInArgs.");
      static_assert(
        std::conjunction_v<std::is_same<std::decay_t<TupleFromTail>, std::decay_t<PassedInArgs>>...>,
        "The parameter shifter works if TupleFromTail is the same as the PassedInArgs.");
    }

   public:
    static auto view(types::registry& registry, const PassedInArgs&... passedInArgs) {
      paramShiftCheck();
      if constexpr (hasRegistryFirst || hasHandleFirst) {
        return runViewNoFirstArg<RegistryArgs...>(registry, passedInArgs...);
      }
      else {
        return run<getView<RegistryArgs...>>(registry, passedInArgs...);
      }
    }

    static auto group(types::registry& registry, const PassedInArgs&... passedInArgs) {
      paramShiftCheck();
      if constexpr (hasRegistryFirst || hasHandleFirst) {
        return runGroupNoFirstArg<RegistryArgs...>(registry, passedInArgs...);
      }
      else {
        return run<getGroup<RegistryArgs...>>(registry, passedInArgs...);
      }
    }
  };

  template <typename... RegistryArgs>
  struct RegistryLoopInternal<void (*)(RegistryArgs...)> {
    using WithPassedArgs = ParameterShifter<false, Tags<RegistryArgs...>, Tags<>>;
    using NoPassedArgs = ParameterShifter<true, Tags<>, Tags<RegistryArgs...>>;

    static auto view(types::registry& registry, const PassedInArgs&... passedInArgs) {
      if constexpr (passedInArgsSize > 0) {
        return WithPassedArgs::view(registry, passedInArgs...);
      }
      else {
        return NoPassedArgs::view(registry, passedInArgs...);
      }
    }

    static auto group(types::registry& registry, const PassedInArgs&... passedInArgs) {
      if constexpr (passedInArgsSize > 0) {
        return WithPassedArgs::group(registry, passedInArgs...);
      }
      else {
        return NoPassedArgs::group(registry, passedInArgs...);
      }
    }
  };

  using FunctionSig = std::decay_t<decltype(Function)>;

 public:
  static auto view(types::registry& registry, const PassedInArgs&... passedInArgs) {
    return RegistryLoopInternal<FunctionSig>::view(registry, passedInArgs...);
  }

  static auto group(types::registry& registry, const PassedInArgs&... passedInArgs) {
    return RegistryLoopInternal<FunctionSig>::group(registry, passedInArgs...);
  }
};
}  // namespace pokesim::internal

//////////////////// END OF src/Utilities/RegistryLoop.hpp /////////////////////

//////////////// START OF src/Simulation/RegistryContainer.hpp /////////////////

#include <cstdint>
#include <iterator>
#include <type_traits>
#include <vector>

namespace pokesim::internal {
class RegistryContainer {
 public:
  using SelectionFunction = entt::delegate<std::vector<types::entity>(const types::registry&)>;

 private:
  template <typename, typename, typename...>
  friend struct SelectForView;

  using SelectionFunctionList = std::vector<SelectionFunction>;
  SelectionFunctionList battleSelection{};
  SelectionFunctionList sideSelection{};
  SelectionFunctionList pokemonSelection{};
  SelectionFunctionList moveSelection{};

  template <typename Selection>
  SelectionFunctionList& selectedFunctions() {
    if constexpr (std::is_same_v<tags::SelectedForViewBattle, Selection>) {
      return battleSelection;
    }
    else if constexpr (std::is_same_v<tags::SelectedForViewSide, Selection>) {
      return sideSelection;
    }
    else if constexpr (std::is_same_v<tags::SelectedForViewPokemon, Selection>) {
      return pokemonSelection;
    }
    else {
      return moveSelection;
    }
  }

  template <typename Selection>
  const SelectionFunctionList& selectedFunctions() const {
    if constexpr (std::is_same_v<tags::SelectedForViewBattle, Selection>) {
      return battleSelection;
    }
    else if constexpr (std::is_same_v<tags::SelectedForViewSide, Selection>) {
      return sideSelection;
    }
    else if constexpr (std::is_same_v<tags::SelectedForViewPokemon, Selection>) {
      return pokemonSelection;
    }
    else {
      return moveSelection;
    }
  }

  template <typename Selection, typename GetNewSelection, typename GetUnmatchedSelection>
  std::size_t select(
    GetNewSelection getNewSelection, GetUnmatchedSelection getUnmatchedSelection, SelectionFunction selectionFunction,
    bool isEmptySelection = false) {
    auto list = getNewSelection(registry);
    if (list.empty()) {
      return 0U;
    }

    bool narrowSelection = hasActiveSelection<Selection>();
    std::size_t finalSelectionSize = 0U;

    if (narrowSelection && isEmptySelection) {
      selectedFunctions<Selection>().push_back(selectionFunction);
      return registry.view<Selection>().size();
    }
    if (narrowSelection) {
      auto unmatchedSelections = getUnmatchedSelection(registry);
      std::size_t totalSelected = registry.view<Selection>().size();
      std::size_t unmatchedSelectionSize = unmatchedSelections.size();
      if (unmatchedSelectionSize == totalSelected) {
        return 0U;
      }

      registry.remove<Selection>(unmatchedSelections.begin(), unmatchedSelections.end());

      POKESIM_ASSERT(
        unmatchedSelectionSize < totalSelected,
        "The number of elements removed from the active selection must be less than the number of elements selected.");
      finalSelectionSize = totalSelected - unmatchedSelectionSize;
    }
    else {
      registry.clear<Selection>();
      registry.insert<Selection>(list.begin(), list.end());
      finalSelectionSize = list.size();
    }

    selectedFunctions<Selection>().push_back(selectionFunction);

    return finalSelectionSize;
  }

  template <typename Selection, typename Required, typename... ComponentsToSelect, typename... ComponentsToExclude>
  std::size_t select(entt::exclude_t<ComponentsToExclude...> exclude) {
    auto getNewSelection = [&exclude](types::registry& reg) {
      auto view = reg.view<Required, ComponentsToSelect...>(exclude);
      return std::vector<types::entity>{view.begin(), view.end()};
    };
    auto getUnmatchedSelection = [](types::registry& reg) {
      auto view = reg.view<Selection, ComponentsToExclude...>(entt::exclude<ComponentsToSelect...>);
      return std::vector<types::entity>{view.begin(), view.end()};
    };
    SelectionFunction selectionFunction{[](const void*, const types::registry& reg) {
      auto view = reg.view<Required, ComponentsToSelect...>(entt::exclude<ComponentsToExclude...>);
      return std::vector<types::entity>{view.begin(), view.end()};
    }};

    return select<Selection>(
      getNewSelection,
      getUnmatchedSelection,
      selectionFunction,
      sizeof...(ComponentsToSelect) == 0);
  }

  template <typename Selection>
  std::size_t select(SelectionFunction selectionFunction) {
    auto getUnmatchedSelections = [&selectionFunction](const types::registry& reg) -> std::vector<types::entity> {
      auto upcomingSelection = selectionFunction(reg);
      auto currentSelection = reg.view<Selection>();
      auto end =
        std::remove_if(upcomingSelection.begin(), upcomingSelection.end(), [&currentSelection](types::entity entity) {
          return !currentSelection.contains(entity);
        });
      return {upcomingSelection.begin(), end};
    };

    return select<Selection>(selectionFunction, getUnmatchedSelections, selectionFunction);
  }

  template <typename Selection>
  void deselect() {
    POKESIM_ASSERT(hasActiveSelection<Selection>(), "Selections must be present to deselect.");

    registry.clear<Selection>();
    SelectionFunctionList& functions = selectedFunctions<Selection>();
    functions.pop_back();

    if (functions.empty()) {
      return;
    }

    std::vector<types::entity> filteredEntityList = functions[0](registry);
    auto end = filteredEntityList.end();
    for (std::size_t i = 1; i < functions.size(); i++) {
      std::vector<types::entity> previouslySelected = functions[i](registry);
      end = std::remove_if(filteredEntityList.begin(), end, [&previouslySelected](types::entity entity) {
        return std::find(previouslySelected.begin(), previouslySelected.end(), entity) == previouslySelected.end();
      });
    }

    registry.insert<Selection>(filteredEntityList.begin(), end);
  }

 protected:
  template <typename Selection>
  bool hasActiveSelection() const {
    return !selectedFunctions<Selection>().empty();
  }

 private:
  template <typename Selected, typename Required, auto Function, typename...>
  struct ForSelected;

  template <
    typename Selected, typename Required, auto Function, typename ExcludeContainer, typename IncludeContainer,
    typename... ExtraTags>
  struct ForSelected<Selected, Required, Function, Tags<ExtraTags...>, ExcludeContainer, IncludeContainer> {
    template <typename... PassedInArgs>
    static void view(RegistryContainer* container, const PassedInArgs&... passedInArgs) {
      if (container->hasActiveSelection<Selected>()) {
        container->view<Function, Tags<Selected, Required, ExtraTags...>, ExcludeContainer, IncludeContainer>(
          passedInArgs...);
      }
      else {
        container->view<Function, Tags<Required, ExtraTags...>, ExcludeContainer, IncludeContainer>(passedInArgs...);
      }
    }

    template <typename... PassedInArgs>
    static void group(RegistryContainer* container, const PassedInArgs&... passedInArgs) {
      if (container->hasActiveSelection<Selected>()) {
        container->view<Function, Tags<Selected, ExtraTags...>, ExcludeContainer, IncludeContainer>(passedInArgs...);
      }
      else {
        container->group<Function, Tags<ExtraTags...>, ExcludeContainer, IncludeContainer>(passedInArgs...);
      }
    }
  };

 public:
  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  void viewForSelectedBattles(const PassedInArgs&... passedInArgs) {
    ForSelected<tags::SelectedForViewBattle, tags::Battle, Function, TagContainer, ExcludeContainer, IncludeContainer>::
      view(this, passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  void groupForSelectedBattles(const PassedInArgs&... passedInArgs) {
    ForSelected<tags::SelectedForViewBattle, tags::Battle, Function, TagContainer, ExcludeContainer, IncludeContainer>::
      group(this, passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  void viewForSelectedSides(const PassedInArgs&... passedInArgs) {
    ForSelected<tags::SelectedForViewSide, tags::Side, Function, TagContainer, ExcludeContainer, IncludeContainer>::
      view(this, passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  void groupForSelectedSides(const PassedInArgs&... passedInArgs) {
    ForSelected<tags::SelectedForViewSide, tags::Side, Function, TagContainer, ExcludeContainer, IncludeContainer>::
      group(this, passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  void viewForSelectedPokemon(const PassedInArgs&... passedInArgs) {
    ForSelected<
      tags::SelectedForViewPokemon,
      tags::Pokemon,
      Function,
      TagContainer,
      ExcludeContainer,
      IncludeContainer>::view(this, passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  void groupForSelectedPokemon(const PassedInArgs&... passedInArgs) {
    ForSelected<
      tags::SelectedForViewPokemon,
      tags::Pokemon,
      Function,
      TagContainer,
      ExcludeContainer,
      IncludeContainer>::group(this, passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  void viewForSelectedMoves(const PassedInArgs&... passedInArgs) {
    ForSelected<
      tags::SelectedForViewMove,
      tags::CurrentActionMove,
      Function,
      TagContainer,
      ExcludeContainer,
      IncludeContainer>::view(this, passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  void groupForSelectedMoves(const PassedInArgs&... passedInArgs) {
    ForSelected<
      tags::SelectedForViewMove,
      tags::CurrentActionMove,
      Function,
      TagContainer,
      ExcludeContainer,
      IncludeContainer>::group(this, passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  auto view(const PassedInArgs&... passedInArgs) {
    return internal::RegistryLoop<Function, TagContainer, ExcludeContainer, IncludeContainer, PassedInArgs...>::view(
      registry,
      passedInArgs...);
  }

  template <
    auto Function, typename TagContainer = Tags<>, typename ExcludeContainer = entt::exclude_t<>,
    typename IncludeContainer = entt::get_t<>, typename... PassedInArgs>
  auto group(const PassedInArgs&... passedInArgs) {
    return internal::RegistryLoop<Function, TagContainer, ExcludeContainer, IncludeContainer, PassedInArgs...>::group(
      registry,
      passedInArgs...);
  }

 public:
  types::registry registry{};

  template <typename Type, typename... ViewComponents, typename... Args>
  void addToEntities(Args&&... args) {
    auto view = registry.view<ViewComponents...>();
    registry.insert<Type>(view.begin(), view.end(), args...);
  }

  template <typename Type, typename... ViewComponents, typename... ExcludeComponents>
  void removeFromEntities(entt::exclude_t<ExcludeComponents...> exclude = entt::exclude_t{}) {
    auto view = registry.view<Type, ViewComponents...>(exclude);
    registry.remove<Type>(view.begin(), view.end());
  }
};
}  // namespace pokesim::internal

///////////////// END OF src/Simulation/RegistryContainer.hpp //////////////////

//////////////// START OF src/Simulation/SimulationOptions.hpp /////////////////

#include <cstdint>
#include <optional>
#include <type_traits>

namespace pokesim {
class Simulation;

struct DamageRollOptions {
  DamageRollKind p1 = DamageRollKind::AVERAGE_DAMAGE;
  DamageRollKind p2 = DamageRollKind::AVERAGE_DAMAGE;
  bool sidesMatch() const { return p1 == p2; }
};

namespace simulate_turn {
struct Options {
  DamageRollOptions damageRollsConsidered;
  bool applyChangesToInputBattle = true;
  std::optional<types::percentChance> randomChanceUpperLimit = std::nullopt;
  std::optional<types::percentChance> randomChanceLowerLimit = std::nullopt;
  std::optional<types::probability> branchProbabilityLowerLimit = std::nullopt;

  // For Monte Carlo method. When false, the number of branches is determined by the number of random chance events that
  // happen in the turn. When true, the number of output battles is the same as the number in input battles as each
  // battle picks a random outcome for each random event without branching.
  bool makeBranchesOnRandomEvents = true;

  entt::delegate<std::remove_pointer_t<types::callback>> decisionCallback{};
  entt::delegate<std::remove_pointer_t<types::callback>> faintCallback{};
};
}  // namespace simulate_turn

namespace calc_damage {
struct Options {
  bool calculateUpToFoeHp = false;
  // KO chance is otherwise calculated if DamageRollKind::ALL_DAMAGE_ROLLS is set as the damage roll option
  bool noKoChanceCalculation = false;

  DamageRollOptions damageRollOptions;
};
}  // namespace calc_damage

namespace analyze_effect {
struct Options {
  // Whether to consider the multiplier even if the effect is already active (i.e. Rain will return a 1x multiplier
  // instead of 1.5x multiplier for Surf if this option is true and it's already raining)
  bool reconsiderActiveEffects = false;
  bool calculateUpToFoeHp = false;
  // KO chance is otherwise calculated if DamageRollKind::ALL_DAMAGE_ROLLS is set as the damage roll option
  bool noKoChanceCalculation = false;

  DamageRollOptions damageRollOptions;
};
}  // namespace analyze_effect
}  // namespace pokesim

///////////////// END OF src/Simulation/SimulationOptions.hpp //////////////////

//////////////////////// START OF src/Types/Damage.hpp /////////////////////////

#include <cstdint>

namespace pokesim::types {
using damage = std::uint16_t;
using damageRoll = std::uint8_t;
using effectMultiplier = float;
using useUntilKoChance = float;
using typeEffectiveness = std::int8_t;
}  // namespace pokesim::types

///////////////////////// END OF src/Types/Damage.hpp //////////////////////////

///////////////////////// START OF src/Types/Event.hpp /////////////////////////

#include <cstdint>

namespace pokesim::types {
using eventModifier = std::uint32_t;
}  // namespace pokesim::types

////////////////////////// END OF src/Types/Event.hpp //////////////////////////

//////////////////// START OF src/Simulation/Simulation.hpp ////////////////////

#include <optional>
#include <tuple>
#include <utility>
#include <vector>


namespace pokesim {
struct SideStateSetup;
struct PokemonStateSetup;
struct BattleStateSetup;
class Pokedex;

namespace simulate_turn {
struct Results;
}
namespace calc_damage {
struct Results;
struct InputSetup;
}  // namespace calc_damage
namespace analyze_effect {
struct Results;
struct InputSetup;
}  // namespace analyze_effect

/**
 * @brief The entry point for creating and running simulations.
 *
 * @details Each `Simulation` instance will only simulate for either single or double battles. This class is optimized
 * for running multiple simulations of the same battle, where each battle state has completed the same number of turns.
 */
class Simulation : public internal::RegistryContainer {
 public:
  struct MoveCreationInfo {
    dex::Move name = dex::Move::NO_MOVE;
    types::pp pp = 1;
    types::pp maxPp = 1;
  };

  struct PokemonCreationInfo {
    std::optional<types::stateId> id = std::nullopt;
    std::optional<types::stat> hp = std::nullopt;
    dex::Species species = dex::Species::MISSING_NO;
    std::optional<SpeciesTypes> types = std::nullopt;
    dex::Item item = dex::Item::NO_ITEM;
    dex::Ability ability = dex::Ability::NO_ABILITY;
    dex::Gender gender = dex::Gender::NO_GENDER;
    dex::Status status = dex::Status::NO_STATUS;
    types::level level = 1;

    bool fainted = false;

    dex::Nature nature = dex::Nature::NO_NATURE;
    Evs evs;
    Ivs ivs;
    struct {
      types::stat hp = 1;
      types::stat atk = 1;
      types::stat def = 1;
      types::stat spa = 1;
      types::stat spd = 1;
      types::stat spe = 1;
    } stats;

    std::vector<MoveCreationInfo> moves{};
  };

  struct SideCreationInfo {
    std::vector<PokemonCreationInfo> team;
  };

  struct TurnDecisionInfo {
    SideDecision p1;
    SideDecision p2;
  };

  struct CalcDamageInputInfo {
    Slot attackerSlot = Slot::NONE;
    Slot defenderSlot = Slot::NONE;
    dex::Move move = dex::Move::NO_MOVE;
  };

  struct AnalyzeEffectInputInfo {
   private:
    struct BoostInfo {
      dex::Stat stat = dex::Stat::ATK;
      types::boost boost = 0;
    };

   public:
    Slot attackerSlot = Slot::NONE;
    Slot defenderSlot = Slot::NONE;
    Slot effectTarget = Slot::NONE;
    std::vector<dex::Move> moves;
    std::optional<types::effectEnum> effect = std::nullopt;
    std::optional<BoostInfo> boostEffect = std::nullopt;
  };

  struct BattleCreationInfo {
    bool runWithSimulateTurn = false;
    bool runWithCalculateDamage = false;
    bool runWithAnalyzeEffect = false;
    types::battleTurn turn = 0;
    std::optional<types::rngState> rngSeed = std::nullopt;
    types::probability probability = 1;

    SideCreationInfo p1;
    SideCreationInfo p2;

    std::vector<TurnDecisionInfo> decisionsToSimulate;
    std::vector<CalcDamageInputInfo> damageCalculations;
    std::vector<AnalyzeEffectInputInfo> effectsToAnalyze;
  };

 private:
  inline std::vector<types::entity> createInitialMoves(const std::vector<MoveCreationInfo>& moveInfoList);
  inline PokemonStateSetup createInitialPokemon(const PokemonCreationInfo& pokemonInfo);
  inline void createInitialSide(
    SideStateSetup sideSetup, const SideCreationInfo& sideInfo, const BattleCreationInfo& battleInfo);

  inline void createInitialTurnDecision(BattleStateSetup battleStateSetup, const TurnDecisionInfo& turnDecisionInfo);
  inline void createCalcDamageInput(
    BattleStateSetup battleStateSetup, calc_damage::InputSetup& inputSetup, const CalcDamageInputInfo& inputInfo);
  inline void createAnalyzeEffectInput(
    BattleStateSetup battleStateSetup, analyze_effect::InputSetup& inputSetup, const AnalyzeEffectInputInfo& inputInfo);

  inline std::tuple<SideStateSetup, SideStateSetup> createInitialBattle(
    BattleStateSetup battleStateSetup, const BattleCreationInfo& battleInfo);

 public:
  const BattleFormat battleFormat = BattleFormat::SINGLES_BATTLE_FORMAT;
  const Pokedex& pokedex;

  simulate_turn::Options simulateTurnOptions;
  calc_damage::Options calculateDamageOptions;
  analyze_effect::Options analyzeEffectOptions;

  inline Simulation(const Pokedex& pokedex_, BattleFormat battleFormat_);

  // Load information about any number of battle states into the simulation's registry.
  inline void createInitialStates(const std::vector<BattleCreationInfo>& battleInfoList);

  inline void run();

  inline simulate_turn::Results simulateTurn(std::optional<simulate_turn::Options> options = std::nullopt);
  inline calc_damage::Results calculateDamage(std::optional<calc_damage::Options> options = std::nullopt);
  inline analyze_effect::Results analyzeEffect(std::optional<analyze_effect::Options> options = std::nullopt);

  inline simulate_turn::Results simulateTurn(
    const std::vector<BattleCreationInfo>& battleInfoList,
    std::optional<simulate_turn::Options> options = std::nullopt);

  inline calc_damage::Results calculateDamage(
    const std::vector<BattleCreationInfo>& battleInfoList, std::optional<calc_damage::Options> options = std::nullopt);

  inline analyze_effect::Results analyzeEffect(
    const std::vector<BattleCreationInfo>& battleInfoList,
    std::optional<analyze_effect::Options> options = std::nullopt);

  inline void clearAllResults();
  inline void clearSimulateTurnResults();
  inline void clearCalculateDamageResults();
  inline void clearAnalyzeEffectResults();

  inline std::vector<types::entity> selectedBattleEntities() const;
  inline std::vector<types::entity> selectedMoveEntities() const;
  inline std::vector<types::entity> selectedPokemonEntities() const;
};
}  // namespace pokesim

///////////////////// END OF src/Simulation/Simulation.hpp /////////////////////

////////////// START OF src/Components/AnalyzeEffect/Aliases.hpp ///////////////

namespace pokesim::analyze_effect {
using Attacker = CurrentActionSource;
using Defenders = CurrentActionTargets;

namespace tags {
using Attacker = pokesim::tags::CurrentActionMoveSource;
using Defender = pokesim::tags::CurrentActionMoveTarget;
using Move = pokesim::tags::CurrentActionMove;
}  // namespace tags
}  // namespace pokesim::analyze_effect

/////////////// END OF src/Components/AnalyzeEffect/Aliases.hpp ////////////////

//////// START OF src/Components/AnalyzeEffect/AnalyzeEffectInputs.hpp /////////

#include <vector>

namespace pokesim::analyze_effect {
struct EffectTarget {
  types::entity val{};
};

struct EffectMoves {
  std::vector<dex::Move> val{};
};

struct Inputs {
  std::vector<types::entity> val{};
};

struct OriginalInputEntities {
  types::entity battle{};
  types::entity attacker{};
  types::entity defender{};
  types::entity effectTarget{};

  bool operator==(const OriginalInputEntities& other) const {
    return battle == other.battle && attacker == other.attacker && defender == other.defender &&
           effectTarget == other.effectTarget;
  }
};

struct MovePairs {
  std::vector<std::pair<types::entity, types::entity>> val{};

  bool operator==(const MovePairs& other) const {
    if (val.size() != other.val.size()) return false;
    for (std::size_t i = 0; i < val.size(); i++) {
      if (val[i].first != other.val[i].first || val[i].second != other.val[i].second) {
        return false;
      }
    }
    return true;
  }
};

struct RunsOneCalculationCount {
  types::eventPossibilities val = 0;
};

namespace tags {
struct Input {};
struct RunOneCalculation {};
struct BattleCloneForCalculation {};
struct InvertFinalAnswer {};
}  // namespace tags
}  // namespace pokesim::analyze_effect

///////// END OF src/Components/AnalyzeEffect/AnalyzeEffectInputs.hpp //////////

////////////// START OF src/Components/EntityHolders/FoeSide.hpp ///////////////

namespace pokesim {
// Contains the entity of a side's opponent.
struct FoeSide {
  types::entity val{};
};
}  // namespace pokesim

/////////////// END OF src/Components/EntityHolders/FoeSide.hpp ////////////////

///////////// START OF src/Components/EntityHolders/MoveSlots.hpp //////////////

namespace pokesim {
// Contains a list of entities of the moves a Pokemon known.
struct MoveSlots {
  types::moveSlots<types::entity> val{};
};
}  // namespace pokesim

////////////// END OF src/Components/EntityHolders/MoveSlots.hpp ///////////////

//////////////// START OF src/Components/EntityHolders/Team.hpp ////////////////

namespace pokesim {
// Contains a list of entities pointing to the Pokemon on a team.
struct Team {
  types::teamPositions<types::entity> val{};
};
}  // namespace pokesim

///////////////// END OF src/Components/EntityHolders/Team.hpp /////////////////

//////////////////////// START OF src/Components/ID.hpp ////////////////////////

namespace pokesim {
struct Id {
  types::stateId val = 1;
};
}  // namespace pokesim

///////////////////////// END OF src/Components/ID.hpp /////////////////////////

////////////////////// START OF src/Components/Level.hpp ///////////////////////

namespace pokesim {
// A Pokemon's level
struct Level {
  types::level val = 1;
};
}  // namespace pokesim

/////////////////////// END OF src/Components/Level.hpp ////////////////////////

//////////////// START OF src/Components/Names/AbilityNames.hpp ////////////////

namespace pokesim {
struct AbilityName {
  dex::Ability name = dex::Ability::NO_ABILITY;
};
}  // namespace pokesim

///////////////// END OF src/Components/Names/AbilityNames.hpp /////////////////

//////////////// START OF src/Components/Names/GenderNames.hpp /////////////////

namespace pokesim {
struct GenderName {
  dex::Gender name = dex::Gender::NO_GENDER;
};
}  // namespace pokesim

///////////////// END OF src/Components/Names/GenderNames.hpp //////////////////

///////////////// START OF src/Components/Names/ItemNames.hpp //////////////////

namespace pokesim {
struct ItemName {
  dex::Item name = dex::Item::NO_ITEM;
};
}  // namespace pokesim

////////////////// END OF src/Components/Names/ItemNames.hpp ///////////////////

///////////////// START OF src/Components/Names/MoveNames.hpp //////////////////

namespace pokesim {
struct MoveName {
  dex::Move name = dex::Move::NO_MOVE;
};
}  // namespace pokesim

////////////////// END OF src/Components/Names/MoveNames.hpp ///////////////////

//////////////// START OF src/Components/Names/NatureNames.hpp /////////////////

namespace pokesim {
struct NatureName {
  dex::Nature name = dex::Nature::NO_NATURE;
};
}  // namespace pokesim

///////////////// END OF src/Components/Names/NatureNames.hpp //////////////////

///////////// START OF src/Components/Names/PseudoWeatherNames.hpp /////////////

namespace pokesim {
struct PseudoWeatherName {
  dex::PseudoWeather name = dex::PseudoWeather::NO_PSEUDO_WEATHER;
};
}  // namespace pokesim

////////////// END OF src/Components/Names/PseudoWeatherNames.hpp //////////////

///////////// START OF src/Components/Names/SideConditionNames.hpp /////////////

namespace pokesim {
struct SideConditionName {
  dex::SideCondition name = dex::SideCondition::NO_SIDE_CONDITION;
};
}  // namespace pokesim

////////////// END OF src/Components/Names/SideConditionNames.hpp //////////////

//////////////// START OF src/Components/Names/SpeciesNames.hpp ////////////////

namespace pokesim {
struct SpeciesName {
  dex::Species name = dex::Species::MISSING_NO;
};
}  // namespace pokesim

///////////////// END OF src/Components/Names/SpeciesNames.hpp /////////////////

//////////////// START OF src/Components/Names/StatusNames.hpp /////////////////

namespace pokesim {
struct StatusName {
  dex::Status name = dex::Status::NO_STATUS;
};
}  // namespace pokesim

///////////////// END OF src/Components/Names/StatusNames.hpp //////////////////

//////////////// START OF src/Components/Names/TerrainNames.hpp ////////////////

namespace pokesim {
struct TerrainName {
  dex::Terrain name = dex::Terrain::NO_TERRAIN;
};
}  // namespace pokesim

///////////////// END OF src/Components/Names/TerrainNames.hpp /////////////////

/////////////// START OF src/Components/Names/VolatileNames.hpp ////////////////

namespace pokesim {
struct VolatileName {
  dex::Volatile name = dex::Volatile::NO_VOLATILE;
};
}  // namespace pokesim

//////////////// END OF src/Components/Names/VolatileNames.hpp /////////////////

//////////////// START OF src/Components/Names/WeatherNames.hpp ////////////////

namespace pokesim {
struct WeatherName {
  dex::Weather name = dex::Weather::NO_WEATHER;
};
}  // namespace pokesim

///////////////// END OF src/Components/Names/WeatherNames.hpp /////////////////

//////////////////////// START OF src/Components/PP.hpp ////////////////////////

namespace pokesim {
struct Pp {
  types::pp val = 0;
};

struct MaxPp {
  types::pp val = 5;
};
}  // namespace pokesim

///////////////////////// END OF src/Components/PP.hpp /////////////////////////

/////////////////// START OF src/Components/Probability.hpp ////////////////////

namespace pokesim {
/**
 * @brief The probability of all the previous actions in a battle's simulation occurring.
 *
 * Calculated by multiplying the various Accuracy and Chance numbers of a battle state's events.
 */
struct Probability {
  types::probability val = 1;
};
}  // namespace pokesim

//////////////////// END OF src/Components/Probability.hpp /////////////////////

///////////////////// START OF src/Components/RNGSeed.hpp //////////////////////

namespace pokesim {
struct RngSeed {
  types::rngState val = 1;
};
}  // namespace pokesim

////////////////////// END OF src/Components/RNGSeed.hpp ///////////////////////

/////////////////////// START OF src/Components/Turn.hpp ///////////////////////

namespace pokesim {
// The current turn of a battle
struct Turn {
  types::battleTurn val = 0;
};
}  // namespace pokesim

//////////////////////// END OF src/Components/Turn.hpp ////////////////////////

//////////////////// START OF src/Utilities/DebugChecks.hpp ////////////////////

#ifdef POKESIM_DEBUG_CHECK_UTILITIES


namespace pokesim::debug {
struct Checks {
  Checks(const Simulation& _simulation) : simulation(_simulation), registry(simulation.registry) {}

 protected:
  const Simulation& simulation;
  const types::registry& registry;
  types::registry registryOnInput;
  entt::dense_map<types::entity, types::entity> originalToCopy;
  entt::dense_set<types::entity> specificallyChecked;
  std::size_t initialEntityCount = 0;

  void copyRemainingEntities() {
    for (types::entity entity : registry.view<types::entity>()) {
      if (!registry.orphan(entity)) {
        initialEntityCount++;
        if (originalToCopy.contains(entity)) {
          specificallyChecked.emplace(entity);
        }
        else {
          originalToCopy[entity] = createEntityCopy(entity, registry, registryOnInput);
        }
      }
    }
  }

  void checkRemainingOutputs() const {
    for (auto [original, copy] : originalToCopy) {
      if (!specificallyChecked.contains(original)) {
        areEntitiesEqual(registry, original, registryOnInput, copy);
      }
    }
  }

  std::size_t getFinalEntityCount() const {
    std::size_t finalEntityCount = 0;
    for (types::entity entity : registry.view<types::entity>()) {
      if (!registry.orphan(entity)) {
        finalEntityCount++;
      }
    }
    return finalEntityCount;
  }
};
}  // namespace pokesim::debug

#else
namespace pokesim::debug {
struct Checks {};
}  // namespace pokesim::debug
#endif

///////////////////// END OF src/Utilities/DebugChecks.hpp /////////////////////

//////////// START OF src/Simulation/SimulationSetupDebugChecks.hpp ////////////

namespace pokesim::debug {
struct SimulationSetupChecks {
#ifdef NDEBUG
  SimulationSetupChecks(const types::registry&, const std::vector<Simulation::BattleCreationInfo>&) {}
  void addToBattleChecklist(const BattleStateSetup&, const Simulation::BattleCreationInfo&) {}
  void addToTurnDecisionChecklist(const BattleStateSetup&, const Simulation::TurnDecisionInfo&) {}
  void addToCalcDamageChecklist(
    const BattleStateSetup&, const calc_damage::InputSetup&, const Simulation::CalcDamageInputInfo&) {}
  void addToAnalyzeEffectChecklist(
    const BattleStateSetup&, const analyze_effect::InputSetup&, const Simulation::AnalyzeEffectInputInfo&) {}
  static void checkBattle(const types::registry&, types::entity, const Simulation::BattleCreationInfo&) {}
#else
 private:
  const types::registry& registry;
  const std::vector<Simulation::BattleCreationInfo>& battleInfoList;

  struct SetupEntities {
    types::entity battle;
    types::entity setup;
  };

  entt::dense_map<const Simulation::BattleCreationInfo*, std::vector<entt::entity> > createdBattles;
  entt::dense_map<const Simulation::TurnDecisionInfo*, entt::entity> createdTurnDecisions;

  entt::dense_map<const Simulation::CalcDamageInputInfo*, SetupEntities> createdCalcDamageInputs;
  entt::dense_map<const Simulation::AnalyzeEffectInputInfo*, SetupEntities> createdAnalyzeEffectInputs;

  static types::entity targetSlotToEntity(
    Slot targetSlot, const types::teamPositions<types::entity>& p1Team,
    const types::teamPositions<types::entity>& p2Team) {
    switch (targetSlot) {
      case Slot::P1A: {
        return p1Team[0];
      }
      case Slot::P1B: {
        return p1Team[1];
      }
      case Slot::P1C: {
        return p1Team[2];
      }
      case Slot::P1D: {
        return p1Team[3];
      }
      case Slot::P1E: {
        return p1Team[4];
      }
      case Slot::P1F: {
        return p1Team[5];
      }
      case Slot::P2A: {
        return p2Team[0];
      }
      case Slot::P2B: {
        return p2Team[1];
      }
      case Slot::P2C: {
        return p2Team[2];
      }
      case Slot::P2D: {
        return p2Team[3];
      }
      case Slot::P2E: {
        return p2Team[4];
      }
      case Slot::P2F: {
        return p2Team[5];
      }
      default: break;
    }

    POKESIM_ASSERT_FAIL("Given target slot does not exist in a team.");
    return entt::null;
  }

  void checkCreatedPokemon(types::entity pokemonEntity, const Simulation::PokemonCreationInfo& creationInfo) const {
    const auto& [id, side, battle, speciesName, abilityName, level, moveSlots, evs, ivs] =
      registry.get<Id, Side, Battle, SpeciesName, AbilityName, Level, MoveSlots, Evs, Ivs>(pokemonEntity);
    const auto& [hp, atk, def, spa, spd, spe] =
      registry.get<stat::Hp, stat::Atk, stat::Def, stat::Spa, stat::Spd, stat::Spe>(pokemonEntity);

    if (creationInfo.id.has_value()) {
      POKESIM_ASSERT_NM(id.val == creationInfo.id.value());
    }
    else {
      POKESIM_ASSERT_NM(id.val != 0);
    }

    POKESIM_ASSERT_NM(speciesName.name == creationInfo.species);
    POKESIM_ASSERT_NM(abilityName.name == creationInfo.ability);
    POKESIM_ASSERT_NM(level.val == creationInfo.level);

    if (creationInfo.item == dex::Item::NO_ITEM) {
      POKESIM_ASSERT_NM(!registry.all_of<ItemName>(pokemonEntity));
    }
    else {
      POKESIM_ASSERT_NM(registry.get<ItemName>(pokemonEntity).name == creationInfo.item);
    }

    if (creationInfo.gender == dex::Gender::NO_GENDER) {
      POKESIM_ASSERT_NM(!registry.all_of<GenderName>(pokemonEntity));
    }
    else {
      POKESIM_ASSERT_NM(registry.get<GenderName>(pokemonEntity).name == creationInfo.gender);
    }

    if (creationInfo.status == dex::Status::NO_STATUS) {
      POKESIM_ASSERT_NM(!registry.all_of<StatusName>(pokemonEntity));
    }
    else {
      POKESIM_ASSERT_NM(registry.get<StatusName>(pokemonEntity).name == creationInfo.status);
    }

    if (creationInfo.nature == dex::Nature::NO_NATURE) {
      POKESIM_ASSERT_NM(!registry.all_of<NatureName>(pokemonEntity));
    }
    else {
      POKESIM_ASSERT_NM(registry.get<NatureName>(pokemonEntity).name == creationInfo.nature);
    }

    POKESIM_ASSERT_NM(hp.val == creationInfo.stats.hp);
    POKESIM_ASSERT_NM(atk.val == creationInfo.stats.atk);
    POKESIM_ASSERT_NM(def.val == creationInfo.stats.def);
    POKESIM_ASSERT_NM(spa.val == creationInfo.stats.spa);
    POKESIM_ASSERT_NM(spd.val == creationInfo.stats.spd);
    POKESIM_ASSERT_NM(spe.val == creationInfo.stats.spe);

    POKESIM_ASSERT_NM(evs.hp == creationInfo.evs.hp);
    POKESIM_ASSERT_NM(evs.atk == creationInfo.evs.atk);
    POKESIM_ASSERT_NM(evs.def == creationInfo.evs.def);
    POKESIM_ASSERT_NM(evs.spa == creationInfo.evs.spa);
    POKESIM_ASSERT_NM(evs.spd == creationInfo.evs.spd);
    POKESIM_ASSERT_NM(evs.spe == creationInfo.evs.spe);

    POKESIM_ASSERT_NM(ivs.hp == creationInfo.ivs.hp);
    POKESIM_ASSERT_NM(ivs.atk == creationInfo.ivs.atk);
    POKESIM_ASSERT_NM(ivs.def == creationInfo.ivs.def);
    POKESIM_ASSERT_NM(ivs.spa == creationInfo.ivs.spa);
    POKESIM_ASSERT_NM(ivs.spd == creationInfo.ivs.spd);
    POKESIM_ASSERT_NM(ivs.spe == creationInfo.ivs.spe);

    POKESIM_ASSERT_NM(moveSlots.val.size() == creationInfo.moves.size());

    for (std::size_t i = 0; i < creationInfo.moves.size(); i++) {
      const Simulation::MoveCreationInfo& move = creationInfo.moves[i];
      types::entity moveEntity = moveSlots.val[(std::uint8_t)i];
      POKESIM_ASSERT_NM((registry.all_of<MoveName, Pp, MaxPp>(moveEntity)));
      POKESIM_ASSERT_NM(registry.get<MoveName>(moveEntity).name == move.name);
      POKESIM_ASSERT_NM(registry.get<Pp>(moveEntity).val == move.pp);
      POKESIM_ASSERT_NM(registry.get<MaxPp>(moveEntity).val == move.maxPp);
    }
  }

  void checkCreatedSide(types::entity sideEntity, const Simulation::SideCreationInfo& creationInfo) const {
    POKESIM_ASSERT_NM((registry.all_of<Team, FoeSide, Battle>(sideEntity)));

    const auto& team = registry.get<Team>(sideEntity).val;
    POKESIM_ASSERT_NM(team.size() == creationInfo.team.size());

    for (std::size_t i = 0; i < creationInfo.team.size(); i++) {
      types::entity pokemonEntity = team[(std::uint8_t)i];
      checkCreatedPokemon(pokemonEntity, creationInfo.team[i]);

      POKESIM_ASSERT_NM(registry.get<Side>(pokemonEntity).val == sideEntity);
      POKESIM_ASSERT_NM(registry.get<Battle>(pokemonEntity).val == registry.get<Battle>(sideEntity).val);
    }
  }

  void checkBattle(types::entity battleEntity, const Simulation::BattleCreationInfo& creationInfo) const {
    POKESIM_ASSERT_NM((registry.all_of<Sides, ActionQueue, Turn, Probability, RngSeed>(battleEntity)));
    const auto& [sides, turn, probability, rngSeed] = registry.get<Sides, Turn, Probability, RngSeed>(battleEntity);

    POKESIM_ASSERT_NM(turn.val == creationInfo.turn);
    POKESIM_ASSERT_NM(probability.val == creationInfo.probability);

    if (creationInfo.rngSeed) {
      POKESIM_ASSERT_NM(rngSeed.val == creationInfo.rngSeed);
    }
    else {
      POKESIM_ASSERT_NM(rngSeed.val != 0);
    }

    POKESIM_ASSERT(sides.val.size() == 2, "Both sides should be have entities.");
    auto [p1SideEntity, p2SideEntity] = sides.val;

    checkCreatedSide(p1SideEntity, creationInfo.p1);
    checkCreatedSide(p2SideEntity, creationInfo.p2);

    POKESIM_ASSERT_NM(registry.get<Battle>(p1SideEntity).val == battleEntity);
    POKESIM_ASSERT_NM(registry.get<Battle>(p2SideEntity).val == battleEntity);
    POKESIM_ASSERT_NM(registry.get<FoeSide>(p1SideEntity).val == p2SideEntity);
    POKESIM_ASSERT_NM(registry.get<FoeSide>(p2SideEntity).val == p1SideEntity);
  }

  void checkTurnDecision(types::entity battleEntity, const Simulation::TurnDecisionInfo& turnDecisionInfo) const {
    const auto& sides = registry.get<Sides>(battleEntity).val;

    POKESIM_ASSERT(sides.size() == 2, "Both sides should be have entities.");
    for (uint8_t side = 0; side < 2U; side++) {
      const auto& sideDecision = registry.get<SideDecision>(sides[side]);
      const auto& sideDecisionInfo = side ? turnDecisionInfo.p2 : turnDecisionInfo.p1;

      POKESIM_ASSERT_NM(sideDecision.sideId == sideDecisionInfo.sideId);

      if (sideDecisionInfo.decisions.holds<types::slotDecisions>()) {
        POKESIM_ASSERT_NM(sideDecision.decisions.holds<types::slotDecisions>());

        const auto& slotDecisions = sideDecision.decisions.get<types::slotDecisions>();
        const auto& slotDecisionsInfo = sideDecisionInfo.decisions.get<types::slotDecisions>();
        POKESIM_ASSERT_NM(slotDecisions.size() == slotDecisionsInfo.size());
        POKESIM_ASSERT_NM(!slotDecisions.empty());
        for (uint8_t slot = 0; slot < slotDecisions.size(); slot++) {
          const auto& slotDecision = slotDecisions[slot];
          const auto& slotDecisionInfo = slotDecisionsInfo[slot];

          POKESIM_ASSERT_NM(slotDecision.sourceSlot == slotDecisionInfo.sourceSlot);
          POKESIM_ASSERT_NM(slotDecision.targetSlot == slotDecisionInfo.targetSlot);
          POKESIM_ASSERT_NM(slotDecision.megaEvolve == slotDecisionInfo.megaEvolve);
          POKESIM_ASSERT_NM(slotDecision.primalRevert == slotDecisionInfo.primalRevert);
          POKESIM_ASSERT_NM(slotDecision.dynamax == slotDecisionInfo.dynamax);
          POKESIM_ASSERT_NM(slotDecision.terastallize == slotDecisionInfo.terastallize);
          POKESIM_ASSERT_NM(slotDecision.moveChoice == slotDecisionInfo.moveChoice);
          POKESIM_ASSERT_NM(slotDecision.itemChoice == slotDecisionInfo.itemChoice);
        }
      }
      else if (sideDecisionInfo.decisions.holds<types::teamOrder>()) {
        POKESIM_ASSERT_NM(sideDecision.decisions.holds<types::teamOrder>());

        const auto& teamOrder = sideDecision.decisions.get<types::teamOrder>();
        const auto& teamOrderInfo = sideDecisionInfo.decisions.get<types::teamOrder>();
        POKESIM_ASSERT_NM(teamOrder.size() == teamOrderInfo.size());
        POKESIM_ASSERT_NM(!teamOrder.empty());

        for (uint8_t position = 0; position < teamOrder.size(); position++) {
          POKESIM_ASSERT_NM(teamOrder[position] == teamOrderInfo[position]);
        }
      }
    }
  }

  void checkCalcDamage(
    types::entity battleEntity, types::entity calcDamageEntity,
    const Simulation::CalcDamageInputInfo& calcDamageInputInfo) const {
    POKESIM_ASSERT_NM(registry.all_of<calc_damage::tags::UsedMove>(calcDamageEntity));
    POKESIM_ASSERT_NM(registry.all_of<tags::CalculateDamage>(calcDamageEntity));

    const auto& p1Team = registry.get<Team>(registry.get<Sides>(battleEntity).p1()).val;
    const auto& p2Team = registry.get<Team>(registry.get<Sides>(battleEntity).p2()).val;
    const auto& [battle, moveName, attacker, defenders] =
      registry.get<Battle, MoveName, calc_damage::Attacker, calc_damage::Defenders>(calcDamageEntity);
    types::entity setupInfoAttacker = targetSlotToEntity(calcDamageInputInfo.attackerSlot, p1Team, p2Team);
    types::entity setupInfoDefender = targetSlotToEntity(calcDamageInputInfo.defenderSlot, p1Team, p2Team);

    POKESIM_ASSERT_NM(battle.val == battleEntity);
    POKESIM_ASSERT_NM(attacker.val == setupInfoAttacker);
    POKESIM_ASSERT_NM(defenders.only() == setupInfoDefender);
    POKESIM_ASSERT_NM(moveName.name == calcDamageInputInfo.move);

    POKESIM_ASSERT_NM(registry.all_of<calc_damage::tags::Attacker>(setupInfoAttacker));
    POKESIM_ASSERT_NM(registry.all_of<calc_damage::tags::Defender>(setupInfoDefender));

    const auto& attackerMoves = registry.get<calc_damage::UsedMoves>(setupInfoAttacker).val;
    const auto& defenderMoves = registry.get<calc_damage::UsedMoves>(setupInfoDefender).val;

    POKESIM_ASSERT_NM(std::find(attackerMoves.begin(), attackerMoves.end(), calcDamageEntity) != attackerMoves.end());
    POKESIM_ASSERT_NM(std::find(defenderMoves.begin(), defenderMoves.end(), calcDamageEntity) != defenderMoves.end());
  }

  void checkAnalyzeEffect(
    types::entity battleEntity, types::entity analyzeEffectEntity,
    const Simulation::AnalyzeEffectInputInfo& analyzeEffectInputInfo) const {
    POKESIM_ASSERT_NM(registry.all_of<analyze_effect::tags::Input>(analyzeEffectEntity));
    POKESIM_ASSERT(
      !registry.all_of<tags::AnalyzeEffect>(analyzeEffectEntity),
      "This should not be set on the input entity as it's used for individual move calculations.");

    const auto& p1Team = registry.get<Team>(registry.get<Sides>(battleEntity).p1()).val;
    const auto& p2Team = registry.get<Team>(registry.get<Sides>(battleEntity).p2()).val;
    const auto& [battle, effectMoves, attacker, defenders, effectTarget] = registry.get<
      Battle,
      analyze_effect::EffectMoves,
      analyze_effect::Attacker,
      analyze_effect::Defenders,
      analyze_effect::EffectTarget>(analyzeEffectEntity);
    types::entity setupInfoAttacker = targetSlotToEntity(analyzeEffectInputInfo.attackerSlot, p1Team, p2Team);
    types::entity setupInfoDefender = targetSlotToEntity(analyzeEffectInputInfo.defenderSlot, p1Team, p2Team);
    types::entity setupInfoEffectTarget = targetSlotToEntity(analyzeEffectInputInfo.effectTarget, p1Team, p2Team);

    POKESIM_ASSERT_NM(battle.val == battleEntity);
    POKESIM_ASSERT_NM(attacker.val == setupInfoAttacker);
    POKESIM_ASSERT_NM(defenders.only() == setupInfoDefender);
    POKESIM_ASSERT_NM(effectTarget.val == setupInfoEffectTarget);

    POKESIM_ASSERT_NM(effectMoves.val.size() == analyzeEffectInputInfo.moves.size());
    for (std::size_t i = 0; i < effectMoves.val.size(); i++) {
      POKESIM_ASSERT_NM(effectMoves.val[i] == analyzeEffectInputInfo.moves[i]);
    }

    POKESIM_ASSERT_NM(registry.all_of<analyze_effect::Inputs>(battle.val));
    const auto& battleInputs = registry.get<analyze_effect::Inputs>(battle.val).val;
    POKESIM_ASSERT_NM(std::find(battleInputs.begin(), battleInputs.end(), analyzeEffectEntity) != battleInputs.end());

    POKESIM_ASSERT_NM(registry.all_of<analyze_effect::tags::Attacker>(setupInfoAttacker));
    POKESIM_ASSERT_NM(registry.all_of<analyze_effect::tags::Defender>(setupInfoDefender));

    if (analyzeEffectInputInfo.effect.has_value()) {
      const auto& effect = analyzeEffectInputInfo.effect.value();
      if (effect.holds<dex::PseudoWeather>()) {
        POKESIM_ASSERT_NM(registry.all_of<PseudoWeatherName>(analyzeEffectEntity));
        POKESIM_ASSERT_NM(
          registry.get<PseudoWeatherName>(analyzeEffectEntity).name == effect.get<dex::PseudoWeather>());
      }
      else if (effect.holds<dex::SideCondition>()) {
        POKESIM_ASSERT_NM(registry.all_of<SideConditionName>(analyzeEffectEntity));
        POKESIM_ASSERT_NM(
          registry.get<SideConditionName>(analyzeEffectEntity).name == effect.get<dex::SideCondition>());
      }
      else if (effect.holds<dex::Status>()) {
        POKESIM_ASSERT_NM(registry.all_of<StatusName>(analyzeEffectEntity));
        POKESIM_ASSERT_NM(registry.get<StatusName>(analyzeEffectEntity).name == effect.get<dex::Status>());
      }
      else if (effect.holds<dex::Terrain>()) {
        POKESIM_ASSERT_NM(registry.all_of<TerrainName>(analyzeEffectEntity));
        POKESIM_ASSERT_NM(registry.get<TerrainName>(analyzeEffectEntity).name == effect.get<dex::Terrain>());
      }
      else if (effect.holds<dex::Volatile>()) {
        POKESIM_ASSERT_NM(registry.all_of<VolatileName>(analyzeEffectEntity));
        POKESIM_ASSERT_NM(registry.get<VolatileName>(analyzeEffectEntity).name == effect.get<dex::Volatile>());
      }
      else if (effect.holds<dex::Weather>()) {
        POKESIM_ASSERT_NM(registry.all_of<WeatherName>(analyzeEffectEntity));
        POKESIM_ASSERT_NM(registry.get<WeatherName>(analyzeEffectEntity).name == effect.get<dex::Weather>());
      }
      else {
        POKESIM_ASSERT_FAIL("Effect does not contain a valid enum.");
      }
    }

    if (analyzeEffectInputInfo.boostEffect.has_value()) {
      const auto [stat, boostValue] = analyzeEffectInputInfo.boostEffect.value();
      switch (stat) {
        case dex::Stat::ATK: {
          POKESIM_ASSERT_NM(registry.all_of<AtkBoost>(analyzeEffectEntity));
          POKESIM_ASSERT_NM(registry.get<AtkBoost>(analyzeEffectEntity).val == boostValue);
          break;
        }
        case dex::Stat::DEF: {
          POKESIM_ASSERT_NM(registry.all_of<DefBoost>(analyzeEffectEntity));
          POKESIM_ASSERT_NM(registry.get<DefBoost>(analyzeEffectEntity).val == boostValue);
          break;
        }
        case dex::Stat::SPA: {
          POKESIM_ASSERT_NM(registry.all_of<SpaBoost>(analyzeEffectEntity));
          POKESIM_ASSERT_NM(registry.get<SpaBoost>(analyzeEffectEntity).val == boostValue);
          break;
        }
        case dex::Stat::SPD: {
          POKESIM_ASSERT_NM(registry.all_of<SpdBoost>(analyzeEffectEntity));
          POKESIM_ASSERT_NM(registry.get<SpdBoost>(analyzeEffectEntity).val == boostValue);
          break;
        }
        case dex::Stat::SPE: {
          POKESIM_ASSERT_NM(registry.all_of<SpeBoost>(analyzeEffectEntity));
          POKESIM_ASSERT_NM(registry.get<SpeBoost>(analyzeEffectEntity).val == boostValue);
          break;
        }
        default: {
          POKESIM_ASSERT_FAIL("Using a stat enum that doesn't have boost.");
        }
      }
    }
  }

  void checkOutputs() const {
    for (const auto& battleInfo : battleInfoList) {
      POKESIM_ASSERT_NM(createdBattles.contains(&battleInfo));
      const std::vector<types::entity>& battleEntities = createdBattles.at(&battleInfo);

      types::cloneIndex idealBattleCount =
        battleInfo.decisionsToSimulate.empty() ? 1 : battleInfo.decisionsToSimulate.size();
      POKESIM_ASSERT_NM(idealBattleCount == battleEntities.size());
      for (types::entity entity : battleEntities) {
        checkBattle(entity, battleInfo);
      }

      for (const auto& turnDecisionInfo : battleInfo.decisionsToSimulate) {
        POKESIM_ASSERT_NM(createdTurnDecisions.contains(&turnDecisionInfo));
        types::entity battleEntity = createdTurnDecisions.at(&turnDecisionInfo);
        checkTurnDecision(battleEntity, turnDecisionInfo);
      }

      for (const auto& calcDamageInputInfo : battleInfo.damageCalculations) {
        POKESIM_ASSERT_NM(createdCalcDamageInputs.contains(&calcDamageInputInfo));
        auto [battleEntity, setupEntity] = createdCalcDamageInputs.at(&calcDamageInputInfo);
        checkCalcDamage(battleEntity, setupEntity, calcDamageInputInfo);
      }

      for (const auto& analyzeEffectInputInfo : battleInfo.effectsToAnalyze) {
        POKESIM_ASSERT_NM(createdAnalyzeEffectInputs.contains(&analyzeEffectInputInfo));
        auto [battleEntity, setupEntity] = createdAnalyzeEffectInputs.at(&analyzeEffectInputInfo);
        checkAnalyzeEffect(battleEntity, setupEntity, analyzeEffectInputInfo);
      }
    }
  }

 public:
  SimulationSetupChecks(
    const types::registry& _registry, const std::vector<Simulation::BattleCreationInfo>& _battleInfoList)
      : registry(_registry), battleInfoList(_battleInfoList) {}

  ~SimulationSetupChecks() { checkOutputs(); }

  void addToBattleChecklist(
    const BattleStateSetup& battleStateSetup, const Simulation::BattleCreationInfo& creationInfo) {
    createdBattles[&creationInfo].push_back(battleStateSetup.entity());
  }

  void addToTurnDecisionChecklist(
    const BattleStateSetup& battleStateSetup, const Simulation::TurnDecisionInfo& turnDecisionInfo) {
    createdTurnDecisions[&turnDecisionInfo] = battleStateSetup.entity();
  }

  void addToCalcDamageChecklist(
    const BattleStateSetup& battleStateSetup, const calc_damage::InputSetup& inputSetup,
    const Simulation::CalcDamageInputInfo& calcDamageInputInfo) {
    createdCalcDamageInputs[&calcDamageInputInfo] = {battleStateSetup.entity(), inputSetup.entity()};
  }

  void addToAnalyzeEffectChecklist(
    const BattleStateSetup& battleStateSetup, const analyze_effect::InputSetup& inputSetup,
    const Simulation::AnalyzeEffectInputInfo& analyzeEffectInputInfo) {
    createdAnalyzeEffectInputs[&analyzeEffectInputInfo] = {battleStateSetup.entity(), inputSetup.entity()};
  }

  static void checkBattle(
    const types::registry& registry, types::entity battleEntity,
    const Simulation::BattleCreationInfo& battleCreationInfo) {
    SimulationSetupChecks(registry, {}).checkBattle(battleEntity, battleCreationInfo);
  }

#endif
};
}  // namespace pokesim::debug

///////////// END OF src/Simulation/SimulationSetupDebugChecks.hpp /////////////

///////////////// START OF src/Simulation/SimulationSetup.cpp //////////////////

#include <cstddef>
#include <utility>
#include <vector>


namespace pokesim {
Simulation::Simulation(const Pokedex& pokedex_, BattleFormat battleFormat_)
    : battleFormat(battleFormat_), pokedex(pokedex_) {}

inline std::vector<types::entity> Simulation::createInitialMoves(const std::vector<MoveCreationInfo>& moveInfoList) {
  std::vector<types::entity> moveEntities{};
  moveEntities.reserve(moveInfoList.size());

  for (const MoveCreationInfo& moveInfo : moveInfoList) {
    MoveStateSetup moveSetup(registry);
    moveSetup.setName(moveInfo.name);
    moveSetup.setPP(moveInfo.pp);
    moveSetup.setMaxPP(moveInfo.maxPp);
    moveEntities.push_back(moveSetup.entity());
  }

  return moveEntities;
}

inline PokemonStateSetup Simulation::createInitialPokemon(const PokemonCreationInfo& pokemonInfo) {
  PokemonStateSetup pokemonSetup(registry);
  if (pokemonInfo.id.has_value()) {
    pokemonSetup.setID(pokemonInfo.id.value());
  }
  else {
    pokemonSetup.setAutoID();
  }

  pokemonSetup.setSpecies(pokemonInfo.species);
  pokemonSetup.setLevel(pokemonInfo.level);
  if (pokemonInfo.types.has_value()) {
    pokemonSetup.setTypes(pokemonInfo.types.value());
  }
  else {
    pokemonSetup.setTypes(pokedex.getSpeciesData<SpeciesTypes>(pokemonInfo.species));
  }
  if (pokemonInfo.gender != dex::Gender::NO_GENDER) pokemonSetup.setGender(pokemonInfo.gender);
  if (pokemonInfo.ability != dex::Ability::NO_ABILITY) pokemonSetup.setAbility(pokemonInfo.ability);
  if (pokemonInfo.item != dex::Item::NO_ITEM) pokemonSetup.setItem(pokemonInfo.item);
  if (pokemonInfo.nature != dex::Nature::NO_NATURE) pokemonSetup.setNature(pokemonInfo.nature);
  if (pokemonInfo.status != dex::Status::NO_STATUS) pokemonSetup.setStatus(pokemonInfo.status);

  pokemonSetup.setEVs(pokemonInfo.evs);
  pokemonSetup.setIVs(pokemonInfo.ivs);
  pokemonSetup.setStat<stat::Hp>(pokemonInfo.stats.hp);
  pokemonSetup.setStat<stat::Atk>(pokemonInfo.stats.atk);
  pokemonSetup.setStat<stat::Def>(pokemonInfo.stats.def);
  pokemonSetup.setStat<stat::Spa>(pokemonInfo.stats.spa);
  pokemonSetup.setStat<stat::Spd>(pokemonInfo.stats.spd);
  pokemonSetup.setStat<stat::Spe>(pokemonInfo.stats.spe);
  pokemonSetup.setHp(pokemonInfo.hp.value_or(pokemonInfo.stats.hp));
  pokemonSetup.setProperty<tags::AtkStatUpdateRequired>();
  pokemonSetup.setProperty<tags::DefStatUpdateRequired>();
  pokemonSetup.setProperty<tags::SpaStatUpdateRequired>();
  pokemonSetup.setProperty<tags::SpdStatUpdateRequired>();
  pokemonSetup.setProperty<tags::SpeStatUpdateRequired>();

  return pokemonSetup;
}

inline void Simulation::createInitialSide(
  SideStateSetup sideSetup, const SideCreationInfo& sideInfo, const BattleCreationInfo& battleInfo) {
  std::vector<PokemonStateSetup> pokemonSetupList;
  pokemonSetupList.reserve(sideInfo.team.size());

  for (std::size_t i = 0; i < sideInfo.team.size(); i++) {
    const PokemonCreationInfo& pokemonInfo = sideInfo.team[i];
    PokemonStateSetup pokemonSetup = createInitialPokemon(pokemonInfo);
    if (
      battleInfo.turn > 0 && !pokemonInfo.fainted &&
      (i == 0 || (battleFormat == BattleFormat::SINGLES_BATTLE_FORMAT && i == 1))) {
      pokemonSetup.setProperty<tags::ActivePokemon>();
    }

    std::vector<types::entity> moveEntities = createInitialMoves(pokemonInfo.moves);

    if (battleInfo.runWithSimulateTurn) {
      registry.insert<tags::SimulateTurn>(moveEntities.begin(), moveEntities.end());
    }
    if (battleInfo.runWithCalculateDamage) {
      registry.insert<tags::CalculateDamage>(moveEntities.begin(), moveEntities.end());
    }
    if (battleInfo.runWithAnalyzeEffect) {
      registry.insert<tags::AnalyzeEffect>(moveEntities.begin(), moveEntities.end());
    }

    pokemonSetup.setMoves(moveEntities);
    pokemonSetupList.push_back(pokemonSetup);
  }

  if (battleInfo.runWithSimulateTurn) {
    sideSetup.setProperty<tags::SimulateTurn>();
    registry.insert<tags::SimulateTurn>(pokemonSetupList.begin(), pokemonSetupList.end());
  }
  if (battleInfo.runWithCalculateDamage) {
    sideSetup.setProperty<tags::CalculateDamage>();
    registry.insert<tags::CalculateDamage>(pokemonSetupList.begin(), pokemonSetupList.end());
  }
  if (battleInfo.runWithAnalyzeEffect) {
    sideSetup.setProperty<tags::AnalyzeEffect>();
    registry.insert<tags::AnalyzeEffect>(pokemonSetupList.begin(), pokemonSetupList.end());
  }

  sideSetup.setTeam(pokemonSetupList);
}

inline std::tuple<SideStateSetup, SideStateSetup> Simulation::createInitialBattle(
  BattleStateSetup battleStateSetup, const BattleCreationInfo& battleInfo) {
  battleStateSetup.setAutoID();
  battleStateSetup.setTurn(battleInfo.turn);
  battleStateSetup.setRNGSeed(battleInfo.rngSeed);
  battleStateSetup.setProbability(battleInfo.probability);

  if (battleInfo.runWithSimulateTurn) {
    battleStateSetup.setProperty<tags::SimulateTurn>();
  }
  if (battleInfo.runWithCalculateDamage) {
    battleStateSetup.setProperty<tags::CalculateDamage>();
  }
  if (battleInfo.runWithAnalyzeEffect) {
    battleStateSetup.setProperty<tags::AnalyzeEffect>();
  }

  SideStateSetup p1SideSetup(registry, PlayerSideId::P1);
  SideStateSetup p2SideSetup(registry, PlayerSideId::P2);

  types::entity battleEntity = battleStateSetup.entity();
  types::entity p1Entity = p1SideSetup.entity();
  types::entity p2Entity = p2SideSetup.entity();

  battleStateSetup.setSide(p1Entity);
  battleStateSetup.setSide(p2Entity);

  p1SideSetup.setOpponent(p2Entity);
  p2SideSetup.setOpponent(p1Entity);

  p1SideSetup.setBattle(battleEntity);
  p2SideSetup.setBattle(battleEntity);

  return {p1SideSetup, p2SideSetup};
}

inline void Simulation::createInitialTurnDecision(
  BattleStateSetup battleStateSetup, const TurnDecisionInfo& turnDecisionInfo) {
  types::handle battleHandle{registry, battleStateSetup.entity()};
  const Sides& sides = battleHandle.get<Sides>();

  registry.emplace<SideDecision>(sides.p1(), turnDecisionInfo.p1);
  registry.emplace<SideDecision>(sides.p2(), turnDecisionInfo.p2);
}

inline void Simulation::createCalcDamageInput(
  BattleStateSetup battleStateSetup, calc_damage::InputSetup& inputSetup, const CalcDamageInputInfo& inputInfo) {
  POKESIM_ASSERT(inputInfo.attackerSlot != Slot::NONE, "A damage calculation must have a attacker.");
  POKESIM_ASSERT(inputInfo.defenderSlot != Slot::NONE, "A damage calculation must have a defender.");
  POKESIM_ASSERT(inputInfo.move != dex::Move::NO_MOVE, "A damage calculation must have a move.");

  const Sides& sides = registry.get<Sides>(battleStateSetup.entity());
  types::entity attackerEntity = slotToPokemonEntity(registry, sides, inputInfo.attackerSlot);
  types::entity defenderEntity = slotToPokemonEntity(registry, sides, inputInfo.defenderSlot);

  inputSetup.setup(battleStateSetup.entity(), attackerEntity, defenderEntity, inputInfo.move, pokedex);
}

inline void Simulation::createAnalyzeEffectInput(
  BattleStateSetup battleStateSetup, analyze_effect::InputSetup& inputSetup, const AnalyzeEffectInputInfo& inputInfo) {
  POKESIM_ASSERT(inputInfo.attackerSlot != Slot::NONE, "An effect analysis must have a attacker.");
  POKESIM_ASSERT(inputInfo.defenderSlot != Slot::NONE, "An effect analysis must have a defender.");
  POKESIM_ASSERT(inputInfo.effectTarget != Slot::NONE, "An effect analysis must have a effect target.");
  POKESIM_ASSERT(!inputInfo.moves.empty(), "An effect analysis must include a move.");
  const auto& effect = inputInfo.effect;
  const auto& boostEffect = inputInfo.boostEffect;
  POKESIM_ASSERT(
    boostEffect.has_value() || (effect.has_value() && !effect.value().empty()),
    "An effect analysis must have an effect.");

  const Sides& sides = registry.get<Sides>(battleStateSetup.entity());
  types::entity attackerEntity = slotToPokemonEntity(registry, sides, inputInfo.attackerSlot);
  types::entity defenderEntity = slotToPokemonEntity(registry, sides, inputInfo.defenderSlot);
  types::entity effectTargetEntity = slotToPokemonEntity(registry, sides, inputInfo.effectTarget);

  inputSetup.setAttacker(attackerEntity);
  inputSetup.setDefender(defenderEntity);
  inputSetup.setEffectTarget(effectTargetEntity);
  inputSetup.setEffectMoves(inputInfo.moves);
  inputSetup.setBattle(battleStateSetup.entity());

  if (effect.has_value()) {
    inputSetup.setEffect(effect.value());
  }
  if (boostEffect.has_value()) {
    inputSetup.setBoostEffect(boostEffect.value().stat, boostEffect.value().boost);
  }
}

inline void Simulation::createInitialStates(const std::vector<BattleCreationInfo>& battleInfoList) {
  debug::SimulationSetupChecks debugChecks(registry, battleInfoList);

  for (const BattleCreationInfo& battleInfo : battleInfoList) {
    BattleStateSetup battleStateSetup(registry);
    auto [p1SideSetup, p2SideSetup] = createInitialBattle(battleStateSetup, battleInfo);

    createInitialSide(p1SideSetup, battleInfo.p1, battleInfo);
    createInitialSide(p2SideSetup, battleInfo.p2, battleInfo);

    debugChecks.addToBattleChecklist(battleStateSetup, battleInfo);

    if (!battleInfo.decisionsToSimulate.empty()) {
      POKESIM_ASSERT(
        battleInfo.decisionsToSimulate.size() < std::numeric_limits<types::cloneIndex>::max(),
        "Cannot make more clones than there are entities available.");

      types::cloneIndex cloneCount = (types::cloneIndex)(battleInfo.decisionsToSimulate.size() - 1);
      if (cloneCount) {
        std::vector<BattleStateSetup> clones = battleStateSetup.clone(cloneCount);

        for (types::cloneIndex i = 0; i < cloneCount; i++) {
          BattleStateSetup& setupClone = clones[i];
          const TurnDecisionInfo& turnDecisionInfo = battleInfo.decisionsToSimulate[i];
          debugChecks.addToBattleChecklist(setupClone, battleInfo);

          createInitialTurnDecision(setupClone, turnDecisionInfo);
          setupClone.setID(i);

          debugChecks.addToTurnDecisionChecklist(setupClone, turnDecisionInfo);
        }
      }

      createInitialTurnDecision(battleStateSetup, battleInfo.decisionsToSimulate.back());
      debugChecks.addToTurnDecisionChecklist(battleStateSetup, battleInfo.decisionsToSimulate.back());
      battleStateSetup.setID(cloneCount);
    }

    for (const CalcDamageInputInfo& calcDamageInputInfo : battleInfo.damageCalculations) {
      calc_damage::InputSetup inputSetup(registry);
      createCalcDamageInput(battleStateSetup, inputSetup, calcDamageInputInfo);
      debugChecks.addToCalcDamageChecklist(battleStateSetup, inputSetup, calcDamageInputInfo);
    }

    for (const AnalyzeEffectInputInfo& analyzeEffectInputInfo : battleInfo.effectsToAnalyze) {
      analyze_effect::InputSetup inputSetup(registry);
      createAnalyzeEffectInput(battleStateSetup, inputSetup, analyzeEffectInputInfo);
      debugChecks.addToAnalyzeEffectChecklist(battleStateSetup, inputSetup, analyzeEffectInputInfo);
    }
  }
}
}  // namespace pokesim

////////////////// END OF src/Simulation/SimulationSetup.cpp ///////////////////

////////////////////// START OF src/Components/Damage.hpp //////////////////////

#include <vector>

namespace pokesim {
struct Damage {
  types::damage val = 1;
};

struct DamageRollModifiers {
  StabBoostKind stab = StabBoostKind::NONE;
  types::typeEffectiveness typeEffectiveness = 0;
  bool burn = false;
  bool zOrMaxBrokenProtect = false;
  types::eventModifier modifyDamageEvent = MechanicConstants::FIXED_POINT_SCALE;

  bool operator==(const DamageRollModifiers& other) const {
    return stab == other.stab && typeEffectiveness == other.typeEffectiveness && burn == other.burn &&
           modifyDamageEvent == other.modifyDamageEvent && zOrMaxBrokenProtect == other.zOrMaxBrokenProtect;
  }
};

struct DamageRolls {
  std::vector<Damage> val{};

  DamageRolls() {}
  DamageRolls(const DamageRolls& other) : val(other.val) {}

  DamageRolls(const std::vector<types::damage>& list) {
    val.reserve(list.size());
    for (types::damage damage : list) {
      val.push_back({damage});
    }
  }

  types::damage min() const {
    POKESIM_ASSERT(!val.empty(), "DamageRolls has no values to read.");
    return val.back().val;
  }

  types::damage max() const {
    POKESIM_ASSERT(!val.empty(), "DamageRolls has no values to read.");
    return val.front().val;
  }
};
}  // namespace pokesim

/////////////////////// END OF src/Components/Damage.hpp ///////////////////////

//////////////// START OF src/Components/SimulationResults.hpp /////////////////

#include <vector>

namespace pokesim {
namespace simulate_turn {
struct TurnOutcomeBattles {
  std::vector<types::entity> val{};
};
}  // namespace simulate_turn

namespace calc_damage {
struct UsesUntilKo {
 private:
  struct KoChance {
    types::moveHits uses = 0;
    types::useUntilKoChance chance = 0.0F;

    bool operator==(const KoChance& other) const { return uses == other.uses && chance == other.chance; }
  };

 public:
  std::vector<KoChance> val{};

  const KoChance& minHits() const {
    POKESIM_ASSERT(!val.empty(), "UsesUntilKo has no values to read.");
    return val.front();
  }

  const KoChance& maxHits() const {
    POKESIM_ASSERT(!val.empty(), "UsesUntilKo has no values to read.");
    return val.back();
  }

  bool guaranteedKo() const {
    const KoChance& min = minHits();
    return min.uses == 1 && min.chance == 1.0F;
  }
};

struct AttackerHpRecovered : DamageRolls {};
struct AttackerHpLost : DamageRolls {};
}  // namespace calc_damage

namespace analyze_effect {
struct EffectMultiplier {
  types::effectMultiplier val = 1.0F;
};

using MultipliedDamageRolls = DamageRolls;
using MultipliedUsesUntilKo = calc_damage::UsesUntilKo;

namespace tags {
struct InfiniteMultiplier {};
}  // namespace tags
}  // namespace analyze_effect
}  // namespace pokesim

///////////////// END OF src/Components/SimulationResults.hpp //////////////////

//////////////// START OF src/Simulation/SimulationResults.hpp /////////////////

namespace pokesim {
class Simulation;
struct Damage;
struct DamageRolls;

namespace simulate_turn {
struct TurnOutcomeBattles;
struct Results {
  inline types::view<TurnOutcomeBattles> turnOutcomeBattlesResults() const;

  inline Results(const Simulation& simulation_);

 private:
  const Simulation& simulation;
};
}  // namespace simulate_turn

namespace calc_damage {
struct UsesUntilKo;
struct AttackerHpRecovered;
struct AttackerHpLost;

struct Results {
  inline types::view<DamageRolls> damageRollResults() const;
  inline types::view<UsesUntilKo> usesUntilKoResults() const;
  inline types::view<AttackerHpRecovered> hpRecoveredResults() const;
  inline types::view<AttackerHpLost> hpLostResults() const;

  inline Results(const Simulation& simulation_);

 private:
  const Simulation& simulation;
};
}  // namespace calc_damage

namespace analyze_effect {
struct EffectMultiplier;
using MultipliedDamageRolls = DamageRolls;
using MultipliedUsesUntilKo = calc_damage::UsesUntilKo;

struct Results {
  inline types::view<EffectMultiplier> effectMultiplierResults() const;
  inline types::view<MultipliedDamageRolls> multipliedDamageRollsResults() const;
  inline types::view<MultipliedUsesUntilKo> multipliedUsesUntilKoResults() const;

  inline Results(const Simulation& simulation_);

 private:
  const Simulation& simulation;
};
}  // namespace analyze_effect
}  // namespace pokesim

///////////////// END OF src/Simulation/SimulationResults.hpp //////////////////

//////////////// START OF src/Simulation/SimulationResults.cpp /////////////////

namespace pokesim {
namespace simulate_turn {
Results::Results(const Simulation& simulation_) : simulation(simulation_) {}

inline types::view<TurnOutcomeBattles> Results::turnOutcomeBattlesResults() const {
  return simulation.registry.view<TurnOutcomeBattles>();
}
}  // namespace simulate_turn

namespace calc_damage {
Results::Results(const Simulation& simulation_) : simulation(simulation_) {}

inline types::view<DamageRolls> Results::damageRollResults() const {
  return simulation.registry.view<DamageRolls>();
}

inline types::view<UsesUntilKo> Results::usesUntilKoResults() const {
  return simulation.registry.view<UsesUntilKo>();
}

inline types::view<AttackerHpRecovered> Results::hpRecoveredResults() const {
  return simulation.registry.view<AttackerHpRecovered>();
}

inline types::view<AttackerHpLost> Results::hpLostResults() const {
  return simulation.registry.view<AttackerHpLost>();
}
}  // namespace calc_damage

namespace analyze_effect {
Results::Results(const Simulation& simulation_) : simulation(simulation_) {}

inline types::view<EffectMultiplier> Results::effectMultiplierResults() const {
  return simulation.registry.view<EffectMultiplier>();
}

inline types::view<MultipliedDamageRolls> Results::multipliedDamageRollsResults() const {
  return simulation.registry.view<MultipliedDamageRolls>();
}

inline types::view<MultipliedUsesUntilKo> Results::multipliedUsesUntilKoResults() const {
  return simulation.registry.view<MultipliedUsesUntilKo>();
}
}  // namespace analyze_effect
}  // namespace pokesim

///////////////// END OF src/Simulation/SimulationResults.cpp //////////////////

///////////////// START OF src/AnalyzeEffect/AnalyzeEffect.hpp /////////////////

namespace pokesim {
class Simulation;

namespace analyze_effect {
inline void run(Simulation& simulation);
}  // namespace analyze_effect
}  // namespace pokesim

////////////////// END OF src/AnalyzeEffect/AnalyzeEffect.hpp //////////////////

////////////// START OF src/Battle/Pokemon/ManagePokemonState.hpp //////////////

namespace pokesim {
class Simulation;
struct CurrentActionSource;
struct CurrentActionTargets;
struct CurrentActionMoveSlot;
struct Damage;
struct Pp;

namespace stat {
struct Atk;
struct Def;
struct Spa;
struct Spd;
struct Spe;
struct CurrentHp;
}  // namespace stat

inline void setStatus(types::handle pokemonHandle, dex::Status status);
inline void clearStatus(types::handle pokemonHandle);

inline void deductPp(Pp& pp);
inline void setLastMoveUsed(types::registry& registry, const CurrentActionSource& source, const CurrentActionMoveSlot& move);
inline void resetEffectiveAtk(types::handle handle, stat::Atk atk);
inline void resetEffectiveDef(types::handle handle, stat::Def def);
inline void resetEffectiveSpa(types::handle handle, stat::Spa spa);
inline void resetEffectiveSpd(types::handle handle, stat::Spd spd);
inline void resetEffectiveSpe(types::handle handle, stat::Spe spe);

inline void applyDamageToHp(types::registry& registry, const Damage& damage, CurrentActionTargets& targets);

inline void updateAllStats(Simulation& simulation);
inline void updateAtk(Simulation& simulation);
inline void updateDef(Simulation& simulation);
inline void updateSpa(Simulation& simulation);
inline void updateSpd(Simulation& simulation);
inline void updateSpe(Simulation& simulation);
}  // namespace pokesim

/////////////// END OF src/Battle/Pokemon/ManagePokemonState.hpp ///////////////

//////////////////// START OF src/CalcDamage/CalcDamage.hpp ////////////////////

namespace pokesim {
class Simulation;
struct Damage;

namespace calc_damage {
inline void run(Simulation& simulation);

inline void applyDamageRoll(Damage& damage, types::damageRoll damageRoll);
inline void applyAverageDamageRoll(Damage& damage);
inline void applyMinDamageRoll(Damage& damage);

inline void setDamageRollModifiers(Simulation& simulation);
template <typename SimulationTag>
inline void applyDamageRollsAndModifiers(
  Simulation& simulation, DamageRollKind damageRollKind, bool calculateUpToFoeHp, bool noKoChanceCalculation);

template <typename SimulationTag>
inline void setIfMoveCrits(Simulation& simulation, DamageRollKind damageRollKind);
inline void getDamage(Simulation& simulation);
}  // namespace calc_damage
}  // namespace pokesim

///////////////////// END OF src/CalcDamage/CalcDamage.hpp /////////////////////

///////////////////// START OF src/Components/HitCount.hpp /////////////////////

namespace pokesim {
struct HitCount {
  types::moveHits val = 1;
};
}  // namespace pokesim

////////////////////// END OF src/Components/HitCount.hpp //////////////////////

////////////////// START OF src/SimulateTurn/SimulateTurn.hpp //////////////////

namespace pokesim {
class Simulation;
class Pokedex;
struct Battle;
struct CurrentActionTargets;
struct CurrentActionSource;

namespace simulate_turn {
inline void run(Simulation& simulation);
inline void runCurrentAction(Simulation& simulation);
inline void nextTurn(Simulation& simulation);

inline void runBeforeTurnAction(Simulation& simulation);
inline void runMoveAction(Simulation& simulation);
inline void runResidualAction(Simulation& simulation);

inline void addTargetAllyToTargets(types::registry& registry, const Battle& battle);
inline void addUserAllyToTargets(types::registry& registry, const Battle& battle);
inline void resolveMoveTargets(CurrentActionTargets&);
inline void createActionMoveForTargets(
  types::handle targetHandle, const Battle& battle, const CurrentActionSource& source, const Pokedex& pokedex);
inline void getMoveTargets(Simulation& simulation);

inline void useMove(Simulation& simulation);
}  // namespace simulate_turn
}  // namespace pokesim

/////////////////// END OF src/SimulateTurn/SimulateTurn.hpp ///////////////////

//////////////////// START OF src/Simulation/Simulation.cpp ////////////////////

namespace pokesim {
inline void Simulation::clearAllResults() {
  clearSimulateTurnResults();
  clearCalculateDamageResults();
  clearAnalyzeEffectResults();
}

inline void Simulation::clearSimulateTurnResults() {
  registry.clear<simulate_turn::TurnOutcomeBattles>();
}

inline void Simulation::clearCalculateDamageResults() {
  registry.clear<calc_damage::UsesUntilKo, calc_damage::AttackerHpRecovered, calc_damage::AttackerHpLost>();
}

inline void Simulation::clearAnalyzeEffectResults() {
  registry.clear<
    analyze_effect::EffectMultiplier,
    analyze_effect::MultipliedDamageRolls,
    analyze_effect::MultipliedUsesUntilKo>();
}

inline simulate_turn::Results Simulation::simulateTurn(std::optional<simulate_turn::Options> options) {
  if (options.has_value()) {
    simulateTurnOptions = options.value();
  }

  simulate_turn::run(*this);

  return {*this};
}

inline calc_damage::Results Simulation::calculateDamage(std::optional<calc_damage::Options> options) {
  if (options.has_value()) {
    calculateDamageOptions = options.value();
  }

  updateAllStats(*this);
  calc_damage::run(*this);

  return {*this};
}

inline analyze_effect::Results Simulation::analyzeEffect(std::optional<analyze_effect::Options> options) {
  if (options.has_value()) {
    analyzeEffectOptions = options.value();
  }

  updateAllStats(*this);
  analyze_effect::run(*this);

  return {*this};
}

inline simulate_turn::Results Simulation::simulateTurn(
  const std::vector<BattleCreationInfo>& battleInfoList, std::optional<simulate_turn::Options> options) {
  createInitialStates(battleInfoList);
  return simulateTurn(options);
}

inline calc_damage::Results Simulation::calculateDamage(
  const std::vector<BattleCreationInfo>& battleInfoList, std::optional<calc_damage::Options> options) {
  createInitialStates(battleInfoList);
  return calculateDamage(options);
}

inline analyze_effect::Results Simulation::analyzeEffect(
  const std::vector<BattleCreationInfo>& battleInfoList, std::optional<analyze_effect::Options> options) {
  createInitialStates(battleInfoList);
  return analyzeEffect(options);
}

inline void Simulation::run() {
  clearAllResults();
  simulateTurn();
  calculateDamage();
  analyzeEffect();
}

inline std::vector<types::entity> Simulation::selectedBattleEntities() const {
  if (hasActiveSelection<tags::SelectedForViewBattle>()) {
    auto view = registry.view<tags::SelectedForViewBattle, tags::Battle>();
    return {view.begin(), view.end()};
  }

  auto view = registry.view<tags::Battle>();
  return {view.begin(), view.end()};
}

inline std::vector<types::entity> Simulation::selectedMoveEntities() const {
  if (hasActiveSelection<tags::SelectedForViewMove>()) {
    auto view = registry.view<tags::SelectedForViewMove, tags::CurrentActionMove>();
    return {view.begin(), view.end()};
  }

  auto view = registry.view<tags::CurrentActionMove>();
  return {view.begin(), view.end()};
}

inline std::vector<types::entity> Simulation::selectedPokemonEntities() const {
  if (hasActiveSelection<tags::SelectedForViewPokemon>()) {
    auto view = registry.view<tags::SelectedForViewPokemon, tags::Pokemon>();
    return {view.begin(), view.end()};
  }

  auto view = registry.view<tags::Pokemon>();
  return {view.begin(), view.end()};
}
}  // namespace pokesim

///////////////////// END OF src/Simulation/Simulation.cpp /////////////////////

//////////////// START OF src/Battle/Helpers/IntegerModify.hpp /////////////////

namespace pokesim {
template <typename Number1, typename Number2>
types::eventModifier fixedPointMultiply(Number1 value, Number2 multiplier) {
  types::eventModifier modifier = multiplier * MechanicConstants::FIXED_POINT_SCALE;
  types::eventModifier modified = value * modifier;
  types::eventModifier scaled = modified + MechanicConstants::FIXED_POINT_HALF_SCALE - 1U;
  return scaled / MechanicConstants::FIXED_POINT_SCALE;
}

template <typename Number1>
void applyChainedModifier(Number1& value, types::eventModifier eventModifier) {
  types::eventModifier modified = value * eventModifier;
  types::eventModifier scaled = modified + MechanicConstants::FIXED_POINT_HALF_SCALE - 1U;
  value = scaled / MechanicConstants::FIXED_POINT_SCALE;
}

template <typename Multiplier>
void chainToModifier(types::eventModifier& eventModifier, Multiplier multiplier) {
  types::eventModifier newModifier = multiplier * MechanicConstants::FIXED_POINT_SCALE;
  eventModifier =
    (eventModifier * newModifier + MechanicConstants::FIXED_POINT_HALF_SCALE) / MechanicConstants::FIXED_POINT_SCALE;
}
}  // namespace pokesim

///////////////// END OF src/Battle/Helpers/IntegerModify.hpp //////////////////

///////////// START OF src/Components/EntityHolders/ChoiceLock.hpp /////////////

namespace pokesim {
struct ChoiceLock {
  types::entity val{};
};
}  // namespace pokesim

////////////// END OF src/Components/EntityHolders/ChoiceLock.hpp //////////////

////////////////// START OF src/Components/EventModifier.hpp ///////////////////

namespace pokesim {
struct EventModifier {
  types::eventModifier val = MechanicConstants::FIXED_POINT_SCALE;
};
}  // namespace pokesim

/////////////////// END OF src/Components/EventModifier.hpp ////////////////////

////////////////// START OF src/Components/Tags/ItemTags.hpp ///////////////////

// TODO(aed3): Make this auto generated

namespace pokesim::item::tags {
struct AssaultVest {};
struct BrightPowder {};
struct ChoiceScarf {};
struct ChoiceSpecs {};
struct FocusSash {};
struct LifeOrb {};
}  // namespace pokesim::item::tags

/////////////////// END OF src/Components/Tags/ItemTags.hpp ////////////////////

///////////////// START OF src/Components/Tags/StatusTags.hpp //////////////////

// TODO(aed3): Make this auto generated

namespace pokesim::status::tags {
struct Burn {};
struct Freeze {};
struct Paralysis {};
struct Poison {};
struct Sleep {};
struct Toxic {};
}  // namespace pokesim::status::tags

////////////////// END OF src/Components/Tags/StatusTags.hpp ///////////////////

////////////////// START OF src/Pokedex/Abilities/Static.hpp ///////////////////

#include <string_view>

namespace pokesim {
class Simulation;

namespace stat {
struct EffectiveSpe;
}
}  // namespace pokesim

namespace pokesim::dex {
namespace internal {
struct StaticEvents {
  inline static void onDamagingHit(Simulation& simulation);
  inline static void onModifySpe(stat::EffectiveSpe& effectiveSpe);
};
}  // namespace internal

template <GameMechanics>
struct Static : internal::StaticEvents {
  static constexpr dex::Ability name = dex::Ability::STATIC;

  struct Strings {
    static constexpr std::string_view name = "Static";
    static constexpr std::string_view smogonId = "static";
  };
};

namespace latest {
using Static = dex::Static<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Abilities/Static.hpp ////////////////////

///////////////// START OF src/Pokedex/Effects/ChoiceLock.hpp //////////////////

#include <string_view>

namespace pokesim {
struct ChoiceLock;
struct MoveSlots;
}  // namespace pokesim

namespace pokesim::dex {
namespace internal {
struct ChoiceLockEvents {
  inline static void onDisableMove(
    types::registry& registry, const pokesim::ChoiceLock& choiceLocked, const MoveSlots& moveSlots);
};
}  // namespace internal

template <GameMechanics>
struct ChoiceLock : internal::ChoiceLockEvents {
  static constexpr dex::Volatile name = dex::Volatile::CHOICE_LOCK;

  struct Strings {
    static constexpr std::string_view name = "Choice Lock";
    static constexpr std::string_view smogonId = "choicelock";
  };
};

namespace latest {
using ChoiceLock = dex::ChoiceLock<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

////////////////// END OF src/Pokedex/Effects/ChoiceLock.hpp ///////////////////

////////////////// START OF src/Pokedex/Items/AssaultVest.hpp //////////////////

#include <string_view>

namespace pokesim {
struct EventModifier;
}  // namespace pokesim

namespace pokesim::dex {
namespace internal {
struct AssaultVestEvents {
  inline static void onModifySpd(EventModifier& eventModifier);
};
}  // namespace internal

template <GameMechanics>
struct AssaultVest : internal::AssaultVestEvents {
  static constexpr dex::Item name = dex::Item::ASSAULT_VEST;

  static constexpr float onModifySpdModifier = 1.5F;
  struct Strings {
    static constexpr std::string_view name = "Assault Vest";
    static constexpr std::string_view smogonId = "assaultvest";
  };
};

namespace latest {
using AssaultVest = dex::AssaultVest<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Items/AssaultVest.hpp ///////////////////

///////////////// START OF src/Pokedex/Items/BrightPowder.hpp //////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct BrightPowder {
  static constexpr dex::Item name = dex::Item::BRIGHT_POWDER;

  struct Strings {
    static constexpr std::string_view name = "Bright Powder";
    static constexpr std::string_view smogonId = "brightpowder";
  };
};
}  // namespace pokesim::dex

////////////////// END OF src/Pokedex/Items/BrightPowder.hpp ///////////////////

////////////////// START OF src/Pokedex/Items/ChoiceScarf.hpp //////////////////

#include <string_view>

namespace pokesim {
struct EventModifier;
struct Battle;
}  // namespace pokesim

namespace pokesim::dex {
namespace internal {
struct ChoiceScarfEvents {
  inline static void onModifySpe(EventModifier& eventModifier);
  inline static void onSourceModifyMove(types::handle pokemonHandle, const Battle& battle);
};
}  // namespace internal

template <GameMechanics>
struct ChoiceScarf : internal::ChoiceScarfEvents {
  static constexpr dex::Item name = dex::Item::CHOICE_SCARF;

  static constexpr float onModifySpeModifier = 1.5F;
  struct Strings {
    static constexpr std::string_view name = "Choice Scarf";
    static constexpr std::string_view smogonId = "choicescarf";
  };
};

namespace latest {
using ChoiceScarf = dex::ChoiceScarf<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Items/ChoiceScarf.hpp ///////////////////

////////////////// START OF src/Pokedex/Items/ChoiceSpecs.hpp //////////////////

#include <string_view>

namespace pokesim {
struct EventModifier;
struct Battle;
}  // namespace pokesim

namespace pokesim::dex {
namespace internal {
struct ChoiceSpecsEvents {
  inline static void onModifySpa(EventModifier& eventModifier);
  inline static void onSourceModifyMove(types::handle pokemonHandle, const Battle& battle);
};
}  // namespace internal

template <GameMechanics>
struct ChoiceSpecs : internal::ChoiceSpecsEvents {
  static constexpr dex::Item name = dex::Item::CHOICE_SPECS;

  static constexpr float onModifySpaModifier = 1.5F;
  struct Strings {
    static constexpr std::string_view name = "Choice Specs";
    static constexpr std::string_view smogonId = "choicespecs";
  };
};

namespace latest {
using ChoiceSpecs = dex::ChoiceSpecs<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Items/ChoiceSpecs.hpp ///////////////////

/////////////////// START OF src/Pokedex/Items/FocusSash.hpp ///////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct FocusSash {
  static constexpr dex::Item name = dex::Item::FOCUS_SASH;

  struct Strings {
    static constexpr std::string_view name = "Focus Sash";
    static constexpr std::string_view smogonId = "focussash";
  };
};
}  // namespace pokesim::dex

//////////////////// END OF src/Pokedex/Items/FocusSash.hpp ////////////////////

//////////////////// START OF src/Pokedex/Items/LifeOrb.hpp ////////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct LifeOrb {
  static constexpr dex::Item name = dex::Item::LIFE_ORB;

  struct Strings {
    static constexpr std::string_view name = "Life Orb";
    static constexpr std::string_view smogonId = "lifeorb";
  };
};
}  // namespace pokesim::dex

///////////////////// END OF src/Pokedex/Items/LifeOrb.hpp /////////////////////

///////////////////// START OF src/Simulation/RunEvent.hpp /////////////////////

namespace pokesim {
class Simulation;

inline void runAccuracyEvent(Simulation& simulation);
inline void runModifyAccuracyEvent(Simulation& simulation);
inline void runModifyCritBoostEvent(Simulation& simulation);
inline void runBasePowerEvent(Simulation& simulation);
inline void runDamagingHitEvent(Simulation& simulation);
inline void runModifyMove(Simulation& simulation);
inline void runDisableMove(Simulation& simulation);

inline void runModifyAtk(Simulation& simulation);
inline void runModifyDef(Simulation& simulation);
inline void runModifySpa(Simulation& simulation);
inline void runModifySpd(Simulation& simulation);
inline void runModifySpe(Simulation& simulation);
}  // namespace pokesim

////////////////////// END OF src/Simulation/RunEvent.hpp //////////////////////

/////////////////// START OF src/Utilities/SelectForView.hpp ///////////////////

#include <cstdint>
#include <vector>

namespace pokesim::internal {
template <typename Selection, typename Required, typename... ComponentsToSelect>
struct SelectForView {
  template <typename... ComponentsToExclude>
  SelectForView(
    RegistryContainer& registryContainer_,
    entt::exclude_t<ComponentsToExclude...> exclude = entt::exclude<ComponentsToExclude...>)
      : registryContainer(&registryContainer_),
        selectedCount(registryContainer->select<Selection, Required, ComponentsToSelect...>(exclude)) {
    if (hasNoneSelected()) {
      registryContainer = nullptr;
    }
  }

  SelectForView(RegistryContainer& registryContainer_, RegistryContainer::SelectionFunction selectionFunction)
      : registryContainer(&registryContainer_), selectedCount(registryContainer->select<Selection>(selectionFunction)) {
    if (hasNoneSelected()) {
      registryContainer = nullptr;
    }
  }

  ~SelectForView() { deselect(); }

  void deselect() {
    if (registryContainer) {
      registryContainer->deselect<Selection>();
      registryContainer = nullptr;
    }
  }

  bool hasNoneSelected() const { return selectedCount == 0; }

 private:
  RegistryContainer* registryContainer = nullptr;
  const std::size_t selectedCount = 0;
};

template <typename... ComponentsToSelect>
using SelectForBattleView = SelectForView<tags::SelectedForViewBattle, tags::Battle, ComponentsToSelect...>;
template <typename... ComponentsToSelect>
using SelectForSideView = SelectForView<tags::SelectedForViewSide, tags::Side, ComponentsToSelect...>;
template <typename... ComponentsToSelect>
using SelectForPokemonView = SelectForView<tags::SelectedForViewPokemon, tags::Pokemon, ComponentsToSelect...>;
template <typename... ComponentsToSelect>
using SelectForCurrentActionMoveView =
  SelectForView<tags::SelectedForViewMove, tags::CurrentActionMove, ComponentsToSelect...>;
}  // namespace pokesim::internal

//////////////////// END OF src/Utilities/SelectForView.hpp ////////////////////

///////////////////// START OF src/Simulation/RunEvent.cpp /////////////////////

#include <cstdint>
#include <type_traits>


// TODO(aed3) Auto generate?

namespace pokesim {
namespace internal {
template <typename ModifiedComponent>
void applyEventModifier(ModifiedComponent& component, const EventModifier& eventModifier) {
  applyChainedModifier(component.val, eventModifier.val);
}

template <typename... PokemonSpecifiers>
RegistryContainer::SelectionFunction getMoveEventPokemonSelector() {
  static const size_t SelectAnyPokemon = sizeof...(PokemonSpecifiers) == 0U;
  return {[](const void*, const types::registry& registry) -> std::vector<types::entity> {
    entt::dense_set<types::entity> entities;
    auto selectedMoveView = registry.view<tags::SelectedForViewMove>();
    auto begin = selectedMoveView.begin();
    auto end = selectedMoveView.end();
    if (selectedMoveView.empty()) {
      auto anyMoveView = registry.view<tags::CurrentActionMove>();
      begin = anyMoveView.begin();
      end = anyMoveView.end();
    }

    std::for_each(begin, end, [&registry, &entities](types::entity entity) {
      if constexpr (
        SelectAnyPokemon || std::disjunction_v<std::is_same<PokemonSpecifiers, tags::CurrentActionMoveSource>...>) {
        entities.insert(registry.get<CurrentActionSource>(entity).val);
      }

      if constexpr (
        SelectAnyPokemon || std::disjunction_v<std::is_same<PokemonSpecifiers, tags::CurrentActionMoveTarget>...>) {
        entities.insert(registry.get<CurrentActionTargets>(entity).only());
      }
    });

    return {entities.begin(), entities.end()};
  }};
}
}  // namespace internal

inline void runAccuracyEvent(Simulation& /*simulation*/) {}

inline void runModifyAccuracyEvent(Simulation& /*simulation*/) {}

inline void runModifyCritBoostEvent(Simulation& /*simulation*/) {}

inline void runBasePowerEvent(Simulation& /*simulation*/) {}

inline void runDamagingHitEvent(Simulation& simulation) {
  dex::latest::Static::onDamagingHit(simulation);
}

inline void runModifyMove(Simulation& simulation) {
  internal::SelectForPokemonView<> selectedPokemon{
    simulation,
    internal::getMoveEventPokemonSelector<tags::CurrentActionMoveSource>()};

  simulation.viewForSelectedPokemon<
    dex::latest::ChoiceScarf::onSourceModifyMove,
    Tags<item::tags::ChoiceScarf, tags::CurrentActionMoveSource>,
    entt::exclude_t<ChoiceLock>>();

  simulation.viewForSelectedPokemon<
    dex::latest::ChoiceSpecs::onSourceModifyMove,
    Tags<item::tags::ChoiceSpecs, tags::CurrentActionMoveSource>,
    entt::exclude_t<ChoiceLock>>();
}

inline void runDisableMove(Simulation& simulation) {
  simulation.viewForSelectedPokemon<dex::latest::ChoiceLock::onDisableMove>();
}

inline void runModifyAtk(Simulation&) {}

inline void runModifyDef(Simulation&) {}

inline void runModifySpa(Simulation& simulation) {
  simulation.addToEntities<EventModifier, tags::SelectedForViewPokemon>();

  simulation.viewForSelectedPokemon<dex::latest::ChoiceSpecs::onModifySpa, Tags<item::tags::ChoiceSpecs>>();

  simulation.viewForSelectedPokemon<internal::applyEventModifier<stat::EffectiveSpa>>();
  simulation.registry.clear<EventModifier>();
}

inline void runModifySpd(Simulation& simulation) {
  simulation.addToEntities<EventModifier, tags::SelectedForViewPokemon>();

  simulation.viewForSelectedPokemon<dex::latest::AssaultVest::onModifySpd, Tags<item::tags::AssaultVest>>();

  simulation.viewForSelectedPokemon<internal::applyEventModifier<stat::EffectiveSpd>>();
  simulation.registry.clear<EventModifier>();
}

inline void runModifySpe(Simulation& simulation) {
  simulation.addToEntities<EventModifier, tags::SelectedForViewPokemon>();

  simulation.viewForSelectedPokemon<dex::latest::ChoiceScarf::onModifySpe, Tags<item::tags::ChoiceScarf>>();

  simulation.viewForSelectedPokemon<internal::applyEventModifier<stat::EffectiveSpe>>();
  simulation.registry.clear<EventModifier>();

  simulation.viewForSelectedPokemon<
    dex::latest::Static::onModifySpe,
    Tags<status::tags::Paralysis> /*, entt::exclude_t<ability::tags::QuickFeet>*/>();
}
}  // namespace pokesim

////////////////////// END OF src/Simulation/RunEvent.cpp //////////////////////

///////////////////// START OF src/Components/Accuracy.hpp /////////////////////

namespace pokesim {
struct Accuracy {
  types::percentChance val = 100;
};
}  // namespace pokesim

////////////////////// END OF src/Components/Accuracy.hpp //////////////////////

//////////////// START OF src/Components/RandomEventOutputs.hpp ////////////////

namespace pokesim {
namespace tags {
struct RandomEventA {};
struct RandomEventB {};
struct RandomEventC {};
struct RandomEventD {};
struct RandomEventE {};

using RandomEventCheckPassed = RandomEventA;
using RandomEventCheckFailed = RandomEventB;
}  // namespace tags

// Indicates which of equally likely events was chosen randomly
struct RandomEventIndex {
  types::eventPossibilities val = 0U;
};
}  // namespace pokesim

///////////////// END OF src/Components/RandomEventOutputs.hpp /////////////////

/////////// START OF src/Components/SimulateTurn/MoveHitStepTags.hpp ///////////

namespace pokesim::tags::internal {
struct MoveHits {};
}  // namespace pokesim::tags::internal

//////////// END OF src/Components/SimulateTurn/MoveHitStepTags.hpp ////////////

////////////////// START OF src/Components/Tags/MoveTags.hpp ///////////////////

namespace pokesim::move::tags {
// Move Category Tag
struct Physical {};
// Move Category Tag
struct Special {};
// Move Category Tag
struct Status {};

// Move Property Tag: Makes contact
struct Contact {};
// Move Property Tag: Ignores a target's substitute
struct BypassSubstitute {};
// Move Property Tag: Power is multiplied by 1.2 when used by a Pokemon with the Ability Iron Fist.
struct Punch {};
// Move Property Tag: Move hits 2, 3, 4, or 5 times depending on random chance, items (i.e. Loaded Dice), and abilities
// (i.e. Skill Link)
struct VariableHitCount {};
// Move Property Tag: A multi-hit move where each hit checks accuracy (i.e. Triple Kick)
struct AccuracyDependentHitCount {};

struct Disabled {};

namespace effect {
// Move Effect Participant Tag: Who the effect will affect
struct MoveTarget {};
// Move Effect Participant Tag: Who created the effect
struct MoveSource {};
}  // namespace effect
}  // namespace pokesim::move::tags

/////////////////// END OF src/Components/Tags/MoveTags.hpp ////////////////////

//////////////// START OF src/Components/RandomEventInputs.hpp /////////////////

#include <array>

namespace pokesim {
namespace internal {
// Moves such as Metronome and Psywave, the Forewarn ability, and damage rolls have more random options than this, but
// those cases will be handled separately
const types::eventPossibilities MAX_TYPICAL_RANDOM_OPTIONS = 5U;

template <typename T = void>
struct RandomEventStack;

template <>
struct RandomEventStack<void> {
  types::targets<types::entity> val{};
};

template <typename T>
struct RandomEventStack {
  types::targets<std::pair<decltype(T::val), types::entity>> val{};
};
}  // namespace internal

// Used for random events that have a small number of outcomes that can happen and the chance each event can happen is
// not equal (i.e. how many times a multi-hit move hits, Effect Spore)
template <types::eventPossibilities RANDOM_OPTIONS>
struct RandomEventChances {
  std::array<types::percentChance, RANDOM_OPTIONS> val{};
  static_assert(RANDOM_OPTIONS >= 2U, "RandomEventChances should only be used for events with more than two options.");
  static_assert(
    RANDOM_OPTIONS <= internal::MAX_TYPICAL_RANDOM_OPTIONS,
    "Random events with more options than this should use RandomEqualChance or RandomEventCount");

  types::percentChance chanceA() const { return val[0]; }
  types::percentChance chanceB() const { return val[1] - val[0]; }
  types::percentChance chanceC() const {
    static_assert(RANDOM_OPTIONS >= 3U, "This function is only for events with more than 2 outcomes.");
    return val[2] - val[1];
  }
  types::percentChance chanceD() const {
    static_assert(RANDOM_OPTIONS >= 4U, "This function is only for events with more than 3 outcomes.");
    return val[3] - val[2];
  }
  types::percentChance chanceE() const {
    static_assert(RANDOM_OPTIONS == 5U, "This function is only for events with 5 outcomes.");
    return val[4] - val[3];
  }
};

// Used for random events that always have two outcomes where the chance the events happens may not be equal (i.e. move
// accuracy checks, secondary move effects)
struct RandomBinaryChance {
  types::percentChance val = 100U;

  types::percentChance pass() const { return val; }
  types::percentChance fail() const { return 100U - pass(); }
  types::probability reciprocalPass() const { return 100.0F / (types::probability)pass(); }
  types::probability reciprocalFail() const { return 100U - reciprocalPass(); }
};

namespace tags {
// Used for when the number of outcomes a random event can have is always the same (i.e. damage rolls, Psywave) and the
// chance each of those events can happen is equal
struct RandomEqualChance {};
}  // namespace tags

// Used for when the number of outcomes a random event can have depends on the situation (i.e. speed ties, Trace) and
// the chance each of those events can happen is equal
struct RandomEventCount {
  types::eventPossibilities val = 0U;
};

template <types::eventPossibilities RANDOM_OPTIONS>
struct RandomEventChancesStack : internal::RandomEventStack<RandomEventChances<RANDOM_OPTIONS>> {};
struct RandomBinaryChanceStack : internal::RandomEventStack<RandomBinaryChance> {};
struct RandomEventCountStack : internal::RandomEventStack<RandomEventCount> {};
struct RandomEqualChanceStack : internal::RandomEventStack<> {};
}  // namespace pokesim

///////////////// END OF src/Components/RandomEventInputs.hpp //////////////////

////////////////// START OF src/SimulateTurn/RandomChance.hpp //////////////////

#include <optional>

namespace pokesim {
namespace internal {
template <types::eventPossibilities POSSIBLE_EVENT_COUNT, BattleFormat Format>
void setRandomChoice(types::handle handle, const std::array<types::percentChance, POSSIBLE_EVENT_COUNT>& chances) {
  if constexpr (Format == BattleFormat::SINGLES_BATTLE_FORMAT) {
    handle.emplace<RandomEventChances<POSSIBLE_EVENT_COUNT>>(chances);
  }
  else {
    handle.registry()
      ->get_or_emplace<RandomEventChancesStack<POSSIBLE_EVENT_COUNT>>(handle.get<Battle>().val)
      .val.emplace_back(chances, handle.entity());
  }
}

template <BattleFormat Format>
void setBinaryChanceByFormat(types::handle handle, types::percentChance percentChance) {
  if constexpr (Format == BattleFormat::SINGLES_BATTLE_FORMAT) {
    handle.emplace<RandomBinaryChance>(percentChance);
  }
  else {
    handle.registry()
      ->get_or_emplace<RandomBinaryChanceStack>(handle.get<Battle>().val)
      .val.emplace_back(percentChance, handle.entity());
  }
}

enum class PercentChanceLimitResult : std::uint8_t {
  NO_LIMIT_REACHED = 0,
  REACHED_PASS_LIMIT,
  REACHED_FAIL_LIMIT,
};

inline PercentChanceLimitResult checkPercentChanceLimits(
  types::percentChance percentChance, types::probability probability, const simulate_turn::Options& options) {
  const auto& autoPassLimit = options.randomChanceUpperLimit;
  const auto& autoFailLimit = options.randomChanceLowerLimit;
  const auto& branchProbabilityLowerLimit = options.branchProbabilityLowerLimit;

  bool skipBranch = false;
  if (branchProbabilityLowerLimit.has_value()) {
    skipBranch = percentChance * probability <= branchProbabilityLowerLimit.value() * 100;
  }
  const types::percentChance PASS_FAIL_BOUNDARY = 50U;

  if (percentChance >= autoPassLimit.value_or(100U) || (skipBranch && percentChance >= PASS_FAIL_BOUNDARY)) {
    return PercentChanceLimitResult::REACHED_PASS_LIMIT;
  }

  if (percentChance <= autoFailLimit.value_or(0U) || skipBranch) {
    return PercentChanceLimitResult::REACHED_FAIL_LIMIT;
  }

  return PercentChanceLimitResult::NO_LIMIT_REACHED;
}

template <BattleFormat Format>
void setBinaryChanceFromChanceLimit(
  types::handle handle, types::percentChance passChance, types::percentChance percentChance,
  types::probability probability, const simulate_turn::Options& options) {
  PercentChanceLimitResult limitReached = checkPercentChanceLimits(passChance, probability, options);

  switch (limitReached) {
    case PercentChanceLimitResult::REACHED_PASS_LIMIT: {
      handle.emplace<tags::RandomEventCheckPassed>();
      return;
    }
    case PercentChanceLimitResult::REACHED_FAIL_LIMIT: {
      handle.emplace<tags::RandomEventCheckFailed>();
      return;
    }
    default: {
      setBinaryChanceByFormat<Format>(handle, percentChance);
      return;
    };
  }
}

template <typename Component, BattleFormat Format>
void setRandomBinaryChoice(
  types::handle handle, const Component& percentChance, const Battle& battle, const simulate_turn::Options& options) {
  types::probability probability = handle.registry()->get<Probability>(battle.val).val;

  setBinaryChanceFromChanceLimit<Format>(handle, percentChance.val, percentChance.val, probability, options);
}

template <typename Component, BattleFormat Format>
void setReciprocalRandomBinaryChoice(
  types::handle handle, const Component& percentChance, const Battle& battle, const simulate_turn::Options& options) {
  types::percentChance passChance = 100U / percentChance.val;
  types::probability probability = handle.registry()->get<Probability>(battle.val).val;

  setBinaryChanceFromChanceLimit<Format>(handle, passChance, percentChance.val, probability, options);
}

template <BattleFormat Format>
void setRandomEqualChoice(types::handle handle) {
  if constexpr (Format == BattleFormat::SINGLES_BATTLE_FORMAT) {
    handle.emplace<tags::RandomEqualChance>();
  }
  else {
    handle.registry()
      ->get_or_emplace<RandomEqualChanceStack>(handle.get<Battle>().val)
      .val.emplace_back(handle.entity());
  }
}

template <BattleFormat Format, auto GetPossibleEventCount>
void setRandomEventCounts(
  types::handle handle, const Battle& battle, const simulate_turn::Options& options, bool forRequiredDamageRolls) {
  auto eventCount = GetPossibleEventCount(handle);

  PercentChanceLimitResult limitReached = PercentChanceLimitResult::NO_LIMIT_REACHED;
  if (!forRequiredDamageRolls) {
    types::percentChance passChance = 100.0F / (types::probability)eventCount;
    types::probability probability = handle.registry()->get<Probability>(battle.val).val;
    limitReached = checkPercentChanceLimits(passChance, probability, options);
  }

  if (limitReached == PercentChanceLimitResult::NO_LIMIT_REACHED) {
    if constexpr (Format == BattleFormat::SINGLES_BATTLE_FORMAT) {
      handle.emplace<RandomEventCount>(eventCount);
    }
    else {
      handle.registry()
        ->get_or_emplace<RandomEventCountStack>(handle.get<Battle>().val)
        .val.emplace_back(eventCount, handle.entity());
    }
  }
  else {
    handle.emplace<RandomEventIndex>((types::eventPossibilities)(eventCount / 2U));
  }
}
}  // namespace internal

template <types::eventPossibilities POSSIBLE_EVENT_COUNT, typename... T>
void setRandomChoice(
  Simulation& simulation, std::array<types::percentChance, POSSIBLE_EVENT_COUNT> chances,
  const bool cumulativeSumChances) {
  if (cumulativeSumChances) {
    types::percentChance chanceSum = 0;
    for (types::percentChance& chance : chances) {
      chanceSum += chance;
      chance = chanceSum;
    }

    POKESIM_ASSERT(chanceSum == 100, "The total probability of all possible outcomes should add up to 100%.");
  }
  else {
    POKESIM_ASSERT(chances.back() == 100, "The total probability of all possible outcomes should add up to 100%.");
    for (types::eventPossibilities i = 1; i < POSSIBLE_EVENT_COUNT; i++) {
      POKESIM_ASSERT(
        chances[i - 1] <= chances[i],
        "Chances should be a cumulative sum where each value is greater than the last.");
    }
  }

  if (simulation.battleFormat == BattleFormat::SINGLES_BATTLE_FORMAT) {
    simulation.view<internal::setRandomChoice<POSSIBLE_EVENT_COUNT, BattleFormat::SINGLES_BATTLE_FORMAT>, Tags<T...>>(
      chances);
  }
  else {
    simulation.view<internal::setRandomChoice<POSSIBLE_EVENT_COUNT, BattleFormat::DOUBLES_BATTLE_FORMAT>, Tags<T...>>(
      chances);
  }
}

template <typename Component, typename... T>
void setRandomBinaryChoice(Simulation& simulation) {
  const auto& options = simulation.simulateTurnOptions;

  if (simulation.battleFormat == BattleFormat::SINGLES_BATTLE_FORMAT) {
    simulation.view<internal::setRandomBinaryChoice<Component, BattleFormat::SINGLES_BATTLE_FORMAT>, Tags<T...>>(
      options);
  }
  else {
    simulation.view<internal::setRandomBinaryChoice<Component, BattleFormat::DOUBLES_BATTLE_FORMAT>, Tags<T...>>(
      options);
  }
}

template <typename Component, typename... T>
void setReciprocalRandomBinaryChoice(Simulation& simulation) {
  const auto& options = simulation.simulateTurnOptions;

  if (simulation.battleFormat == BattleFormat::SINGLES_BATTLE_FORMAT) {
    simulation
      .view<internal::setReciprocalRandomBinaryChoice<Component, BattleFormat::SINGLES_BATTLE_FORMAT>, Tags<T...>>(
        options);
  }
  else {
    simulation
      .view<internal::setReciprocalRandomBinaryChoice<Component, BattleFormat::DOUBLES_BATTLE_FORMAT>, Tags<T...>>(
        options);
  }
}

template <typename... T>
void setRandomEqualChoice(Simulation& simulation) {
  if (simulation.battleFormat == BattleFormat::SINGLES_BATTLE_FORMAT) {
    simulation.view<internal::setRandomEqualChoice<BattleFormat::SINGLES_BATTLE_FORMAT>, Tags<T...>>();
  }
  else {
    simulation.view<internal::setRandomEqualChoice<BattleFormat::DOUBLES_BATTLE_FORMAT>, Tags<T...>>();
  }
}

template <auto GetPossibleEventCount, typename... T>
void setRandomEventCounts(Simulation& simulation, bool forRequiredDamageRolls) {
  const auto& options = simulation.simulateTurnOptions;

  if (simulation.battleFormat == BattleFormat::SINGLES_BATTLE_FORMAT) {
    simulation
      .view<internal::setRandomEventCounts<BattleFormat::SINGLES_BATTLE_FORMAT, GetPossibleEventCount>, Tags<T...>>(
        options,
        forRequiredDamageRolls);
  }
  else {
    simulation
      .view<internal::setRandomEventCounts<BattleFormat::DOUBLES_BATTLE_FORMAT, GetPossibleEventCount>, Tags<T...>>(
        options,
        forRequiredDamageRolls);
  }
}

template <types::eventPossibilities POSSIBLE_EVENT_COUNT>
inline void randomEventChances(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities = std::nullopt);
inline void randomBinaryChance(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities = std::nullopt);
inline void reciprocalRandomBinaryChance(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities = std::nullopt);
inline void randomEqualChance(
  Simulation& simulation, types::eventPossibilities possibleEventCount, types::callback applyChoices,
  types::optionalCallback updateProbabilities = std::nullopt);
inline void randomEventCount(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities = std::nullopt);

inline void clearRandomChanceResult(Simulation& simulation);
}  // namespace pokesim

/////////////////// END OF src/SimulateTurn/RandomChance.hpp ///////////////////

/////////////////// START OF src/Simulation/MoveHitSteps.hpp ///////////////////

namespace pokesim {
class Simulation;
struct CurrentActionSource;
struct CurrentActionMoves;
struct CurrentActionTargets;
struct Accuracy;
struct Battle;
struct HitCount;

namespace internal {
inline void deductMoveHitCount(types::handle moveHandle, HitCount& hitCount);

template <auto Function>
inline void runMoveHitCheck(Simulation& simulation);
inline void postMoveHitCheck(Simulation& simulation);
inline void updateCurrentActionTargets(types::registry& registry, CurrentActionTargets& targets);
inline void removeFailedHitTargets(
  types::handle moveTarget, const CurrentActionTargets& targets, const CurrentActionSource& source);
}  // namespace internal

inline void setMoveHitCount(Simulation& simulation);

inline void trySetStatusFromEffect(Simulation& simulation);
inline void applyDamage(Simulation& simulation);
inline void runSecondaryMoveEffects(Simulation& simulation);
inline void accuracyCheck(Simulation& simulation);
inline void moveHitLoop(Simulation& simulation);

inline void runMoveHitChecks(Simulation& simulation);
}  // namespace pokesim

//////////////////// END OF src/Simulation/MoveHitSteps.hpp ////////////////////

/////////////////// START OF src/Simulation/MoveHitSteps.cpp ///////////////////

#include <algorithm>


namespace pokesim {
inline void setMoveHitCount(Simulation& simulation) {
  auto noAssignedHitCount =
    simulation.registry.view<tags::SelectedForViewMove>(entt::exclude<move::tags::VariableHitCount, HitCount>);
  simulation.registry.insert<HitCount>(noAssignedHitCount.begin(), noAssignedHitCount.end(), {(types::moveHits)1U});

  // The 35%-35%-15%-15% out of 100 for 2-3-4-5 hits added so each index is the sum of the chance of its hit count and
  // the hit counts less than it so it works with the randomEventChances function
  static constexpr std::array<types::percentChance, 4U> progressiveMultiHitChances{35U, 70U, 85U, 100U};
  setRandomChoice<4U, tags::SelectedForViewMove, move::tags::VariableHitCount>(
    simulation,
    progressiveMultiHitChances,
    false);

  if (!simulation.registry.view<RandomEventChances<4U>>().empty()) {
    randomEventChances<4U>(simulation, [](Simulation& sim) {
      sim.addToEntities<HitCount, tags::RandomEventA>(HitCount{2U});
      sim.addToEntities<HitCount, tags::RandomEventB>(HitCount{3U});
      sim.addToEntities<HitCount, tags::RandomEventC>(HitCount{4U});
      sim.addToEntities<HitCount, tags::RandomEventD>(HitCount{5U});
    });
  }
}

inline void applyDamage(Simulation& simulation) {
  simulation.viewForSelectedMoves<applyDamageToHp>();

  simulation.removeFromEntities<tags::internal::MoveHits, tags::SelectedForViewMove>(entt::exclude<Damage>);
  simulation.removeFromEntities<tags::SelectedForViewMove>(entt::exclude<tags::internal::MoveHits>);
}

inline void trySetStatusFromEffect(Simulation& /*simulation*/) {}

inline void runSecondaryMoveEffects(Simulation& simulation) {
  // Set secondary effect of active move

  trySetStatusFromEffect(simulation);
}

inline void accuracyCheck(Simulation& simulation) {
  runModifyAccuracyEvent(simulation);
  runAccuracyEvent(simulation);

  setRandomBinaryChoice<Accuracy, tags::SelectedForViewMove>(simulation);
  randomBinaryChance(simulation, [](Simulation& sim) {
    sim.removeFromEntities<tags::internal::MoveHits, tags::SelectedForViewMove, tags::RandomEventCheckFailed>();
  });
}

inline void internal::deductMoveHitCount(types::handle moveHandle, HitCount& hitCount) {
  POKESIM_ASSERT(hitCount.val > 0, "A hit count shouldn't be decremented if it's already 0.");
  hitCount.val--;
  if (!hitCount.val) {
    moveHandle.remove<HitCount>();
  }
}

inline void moveHitLoop(Simulation& simulation) {
  setMoveHitCount(simulation);

  while (!simulation.registry.view<HitCount>().empty()) {
    internal::SelectForCurrentActionMoveView<HitCount> selectedMoves{simulation};
    calc_damage::run(simulation);

    // for simulate turn only
    applyDamage(simulation);
    runSecondaryMoveEffects(simulation);
    runDamagingHitEvent(simulation);

    updateAllStats(simulation);
    internal::postMoveHitCheck(simulation);
    simulation.view<internal::deductMoveHitCount>();
  }
}

inline void internal::removeFailedHitTargets(
  types::handle moveTarget, const CurrentActionTargets& targets, const CurrentActionSource& source) {
  types::registry& registry = *moveTarget.registry();
  for (types::entity target : targets.val) {
    registry.remove<tags::CurrentActionMoveTarget>(target);

    CurrentActionMoves& moves = registry.get<CurrentActionMoves>(target);
    auto newEnd = std::remove(moves.val.begin(), moves.val.end(), moveTarget.entity());
    moves.val.erase(newEnd, moves.val.end());
  }

  CurrentActionMoves& moves = registry.get<CurrentActionMoves>(source.val);
  auto newEnd = std::remove(moves.val.begin(), moves.val.end(), moveTarget.entity());
  moves.val.erase(newEnd, moves.val.end());
}

inline void internal::updateCurrentActionTargets(types::registry& registry, CurrentActionTargets& targets) {
  std::uint8_t deleteCount = 0U;
  for (types::entity& target : targets.val) {
    if (!registry.all_of<tags::CurrentActionMoveTarget>(target)) {
      std::uint8_t swapIndex = targets.val.size() - 1 - deleteCount;
      POKESIM_ASSERT(swapIndex >= 0 && swapIndex < targets.val.size(), "Swap index out of bounds.");
      std::swap(target, targets.val[swapIndex]);
      deleteCount++;
    }
  }

  targets.val.pop_count(deleteCount);
}

inline void internal::postMoveHitCheck(Simulation& simulation) {
  auto removedMoves = simulation.view<
    internal::removeFailedHitTargets,
    Tags<tags::CurrentActionMove>,
    entt::exclude_t<tags::internal::MoveHits>>();
  simulation.registry.destroy(removedMoves.begin(), removedMoves.end());
  simulation.registry.clear<Damage>();
  simulation.view<internal::updateCurrentActionTargets>();
}

template <auto Function>
void internal::runMoveHitCheck(Simulation& simulation) {
  simulation.addToEntities<tags::internal::MoveHits, tags::CurrentActionMove>();

  internal::SelectForCurrentActionMoveView<tags::internal::MoveHits> selectedMoves{simulation};
  if (selectedMoves.hasNoneSelected()) {
    return;
  }

  Function(simulation);
  selectedMoves.deselect();

  postMoveHitCheck(simulation);
  simulation.registry.clear<tags::internal::MoveHits>();
}

inline void runMoveHitChecks(Simulation& simulation) {
  // invulnerabilityCheck
  // hitCheck
  // immunityCheck
  internal::runMoveHitCheck<accuracyCheck>(simulation);
  // breakProtectCheck
  // stealBoostCheck
  internal::runMoveHitCheck<moveHitLoop>(simulation);
}
}  // namespace pokesim

//////////////////// END OF src/Simulation/MoveHitSteps.cpp ////////////////////

///////////////////// START OF src/Battle/Clone/Clone.hpp //////////////////////

#include <optional>

namespace pokesim {
struct CloneTo;

inline types::ClonedEntityMap clone(types::registry& registry, std::optional<types::cloneIndex> cloneCount);
inline void deleteClones(types::registry& registry);
}  // namespace pokesim

////////////////////// END OF src/Battle/Clone/Clone.hpp ///////////////////////

////////////////// START OF src/Battle/ManageBattleState.hpp ///////////////////

namespace pokesim {
class Simulation;
class Pokedex;
struct Sides;
struct CurrentAction;
struct CurrentActionSource;
struct CurrentActionTargets;
struct RootBattle;

inline void assignRootBattle(types::handle battleHandle);
inline void collectTurnOutcomeBattles(types::handle leafBattleHandle, const RootBattle& root);

inline void setCurrentActionSource(types::handle battleHandle, const Sides& sides, const CurrentAction& action);
inline void setCurrentActionTarget(
  types::handle battleHandle, const Sides& sides, const CurrentAction& action, const CurrentActionSource& source);
inline void setCurrentActionMove(
  types::handle battleHandle, const CurrentActionSource& source, const CurrentActionTargets& targets,
  const CurrentAction& action, const Pokedex& pokedex);
inline void clearCurrentAction(Simulation& simulation);
}  // namespace pokesim

/////////////////// END OF src/Battle/ManageBattleState.hpp ////////////////////

///////////////////// START OF src/CalcDamage/Helpers.hpp //////////////////////

#include <type_traits>

namespace pokesim::calc_damage {
inline constexpr bool damageKindsMatch(DamageRollKind kindA, DamageRollKind kindB) {
  using DamageRollKindBase = std::underlying_type_t<DamageRollKind>;
  return ((DamageRollKindBase)kindA & (DamageRollKindBase)kindB) != 0;
}

inline types::damage averageOfDamageRolls(const DamageRolls& damageRolls, DamageRollKind damageRollKind) {
  POKESIM_ASSERT(!damageRolls.val.empty(), "DamageRolls has no rolls yet.");

  if (damageKindsMatch(damageRollKind, DamageRollKind::ALL_DAMAGE_ROLLS)) {
    POKESIM_ASSERT(
      damageRolls.val.size() == MechanicConstants::MAX_DAMAGE_ROLL_COUNT,
      "DamageRolls does not have all rolls yet.");
    return damageRolls.val[MechanicConstants::MAX_DAMAGE_ROLL_COUNT / 2].val;
  }
  POKESIM_ASSERT(
    damageKindsMatch(damageRollKind, DamageRollKind::AVERAGE_DAMAGE),
    "DamageRolls does not contain average");

  if (damageKindsMatch(damageRollKind, DamageRollKind::MAX_DAMAGE)) {
    POKESIM_ASSERT(damageRolls.val.size() > 1, "DamageRolls may not have average roll yet.");
    return damageRolls.val[1].val;
  }
  return damageRolls.val[0].val;
}

template <
  typename... CombinedKinds,
  typename = std::enable_if_t<std::conjunction_v<std::is_same<CombinedKinds, DamageRollKind>...>>>
inline constexpr DamageRollKind combineDamageKinds(CombinedKinds... kinds) {
  using DamageRollKindBase = std::underlying_type_t<DamageRollKind>;
  return static_cast<DamageRollKind>((static_cast<DamageRollKindBase>(kinds) | ...));
}
}  // namespace pokesim::calc_damage

////////////////////// END OF src/CalcDamage/Helpers.hpp ///////////////////////

/////////////////// START OF src/Components/AddedTargets.hpp ///////////////////

namespace pokesim {
struct AddedTargets {
  AddedTargetOptions val = AddedTargetOptions::NONE;
};
}  // namespace pokesim

//////////////////// END OF src/Components/AddedTargets.hpp ////////////////////

///////////////// START OF src/Components/CloneFromCloneTo.hpp /////////////////

namespace pokesim {
namespace tags {
struct CloneFrom {};
struct CloneToRemove {};
}  // namespace tags

struct CloneTo {
  types::cloneIndex val{};
};
}  // namespace pokesim

////////////////// END OF src/Components/CloneFromCloneTo.hpp //////////////////

/////////////// START OF src/Components/Names/SourceSlotName.hpp ///////////////

namespace pokesim {
/**
 * @brief Represents the source slot for a move in a Pokemon battle.
 */
struct SourceSlotName {
  Slot name = Slot::NONE;
};
}  // namespace pokesim

//////////////// END OF src/Components/Names/SourceSlotName.hpp ////////////////

/////////////// START OF src/Components/Names/TargetSlotName.hpp ///////////////

namespace pokesim {
/**
 * @brief Represents the target slot for a move in a Pokemon battle.
 *
 * In a single battle, only P1A and P2A are valid targets. In a double battle, P1B and P2B are also valid.
 */
struct TargetSlotName {
  Slot name = Slot::NONE;
};
}  // namespace pokesim

//////////////// END OF src/Components/Names/TargetSlotName.hpp ////////////////

///////////// START OF src/Components/SimulateTurn/ActionNames.hpp /////////////

namespace pokesim::action {
// Component to make an action one where a Pokemon uses a move. Contains the name of the move being used.
struct Move : MoveName {};
// Component to make an action one where a player uses an item. Contains the name of the item being used.
struct Item : ItemName {};
}  // namespace pokesim::action

////////////// END OF src/Components/SimulateTurn/ActionNames.hpp //////////////

///////////// START OF src/Components/SimulateTurn/ActionTags.hpp //////////////

namespace pokesim::action::tags {
struct BeforeTurn {};
struct Residual {};

struct Current {};

struct Switch {};

// Action Tag for Switching: When a Pokemon is about to be switched out
// Example: Pursuit activating
struct PreSwitchOut {};
// Action Tag for Switching: When a Pokemon is being switched out
struct SwitchOut {};
/**
 * @brief Action Tag for Switching: When a Pokemon is being switched in because a player chose to directly switch the
 * Pokemon in as their turn action
 */
struct PreTurnSwitchIn {};
// Action Tag for Switching: When a Pokemon is being switched in because a team member switches out mid-turn
// Examples: U-Turn, Baton Pash, Emergency Exit
struct MidTurnSwitchIn {};
// Action Tag for Switching: When a Pokemon is being switched in to replace a fainted team member
struct PostFoeFaintSwitchIn {};

// Action Tag: When Revival Blessing is being used on a fainted party member
struct RevivalBlessing {};
// Action Tag: When a mega evolution is activating
struct MegaEvolve {};
// Action Tag: When a primal reversion is activating
struct PrimalRevert {};
// Action Tag: When a Pokemon dynamaxing
struct Dynamax {};
// Action Tag: When a Pokemon is terastallizing
struct Terastallize {};
}  // namespace pokesim::action::tags

////////////// END OF src/Components/SimulateTurn/ActionTags.hpp ///////////////

////////// START OF src/Components/SimulateTurn/SimulateTurnInput.hpp //////////

namespace pokesim::simulate_turn::tags {
struct Input {};
}  // namespace pokesim::simulate_turn::tags

/////////// END OF src/Components/SimulateTurn/SimulateTurnInput.hpp ///////////

//////////////////// START OF src/Components/SpeedSort.hpp /////////////////////

namespace pokesim {
// Data that determines the order actions take place
struct SpeedSort {
  // Order of the types of actions (lower first)
  ActionOrder order = ActionOrder::NONE;
  // Priority of the action (higher first)
  types::priority priority = 0;
  // Whether negative fractional priority is active for the action (false first)
  types::fractionalPriority fractionalPriority = false;
  // Speed of Pokemon using move (higher first if priority tie)
  types::stat speed = 1;

  bool operator==(const SpeedSort& other) const {
    return order == other.order && priority == other.priority && fractionalPriority == other.fractionalPriority &&
           speed == other.speed;
  }
};
}  // namespace pokesim

///////////////////// END OF src/Components/SpeedSort.hpp //////////////////////

///////////////// START OF src/Components/Tags/TargetTags.hpp //////////////////

namespace pokesim::move {
namespace tags {
struct AnySingleTarget {};
struct AnySingleFoe {};
struct AnySingleAlly {};
struct AllyOrSelf {};
struct Self {};
struct AllFoes {};
struct AlliesAndFoes {};
struct AlliesAndSelf {};
struct FoeSide {};
struct AllySide {};
struct Field {};
struct AllyTeam {};
struct Retaliation {};
struct RandomFoe {};
}  // namespace tags

namespace added_targets::tags {
struct TargetAlly {};
struct UserAlly {};
struct TargetSide {};
struct UserSide {};
struct Field {};
}  // namespace added_targets::tags
}  // namespace pokesim::move

////////////////// END OF src/Components/Tags/TargetTags.hpp ///////////////////

/////////////// START OF src/SimulateTurn/ManageActionQueue.hpp ////////////////

// Systems
namespace pokesim {
struct SideDecision;
struct ActionQueue;

namespace simulate_turn {
inline void resolveDecision(types::handle sideHandle, const SideDecision& sideDecision);
inline void speedSort(types::handle handle, ActionQueue& actionQueue);

inline void addBeforeTurnAction(types::registry& registry, ActionQueue& actionQueue);
inline void addResidualAction(types::registry& registry, ActionQueue& actionQueue);
inline void setCurrentAction(types::handle battleHandle, ActionQueue& actionQueue);
}  // namespace simulate_turn
}  // namespace pokesim

//////////////// END OF src/SimulateTurn/ManageActionQueue.hpp /////////////////

////////////////// START OF src/SimulateTurn/SimulateTurn.cpp //////////////////

namespace pokesim::simulate_turn {
inline void run(Simulation& simulation) {
  const auto& options = simulation.simulateTurnOptions;
#ifndef POKESIM_ALL_DAMAGE_ALL_BRANCHES
  POKESIM_ASSERT(
    !options.makeBranchesOnRandomEvents ||
      !(calc_damage::damageKindsMatch(options.damageRollsConsidered.p1, DamageRollKind::ALL_DAMAGE_ROLLS) ||
        calc_damage::damageKindsMatch(options.damageRollsConsidered.p2, DamageRollKind::ALL_DAMAGE_ROLLS)),
    "Creating a branch for every damage roll is disabled by default to prevent easily reaching the battle count limit. "
    "Rebuild PokeSim with the flag POKESIM_ALL_DAMAGE_ALL_BRANCHES to enable this option combination.");
#endif

  if (!options.applyChangesToInputBattle) {
    simulation.addToEntities<pokesim::tags::CloneFrom, pokesim::tags::Battle, pokesim::tags::SimulateTurn>();
    const auto entityMap = clone(simulation.registry, 1);
    for (const auto& inputBattleMapping : entityMap) {
      simulation.registry.emplace<tags::Input>(inputBattleMapping.first);
    }
  }

  pokesim::internal::SelectForBattleView<pokesim::tags::SimulateTurn> selectedBattles{
    simulation,
    entt::exclude<tags::Input>};
  pokesim::internal::SelectForSideView<pokesim::tags::SimulateTurn> selectedSides{
    simulation,
    entt::exclude<tags::Input>};
  if (selectedBattles.hasNoneSelected() || selectedSides.hasNoneSelected()) return;

  simulation.viewForSelectedBattles<assignRootBattle>();

  updateAllStats(simulation);
  simulation.viewForSelectedSides<resolveDecision>();
  simulation.removeFromEntities<SideDecision, pokesim::tags::SelectedForViewSide>();

  // simulation.viewForSelectedBattles<addBeforeTurnAction, Tags<>, entt::exclude_t<pokesim::tags::BattleMidTurn>>();
  simulation.viewForSelectedBattles<speedSort>();
  simulation.viewForSelectedBattles<addResidualAction, Tags<>, entt::exclude_t<pokesim::tags::BattleMidTurn>>();

  simulation.addToEntities<pokesim::tags::BattleMidTurn, Turn, pokesim::tags::SelectedForViewBattle>();

  simulation.viewForSelectedBattles<setCurrentAction>();
  while (!simulation.registry.view<action::tags::Current>().empty()) {
    runCurrentAction(simulation);
    simulation.viewForSelectedBattles<setCurrentAction>();
  }

  nextTurn(simulation);

  simulation.removeFromEntities<pokesim::tags::BattleMidTurn, Turn, pokesim::tags::SelectedForViewBattle>();
  simulation.viewForSelectedBattles<collectTurnOutcomeBattles>();
  simulation.registry.clear<tags::Input>();
}

inline void runCurrentAction(Simulation& simulation) {
  // runBeforeTurnAction(simulation);
  runMoveAction(simulation);
  runResidualAction(simulation);

  clearCurrentAction(simulation);
  // faint pokemon
  // Update
  // Switch requests

  if (!simulation.registry.view<pokesim::tags::SpeStatUpdateRequired>().empty()) {
    updateSpe(simulation);
    simulation.viewForSelectedBattles<speedSort>();  // Should only speed sort battles affected
  }
  updateAllStats(simulation);
}

inline void runBeforeTurnAction(Simulation& /*simulation*/) {
  // Barely used, will find different way of handling it
}

inline void runMoveAction(Simulation& simulation) {
  pokesim::internal::SelectForBattleView<action::Move> selectedBattle{simulation};
  if (selectedBattle.hasNoneSelected()) return;

  simulation.viewForSelectedBattles<setCurrentActionSource>();
  simulation.viewForSelectedBattles<setCurrentActionTarget>();
  simulation.viewForSelectedBattles<setCurrentActionMove>(simulation.pokedex);

  simulation.view<deductPp, Tags<pokesim::tags::CurrentActionMoveSlot>>();
  simulation.view<setLastMoveUsed>();

  useMove(simulation);
}

inline void runResidualAction(Simulation& simulation) {
  pokesim::internal::SelectForBattleView<action::tags::Residual> selectedBattle{simulation};
  if (selectedBattle.hasNoneSelected()) return;
}

namespace internal {
inline void incrementTurn(Turn& turn) {
  turn.val++;
}

inline void updateActivePokemonPostTurn(types::handle pokemonHandle, const pokesim::MoveSlots& moveSlots) {
  pokemonHandle.registry()->remove<pokesim::move::tags::Disabled>(moveSlots.val.begin(), moveSlots.val.end());
}
}  // namespace internal

inline void nextTurn(Simulation& simulation) {
  simulation.viewForSelectedBattles<internal::incrementTurn>();

  pokesim::internal::SelectForPokemonView<pokesim::tags::SimulateTurn, pokesim::tags::ActivePokemon> selectedPokemon{
    simulation};
  if (!selectedPokemon.hasNoneSelected()) {
    simulation.viewForSelectedPokemon<internal::updateActivePokemonPostTurn>();
    runDisableMove(simulation);
  }
}

inline void addTargetAllyToTargets(types::registry& registry, const Battle& battle) {
  const Sides& sides = registry.get<Sides>(battle.val);
  const TargetSlotName& targetSlotName = registry.get<TargetSlotName>(registry.get<CurrentAction>(battle.val).val);

  types::entity allyEntity = slotToAllyPokemonEntity(registry, sides, targetSlotName.name);
  if (allyEntity == entt::null) {
    return;
  }

  CurrentActionTargets& targets = registry.get<CurrentActionTargets>(battle.val);
  targets.val.push_back(allyEntity);
}

inline void addUserAllyToTargets(types::registry& registry, const Battle& battle) {
  const Sides& sides = registry.get<Sides>(battle.val);
  const SourceSlotName& sourceSlotName = registry.get<SourceSlotName>(registry.get<CurrentAction>(battle.val).val);

  types::entity allyEntity = slotToAllyPokemonEntity(registry, sides, sourceSlotName.name);
  if (allyEntity == entt::null) {
    return;
  }

  CurrentActionTargets& targets = registry.get<CurrentActionTargets>(battle.val);
  targets.val.push_back(allyEntity);
}

inline void resolveMoveTargets(CurrentActionTargets&) {}

inline void createActionMoveForTargets(
  types::handle targetHandle, const Battle& battle, const CurrentActionSource& source, const Pokedex& pokedex) {
  types::registry& registry = *targetHandle.registry();

  dex::Move move = registry.get<action::Move>(registry.get<CurrentAction>(battle.val).val).name;
  types::entity moveEntity = createActionMoveForTarget(targetHandle, battle.val, source.val, move, pokedex);

  registry.emplace<pokesim::tags::SimulateTurn>(moveEntity);
}

inline void getMoveTargets(Simulation& simulation) {
  if (simulation.battleFormat == BattleFormat::DOUBLES_BATTLE_FORMAT) {
    simulation
      .view<addTargetAllyToTargets, Tags<pokesim::tags::CurrentActionMove, move::added_targets::tags::TargetAlly>>();
    simulation
      .view<addUserAllyToTargets, Tags<pokesim::tags::CurrentActionMove, move::added_targets::tags::UserAlly>>();
  }
  simulation.view<resolveMoveTargets, Tags<pokesim::tags::CurrentActionMove>, entt::exclude_t<AddedTargets>>();
  simulation.view<
    createActionMoveForTargets,
    Tags<pokesim::tags::CurrentActionMoveTarget>,
    entt::exclude_t<CurrentActionMoves>>(simulation.pokedex);
}

inline void useMove(Simulation& simulation) {
  // ModifyTarget
  // ModifyType
  runModifyMove(simulation);

  getMoveTargets(simulation);
  runMoveHitChecks(simulation);
}
}  // namespace pokesim::simulate_turn

/////////////////// END OF src/SimulateTurn/SimulateTurn.cpp ///////////////////

////////////// START OF src/Components/CalcDamage/CriticalHit.hpp //////////////

#include <array>

namespace pokesim::calc_damage {
struct CritChanceDivisor {
  types::percentChance val = pokesim::MechanicConstants::CRIT_CHANCE_DIVISORS[0];
};

struct CritBoost {
  types::boost val = 0U;
};

namespace tags {
struct Crit {};
}  // namespace tags
}  // namespace pokesim::calc_damage

/////////////// END OF src/Components/CalcDamage/CriticalHit.hpp ///////////////

//////////////////////// START OF src/Utilities/RNG.hpp ////////////////////////

// Adapted from https://github.com/imneme/pcg-c-basic/blob/master/pcg_basic.c
namespace pokesim::internal {

// Generate a uniformly distributed 32-bit random number
inline constexpr types::rngResult nextRandomValue(types::rngState& state) {
  // NOLINTBEGIN
  types::rngState oldState = state;
  state = oldState * 6364136223846793005ULL;
  types::rngResult xorShifted = (types::rngResult)(((oldState >> 18U) ^ oldState) >> 27U);
  types::rngResult rot = oldState >> 59U;
  return (xorShifted >> rot) | (xorShifted << ((-1 * rot) & 31));
  // NOLINTEND
}

// Generate a uniformly distributed 32-bit random number
inline types::rngResult nextRandomValue(RngSeed& seed) {
  return nextRandomValue(seed.val);
}

// Generate a uniformly distributed number, r, where 0 <= r < bound
inline types::rngResult nextBoundedRandomValue(types::rngState& state, types::rngResult upperBound) {
  // To avoid bias, we need to make the range of the RNG a multiple of
  // bound, which we do by dropping output less than a threshold.
  // A naive scheme to calculate the threshold would be to do
  //
  //     uint32_t threshold = 0x100000000ull % bound;
  //
  // but 64-bit div/mod is slower than 32-bit div/mod (especially on
  // 32-bit platforms).  In essence, we do
  //
  //     uint32_t threshold = (0x100000000ull-bound) % bound;
  //
  // because this version will calculate the same modulus, but the LHS
  // value is less than 2^32.

  types::rngResult threshold = (-1 * upperBound) % upperBound;

  // Uniformity guarantees that this loop will terminate.  In practice, it
  // should usually terminate quickly; on average (assuming all bounds are
  // equally likely), 82.25% of the time, we can expect it to require just
  // one iteration.  In the worst case, someone passes a bound of 2^31 + 1
  // (i.e., 2147483649), which invalidates almost 50% of the range.  In
  // practice, bounds are typically small and only a tiny amount of the range
  // is eliminated.
  for (;;) {
    types::rngResult value = nextRandomValue(state);
    if (value >= threshold) return value % upperBound;
  }
}

// Generate a uniformly distributed number, r, where 0 <= r < bound
inline types::rngResult nextBoundedRandomValue(RngSeed& seed, types::rngResult upperBound) {
  return nextBoundedRandomValue(seed.val, upperBound);
}
}  // namespace pokesim::internal

///////////////////////// END OF src/Utilities/RNG.hpp /////////////////////////

////////////////// START OF src/SimulateTurn/RandomChance.cpp //////////////////

#include <cstdint>
#include <optional>
#include <type_traits>

namespace pokesim {
namespace internal {
template <typename Type>
void updateProbability(Probability& currentProbability, Type percentChance) {
  currentProbability.val *= (types::probability)percentChance / 100.0F;
}

template <types::eventPossibilities POSSIBLE_EVENT_COUNT, typename RandomEventTag>
void updateProbabilityFromRandomEventChance(
  types::registry& registry, const RandomEventChances<POSSIBLE_EVENT_COUNT>& eventChances, const Battle& battle) {
  Probability& probability = registry.get<Probability>(battle.val);

  if constexpr (std::is_same_v<RandomEventTag, tags::RandomEventA>) {
    updateProbability(probability, eventChances.chanceA());
  }
  else if constexpr (std::is_same_v<RandomEventTag, tags::RandomEventB>) {
    updateProbability(probability, eventChances.chanceB());
  }
  else if constexpr (std::is_same_v<RandomEventTag, tags::RandomEventC>) {
    updateProbability(probability, eventChances.chanceC());
  }
  else if constexpr (std::is_same_v<RandomEventTag, tags::RandomEventD>) {
    updateProbability(probability, eventChances.chanceD());
  }
  else if constexpr (std::is_same_v<RandomEventTag, tags::RandomEventE>) {
    updateProbability(probability, eventChances.chanceE());
  }
}

template <types::eventPossibilities POSSIBLE_EVENT_COUNT, typename RandomEventTag>
void viewUpdateProbabilityFromRandomEventChance(Simulation& simulation) {
  simulation.view<updateProbabilityFromRandomEventChance<POSSIBLE_EVENT_COUNT, RandomEventTag>, Tags<RandomEventTag>>();
}

template <bool Reciprocal, typename RandomEventTag>
void updateProbabilityFromRandomBinaryChance(
  types::registry& registry, const RandomBinaryChance& eventChance, const Battle& battle) {
  Probability& probability = registry.get<Probability>(battle.val);

  if constexpr (std::is_same_v<RandomEventTag, tags::RandomEventCheckPassed>) {
    if constexpr (Reciprocal) {
      updateProbability(probability, eventChance.reciprocalPass());
    }
    else {
      updateProbability(probability, eventChance.pass());
    }
  }
  else if constexpr (std::is_same_v<RandomEventTag, tags::RandomEventCheckFailed>) {
    if constexpr (Reciprocal) {
      updateProbability(probability, eventChance.reciprocalFail());
    }
    else {
      updateProbability(probability, eventChance.fail());
    }
  }
}

inline void updateProbabilityFromRandomEqualChance(
  types::registry& registry, const Battle& battle, const RandomEventIndex&,
  types::eventPossibilities possibleEventCount) {
  Probability& probability = registry.get<Probability>(battle.val);

  updateProbability(probability, 100.0F / (float)possibleEventCount);
}

inline void updateProbabilityFromRandomEventCount(
  types::registry& registry, const RandomEventCount& eventChance, const Battle& battle) {
  Probability& probability = registry.get<Probability>(battle.val);

  updateProbability(probability, 100.0F / (float)eventChance.val);
}

template <types::eventPossibilities POSSIBLE_EVENT_COUNT>
void assignRandomEvent(
  types::handle handle, const Battle& battle, const RandomEventChances<POSSIBLE_EVENT_COUNT>& eventChances) {
  RngSeed& rngSeed = handle.registry()->get<RngSeed>(battle.val);
  types::percentChance rng = (types::percentChance)nextBoundedRandomValue(rngSeed, 100);

  if (rng <= eventChances.val[0]) {
    handle.emplace<tags::RandomEventA>();
    return;
  }
  if (rng <= eventChances.val[1]) {
    handle.emplace<tags::RandomEventB>();
    return;
  }

  if constexpr (POSSIBLE_EVENT_COUNT >= 3U) {
    if (rng <= eventChances.val[2]) {
      handle.emplace<tags::RandomEventC>();
      return;
    }
  }

  if constexpr (POSSIBLE_EVENT_COUNT >= 4U) {
    if (rng <= eventChances.val[3]) {
      handle.emplace<tags::RandomEventD>();
      return;
    }
  }

  if constexpr (POSSIBLE_EVENT_COUNT == 5U) {
    if (rng <= eventChances.val[4]) {
      handle.emplace<tags::RandomEventE>();
    }
  }
}

inline void assignRandomBinaryEvent(types::handle handle, const Battle& battle, const RandomBinaryChance& eventChance) {
  RngSeed& rngSeed = handle.registry()->get<RngSeed>(battle.val);
  types::percentChance rng = (types::percentChance)nextBoundedRandomValue(rngSeed, 100);

  if (rng <= eventChance.pass()) {
    handle.emplace<tags::RandomEventCheckPassed>();
  }
  else {
    handle.emplace<tags::RandomEventCheckFailed>();
  }
}

inline void assignReciprocalRandomBinaryEvent(
  types::handle handle, const Battle& battle, const RandomBinaryChance& eventChance) {
  RngSeed& rngSeed = handle.registry()->get<RngSeed>(battle.val);
  types::percentChance rng = (types::percentChance)nextBoundedRandomValue(rngSeed, eventChance.val);

  if (rng == 0) {
    handle.emplace<tags::RandomEventCheckPassed>();
  }
  else {
    handle.emplace<tags::RandomEventCheckFailed>();
  }
}

inline void assignRandomEqualChance(types::handle handle, const Battle& battle, types::eventPossibilities possibleEventCount) {
  RngSeed& rngSeed = handle.registry()->get<RngSeed>(battle.val);
  types::eventPossibilities rng = (types::eventPossibilities)nextBoundedRandomValue(rngSeed, possibleEventCount);

  handle.emplace<RandomEventIndex>(rng);
}

inline void assignRandomEventCount(types::handle handle, const Battle& battle, const RandomEventCount& eventCount) {
  RngSeed& rngSeed = handle.registry()->get<RngSeed>(battle.val);
  types::eventPossibilities rng = (types::eventPossibilities)nextBoundedRandomValue(rngSeed, eventCount.val);

  handle.emplace<RandomEventIndex>(rng);
}

inline void assignIndexToClones(
  types::registry& registry, const types::ClonedEntityMap& clonedEntityMap,
  const std::vector<types::entity>& originals) {
  for (types::entity original : originals) {
    registry.emplace<RandomEventIndex>(original, (types::eventPossibilities)0U);

    const auto clonedPointer = clonedEntityMap.find(original);
    if (clonedPointer == clonedEntityMap.end()) continue;
    const auto& cloned = clonedPointer->second;

    for (std::size_t index = 0; index < cloned.size(); index++) {
      POKESIM_ASSERT(
        std::numeric_limits<types::eventPossibilities>::max() > index,
        "Number of clones shouldn't be greater than the number of possible events.");
      registry.emplace<RandomEventIndex>(cloned[index], (types::eventPossibilities)(index + 1U));
    }
  }
}

template <typename Stack, typename Random>
void placeChanceFromStack(types::handle battleHandle, Stack& stack) {
  if constexpr (!std::is_empty_v<Random>) {
    auto [eventChances, entity] = stack.val.back();
    battleHandle.registry()->emplace<Random>(entity, eventChances);
  }
  else {
    auto entity = stack.val.back();
    battleHandle.registry()->emplace<Random>(entity);
  }

  stack.val.pop_back();
  if (stack.val.empty()) {
    battleHandle.remove<Stack>();
  }
}

template <
  typename Random, typename RandomStack, auto AssignRandomEvents, typename UpdateProbabilities,
  typename... AssignRandomEventsTags, typename... AssignArgs>
void randomChanceEvent(
  Simulation& simulation, types::cloneIndex cloneCount, types::callback applyChoices,
  void (*assignClonesToEvents)(types::registry&, const types::ClonedEntityMap&, const std::vector<types::entity>&),
  UpdateProbabilities updateProbabilities, const AssignArgs&... assignArgs) {
  if (simulation.battleFormat == BattleFormat::DOUBLES_BATTLE_FORMAT) {
    simulation.view<placeChanceFromStack<RandomStack, Random>>();
  }

  types::registry& registry = simulation.registry;
  if (simulation.simulateTurnOptions.makeBranchesOnRandomEvents) {
    auto chanceEntityView = registry.view<Random>();
    if (chanceEntityView.empty()) {
      applyChoices(simulation);
      clearRandomChanceResult(simulation);
      return;
    }

    if constexpr (std::is_same_v<RandomEventCount, Random>) {
      entt::dense_map<types::eventPossibilities, std::pair<std::vector<types::entity>, std::vector<types::entity>>>
        entitiesByEventCount{};

      auto collectEntityEventCounts =
        [&entitiesByEventCount](types::entity chanceEntity, const Battle& battle, const RandomEventCount& eventCount) {
          entitiesByEventCount[eventCount.val].first.push_back(chanceEntity);
          entitiesByEventCount[eventCount.val].second.push_back(battle.val);
        };

      registry.view<Battle, RandomEventCount>().each(collectEntityEventCounts);

      for (const auto& [eventCount, entities] : entitiesByEventCount) {
        const auto [chanceEntities, battleEntities] = entities;
        if (eventCount == 1U) {
          assignClonesToEvents(registry, {}, chanceEntities);
          continue;
        }

        registry.insert<tags::CloneFrom>(battleEntities.begin(), battleEntities.end());
        auto clonedEntityMap = clone(registry, eventCount - 1U);

        assignClonesToEvents(registry, clonedEntityMap, chanceEntities);
      }
    }
    else {
      auto assignCloneTags = [&registry](const Battle& battle, auto&&...) {
        registry.emplace<tags::CloneFrom>(battle.val);
      };
      registry.view<Battle, Random>().each(assignCloneTags);

      std::vector<types::entity> chanceEntities{chanceEntityView.begin(), chanceEntityView.end()};
      auto clonedEntityMap = clone(registry, cloneCount);

      assignClonesToEvents(registry, clonedEntityMap, chanceEntities);
    }

    applyChoices(simulation);
    updateProbabilities(simulation);
  }
  else {
    simulation.view<AssignRandomEvents, Tags<AssignRandomEventsTags...>>(assignArgs...);
    applyChoices(simulation);
    updateProbabilities(simulation);
  }

  registry.clear<Random>();
  clearRandomChanceResult(simulation);
  if (simulation.battleFormat == BattleFormat::DOUBLES_BATTLE_FORMAT && !registry.view<RandomStack>().empty()) {
    randomChanceEvent<Random, RandomStack, AssignRandomEvents, UpdateProbabilities, AssignRandomEventsTags...>(
      simulation,
      cloneCount,
      applyChoices,
      assignClonesToEvents,
      updateProbabilities,
      assignArgs...);
  }
}

template <bool Reciprocal>
void randomBinaryChance(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities) {
  auto assignClonesToEvents = [](
                                types::registry& registry,
                                const types::ClonedEntityMap& clonedEntityMap,
                                const std::vector<types::entity>& originals) {
    for (types::entity original : originals) {
      const auto& cloned = clonedEntityMap.at(original);
      registry.emplace<tags::RandomEventCheckPassed>(original);
      registry.emplace<tags::RandomEventCheckFailed>(cloned[0]);
    }
  };

  auto defaultUpdateProbabilities = [](Simulation& sim) {
    sim.view<
      updateProbabilityFromRandomBinaryChance<Reciprocal, tags::RandomEventCheckPassed>,
      Tags<tags::RandomEventCheckPassed>>();
    sim.view<
      updateProbabilityFromRandomBinaryChance<Reciprocal, tags::RandomEventCheckFailed>,
      Tags<tags::RandomEventCheckFailed>>();
  };

  if constexpr (Reciprocal) {
    return randomChanceEvent<
      RandomBinaryChance,
      RandomBinaryChanceStack,
      assignReciprocalRandomBinaryEvent,
      types::callback>(
      simulation,
      1U,
      applyChoices,
      assignClonesToEvents,
      updateProbabilities.value_or(defaultUpdateProbabilities));
  }
  else {
    return randomChanceEvent<RandomBinaryChance, RandomBinaryChanceStack, assignRandomBinaryEvent, types::callback>(
      simulation,
      1U,
      applyChoices,
      assignClonesToEvents,
      updateProbabilities.value_or(defaultUpdateProbabilities));
  }
}
}  // namespace internal

template <types::eventPossibilities POSSIBLE_EVENT_COUNT>
void randomEventChances(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities) {
  static_assert(
    POSSIBLE_EVENT_COUNT >= 2U,
    "RandomEventChances should only be used for events with more than two options.");
  static_assert(
    POSSIBLE_EVENT_COUNT <= internal::MAX_TYPICAL_RANDOM_OPTIONS,
    "Random events with more options than this should use RandomEqualChance or RandomEventCount");

  auto assignClonesToEvents = [](
                                types::registry& registry,
                                const types::ClonedEntityMap& clonedEntityMap,
                                const std::vector<types::entity>& originals) {
    for (types::entity original : originals) {
      const auto& cloned = clonedEntityMap.at(original);
      registry.emplace<tags::RandomEventA>(original);
      registry.emplace<tags::RandomEventB>(cloned[0]);
      if constexpr (POSSIBLE_EVENT_COUNT >= 3U) {
        registry.emplace<tags::RandomEventC>(cloned[1]);
      }
      if constexpr (POSSIBLE_EVENT_COUNT >= 4U) {
        registry.emplace<tags::RandomEventD>(cloned[2]);
      }
      if constexpr (POSSIBLE_EVENT_COUNT == 5U) {
        registry.emplace<tags::RandomEventE>(cloned[3]);
      }
    }
  };

  auto defaultUpdateProbabilities = [](Simulation& sim) {
    internal::viewUpdateProbabilityFromRandomEventChance<POSSIBLE_EVENT_COUNT, tags::RandomEventA>(sim);
    internal::viewUpdateProbabilityFromRandomEventChance<POSSIBLE_EVENT_COUNT, tags::RandomEventB>(sim);

    if constexpr (POSSIBLE_EVENT_COUNT >= 3U) {
      internal::viewUpdateProbabilityFromRandomEventChance<POSSIBLE_EVENT_COUNT, tags::RandomEventC>(sim);
    }
    if constexpr (POSSIBLE_EVENT_COUNT >= 4U) {
      internal::viewUpdateProbabilityFromRandomEventChance<POSSIBLE_EVENT_COUNT, tags::RandomEventD>(sim);
    }
    if constexpr (POSSIBLE_EVENT_COUNT == 5U) {
      internal::viewUpdateProbabilityFromRandomEventChance<POSSIBLE_EVENT_COUNT, tags::RandomEventE>(sim);
    }
  };

  return internal::randomChanceEvent<
    RandomEventChances<POSSIBLE_EVENT_COUNT>,
    RandomEventChancesStack<POSSIBLE_EVENT_COUNT>,
    internal::assignRandomEvent<POSSIBLE_EVENT_COUNT>,
    types::callback>(
    simulation,
    POSSIBLE_EVENT_COUNT - 1U,
    applyChoices,
    assignClonesToEvents,
    updateProbabilities.value_or(defaultUpdateProbabilities));
}

inline void randomEqualChance(
  Simulation& simulation, const types::eventPossibilities possibleEventCount, types::callback applyChoices,
  types::optionalCallback updateProbabilities) {
  auto defaultUpdateProbabilities = [possibleEventCount](Simulation& sim) {
    sim.view<internal::updateProbabilityFromRandomEqualChance>(possibleEventCount);
  };

  types::cloneIndex cloneCount =
    possibleEventCount > MechanicConstants::MAX_DAMAGE_ROLL_COUNT ? 0 : possibleEventCount - 1;

  if (updateProbabilities.has_value()) {
    return internal::randomChanceEvent<
      tags::RandomEqualChance,
      RandomEqualChanceStack,
      internal::assignRandomEqualChance,
      types::callback,
      tags::RandomEqualChance>(
      simulation,
      cloneCount,
      applyChoices,
      internal::assignIndexToClones,
      updateProbabilities.value(),
      possibleEventCount);
  }

  return internal::randomChanceEvent<
    tags::RandomEqualChance,
    RandomEqualChanceStack,
    internal::assignRandomEqualChance,
    decltype(defaultUpdateProbabilities),
    tags::RandomEqualChance>(
    simulation,
    cloneCount,
    applyChoices,
    internal::assignIndexToClones,
    defaultUpdateProbabilities,
    possibleEventCount);
}

inline void randomEventCount(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities) {
  auto defaultUpdateProbabilities = [](Simulation& sim) {
    sim.view<internal::updateProbabilityFromRandomEventCount>();
  };

  return internal::
    randomChanceEvent<RandomEventCount, RandomEventCountStack, internal::assignRandomEventCount, types::callback>(
      simulation,
      0U,
      applyChoices,
      internal::assignIndexToClones,
      updateProbabilities.value_or(defaultUpdateProbabilities));
}

inline void randomBinaryChance(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities) {
  internal::randomBinaryChance<false>(simulation, applyChoices, updateProbabilities);
}

inline void reciprocalRandomBinaryChance(
  Simulation& simulation, types::callback applyChoices, types::optionalCallback updateProbabilities) {
  internal::randomBinaryChance<true>(simulation, applyChoices, updateProbabilities);
}

inline void clearRandomChanceResult(Simulation& simulation) {
  simulation.registry.clear<tags::RandomEventA>();
  simulation.registry.clear<tags::RandomEventB>();
  simulation.registry.clear<tags::RandomEventC>();
  simulation.registry.clear<tags::RandomEventD>();
  simulation.registry.clear<tags::RandomEventE>();
  simulation.registry.clear<RandomEventIndex>();
}

template void randomEventChances<2U>(Simulation&, types::callback, types::optionalCallback);
template void randomEventChances<3U>(Simulation&, types::callback, types::optionalCallback);
template void randomEventChances<4U>(Simulation&, types::callback, types::optionalCallback);
template void randomEventChances<5U>(Simulation&, types::callback, types::optionalCallback);
}  // namespace pokesim

/////////////////// END OF src/SimulateTurn/RandomChance.cpp ///////////////////

/////////// START OF src/Components/SimulateTurn/SpeedTieIndexes.hpp ///////////

#include <cstdint>
#include <vector>

namespace pokesim {
struct SpeedTieIndexes {
  struct Span {
    std::size_t start = 0;
    std::size_t length = 0;
  };

  std::vector<Span> val{};
};
}  // namespace pokesim

//////////// END OF src/Components/SimulateTurn/SpeedTieIndexes.hpp ////////////

///////////// START OF src/Components/SimulateTurn/TeamAction.hpp //////////////

namespace pokesim::action {
// Action Tag: When team member order has been picked as part of team preview
struct Team {
  types::teamOrder val{};
};
}  // namespace pokesim::action

////////////// END OF src/Components/SimulateTurn/TeamAction.hpp ///////////////

/////////////// START OF src/SimulateTurn/ManageActionQueue.cpp ////////////////

#include <algorithm>
#include <vector>

namespace pokesim::simulate_turn {
inline void resolveDecision(types::handle sideHandle, const SideDecision& sideDecision) {
  POKESIM_ASSERT(sideDecision.sideId != PlayerSideId::NONE, "Decisions must be assigned to a player.");
  POKESIM_ASSERT(!sideDecision.decisions.valueless_by_exception(), "Decisions must be non-empty.");
  types::registry& registry = *sideHandle.registry();

  ActionQueue& battleActionQueue = registry.get<ActionQueue>(sideHandle.get<Battle>().val);

  if (sideDecision.decisions.holds<types::slotDecisions>()) {
    const auto& decisions = sideDecision.decisions.get<types::slotDecisions>();

    for (const SlotDecision& decision : decisions) {
      POKESIM_ASSERT(decision.sourceSlot != Slot::NONE, "Source slot must be assigned.");
      if (sideDecision.sideId == PlayerSideId::P1) {
        POKESIM_ASSERT(
          (decision.sourceSlot == Slot::P1A || decision.sourceSlot == Slot::P1B),
          "Source must be from a player 1 in battle slot.");
      }
      else {
        POKESIM_ASSERT(
          (decision.sourceSlot == Slot::P2A || decision.sourceSlot == Slot::P2B),
          "Source must be from a player 2 in battle slot.");
      }

      POKESIM_ASSERT(decision.targetSlot != Slot::NONE, "Target slot must be assigned.");
      POKESIM_ASSERT(
        !(decision.moveChoice.has_value() && decision.itemChoice.has_value()),
        "Decisions can't have a move and an item choice.");

      types::handle actionHandle = {registry, registry.create()};
      actionHandle.emplace<SourceSlotName>(decision.sourceSlot);
      actionHandle.emplace<TargetSlotName>(decision.targetSlot);

      SpeedSort speedSort;
      types::entity sourceEntity = slotToPokemonEntity(registry, sideHandle.entity(), decision.sourceSlot);

      stat::EffectiveSpe* effectiveSpe = registry.try_get<stat::EffectiveSpe>(sourceEntity);
      if (effectiveSpe != nullptr) {
        speedSort.speed = effectiveSpe->val;
      }
      else {
        speedSort.speed = registry.get<stat::Spe>(sourceEntity).val;
      }

      if (decision.moveChoice.has_value()) {
        actionHandle.emplace<action::Move>(decision.moveChoice.value());

        speedSort.order = ActionOrder::MOVE;
        speedSort.priority = 0;                // TODO (aed3): Move priority + modify priority
        speedSort.fractionalPriority = false;  // TODO (aed3): get fractionalPriority
      }
      else if (decision.itemChoice.has_value()) {
        actionHandle.emplace<action::Item>(decision.itemChoice.value());
        speedSort.order = ActionOrder::ITEM;
      }
      else {
        actionHandle.emplace<action::tags::Switch>();
        speedSort.order = ActionOrder::SWITCH;
      }

      actionHandle.emplace<SpeedSort>(speedSort);

      battleActionQueue.val.push_back(actionHandle.entity());
    }
  }
  else if (sideDecision.decisions.holds<types::teamOrder>()) {
    const auto& teamOrder = sideDecision.decisions.get<types::teamOrder>();

    POKESIM_ASSERT(
      sideHandle.get<Team>().val.size() == teamOrder.size(),
      "Must pick a placement for each Pokemon on the team.");
    types::handle actionHandle = {registry, registry.create()};

    actionHandle.emplace<action::Team>(teamOrder);

    battleActionQueue.val.push_back(actionHandle.entity());
  }
}

inline void speedSort(types::handle handle, ActionQueue& actionQueue) {
  std::vector<types::entity>& entityList = actionQueue.val;

  if (entityList.size() == 1) return;
  const types::registry* registry = handle.registry();

  std::vector<std::pair<SpeedSort, types::entity>> speedSortList;
  speedSortList.reserve(entityList.size());

  for (types::entity entity : entityList) {
    speedSortList.push_back({registry->get<SpeedSort>(entity), entity});
  }

  // TODO (aed3): Test how different sorting algorithms effect speed
  std::sort(speedSortList.begin(), speedSortList.end(), [](const auto& pairA, const auto& pairB) {
    if (pairA.first.order != pairB.first.order) {
      return pairA.first.order < pairB.first.order;
    }

    if (pairA.first.priority != pairB.first.priority) {
      return pairB.first.priority < pairA.first.priority;
    }

    if (pairA.first.fractionalPriority != pairB.first.fractionalPriority) {
      return pairB.first.fractionalPriority;
    }

    if (pairA.first.speed != pairB.first.speed) {
      return pairB.first.speed < pairA.first.speed;
    }

    return false;
  });

  SpeedTieIndexes speedTies;
  std::size_t lastEqual = 0, tieCount = 1;

  auto speedSortEqual = [](const SpeedSort& speedSortA, const SpeedSort& speedSortB) {
    return speedSortA.order == speedSortB.order && speedSortA.priority == speedSortB.priority &&
           speedSortA.speed == speedSortB.speed && speedSortA.fractionalPriority == speedSortB.fractionalPriority;
  };

  for (std::size_t i = 0; i < speedSortList.size(); i++) {
    entityList[i] = speedSortList[i].second;

    if (i > 0 && speedSortEqual(speedSortList[i].first, speedSortList[i - 1].first)) {
      tieCount++;
    }
    else {
      if (tieCount > 1) {
        speedTies.val.push_back({lastEqual, tieCount});
      }
      lastEqual = i;
      tieCount = 1;
    }
  }

  if (tieCount > 1) {
    speedTies.val.push_back({lastEqual, tieCount});
  }

  if (!speedTies.val.empty()) {
    handle.emplace<SpeedTieIndexes>(speedTies);
  }
}

inline void addBeforeTurnAction(types::registry& registry, ActionQueue& actionQueue) {
  types::handle actionHandle{registry, registry.create()};
  SpeedSort speedSort{ActionOrder::BEFORE_TURN};

  actionHandle.emplace<action::tags::BeforeTurn>();
  actionHandle.emplace<SpeedSort>(speedSort);
  actionQueue.val.push_back(actionHandle.entity());
}

inline void addResidualAction(types::registry& registry, ActionQueue& actionQueue) {
  types::handle actionHandle{registry, registry.create()};
  SpeedSort speedSort{ActionOrder::RESIDUAL};

  actionHandle.emplace<action::tags::Residual>();
  actionHandle.emplace<SpeedSort>(speedSort);
  actionQueue.val.push_back(actionHandle.entity());
}

inline void setCurrentAction(types::handle battleHandle, ActionQueue& actionQueue) {
  types::registry& registry = *battleHandle.registry();

  if (actionQueue.val.empty()) return;

  types::entity newCurrentAction = actionQueue.val.front();
  registry.emplace<action::tags::Current>(newCurrentAction);

  action::Move* moveAction = registry.try_get<action::Move>(newCurrentAction);
  if (moveAction) {
    battleHandle.emplace<action::Move>(*moveAction);
  }
  else if (registry.all_of<action::tags::Residual>(newCurrentAction)) {
    battleHandle.emplace<action::tags::Residual>();
  }

  actionQueue.val.erase(actionQueue.val.begin());

  registry.clear<NextAction>();
  battleHandle.emplace<CurrentAction>(newCurrentAction);
  if (!actionQueue.val.empty()) {
    battleHandle.emplace<NextAction>(actionQueue.val[0]);
  }
}
}  // namespace pokesim::simulate_turn

//////////////// END OF src/SimulateTurn/ManageActionQueue.cpp /////////////////

////////////// START OF src/SimulateTurn/CalcDamageSpecifics.hpp ///////////////

namespace pokesim {
class Simulation;
namespace simulate_turn {
inline void cloneFromDamageRolls(Simulation& simulation, DamageRollKind damageRollKind);
inline void setIfMoveCrits(Simulation& simulation);
}  // namespace simulate_turn
}  // namespace pokesim

/////////////// END OF src/SimulateTurn/CalcDamageSpecifics.hpp ////////////////

////////////// START OF src/SimulateTurn/CalcDamageSpecifics.cpp ///////////////

namespace pokesim::simulate_turn {
namespace internal {
inline void applyDamageRollIndex(Damage& damage, const DamageRolls& damageRolls, const RandomEventIndex& randomRollIndex) {
  types::eventPossibilities damageRollIndex = 0U;
  for (std::size_t i = 0U; i < damageRolls.val.size(); i++) {
    if (randomRollIndex.val == damageRollIndex) {
      damage = damageRolls.val[damageRollIndex];
      return;
    }

    damageRollIndex += i == 0 || damageRolls.val[i - 1].val != damageRolls.val[i].val ? 1 : 0;
  }

  POKESIM_ASSERT_FAIL("How was a damage roll not found that matched the event index?");
}

inline void assignPartialProbability(
  types::registry& registry, const Battle& battle, const RandomEventCount& randomEventCount) {
  if (randomEventCount.val != 1U) {
    Probability& probability = registry.get<Probability>(battle.val);
    probability.val *= 1.0F / (types::probability)randomEventCount.val;
  }
}

inline void assignAllDamageRollProbability(
  types::registry& registry, const Damage& damage, DamageRolls& damageRolls, const Battle& battle,
  const RandomEventIndex& randomRollIndex) {
  types::eventPossibilities damageCount = 0U;
  for (const Damage damageRoll : damageRolls.val) {
    damageCount += damageRoll.val == damage.val ? 1 : 0;
  }

  POKESIM_ASSERT(damageCount > 0U, "How was a damage roll not found that matched the damage dealt?");

  Probability& probability = registry.get<Probability>(battle.val);
  probability.val *= damageCount / (types::probability)MechanicConstants::MAX_DAMAGE_ROLL_COUNT;
}

inline types::eventPossibilities countUniqueDamageRolls(types::handle moveHandle) {
  const DamageRolls& damageRolls = moveHandle.get<DamageRolls>();
  types::eventPossibilities eventPossibilities = 1U;
  for (std::size_t i = 1U; i < damageRolls.val.size(); i++) {
    eventPossibilities += damageRolls.val[i - 1].val != damageRolls.val[i].val ? 1 : 0;
  }
  return eventPossibilities;
}
}  // namespace internal

inline void cloneFromDamageRolls(Simulation& simulation, DamageRollKind damageRollKind) {
  pokesim::internal::SelectForCurrentActionMoveView<pokesim::tags::SimulateTurn, DamageRolls> selectedMoves{simulation};
  if (selectedMoves.hasNoneSelected()) return;

  bool forAllDamageRolls = calc_damage::damageKindsMatch(damageRollKind, DamageRollKind::ALL_DAMAGE_ROLLS);
  bool forRequiredDamageRolls = simulation.simulateTurnOptions.makeBranchesOnRandomEvents || forAllDamageRolls;
  setRandomEventCounts<internal::countUniqueDamageRolls, pokesim::tags::SelectedForViewMove>(
    simulation,
    forRequiredDamageRolls);

  auto applyChoices = [](Simulation& sim) { sim.viewForSelectedMoves<internal::applyDamageRollIndex>(); };

  auto updateProbabilities =
    forAllDamageRolls ? [](Simulation& sim) { sim.viewForSelectedMoves<internal::assignAllDamageRollProbability>(); }
                      : [](Simulation& sim) { sim.viewForSelectedMoves<internal::assignPartialProbability>(); };

  randomEventCount(simulation, applyChoices, updateProbabilities);
  simulation.removeFromEntities<DamageRolls, pokesim::tags::SelectedForViewMove>();
}

inline void setIfMoveCrits(Simulation& simulation) {
  pokesim::internal::SelectForCurrentActionMoveView<pokesim::tags::SimulateTurn> selectedMoves{simulation};
  if (selectedMoves.hasNoneSelected()) return;

  setReciprocalRandomBinaryChoice<calc_damage::CritChanceDivisor, pokesim::tags::SelectedForViewMove>(simulation);
  reciprocalRandomBinaryChance(simulation, [](Simulation& sim) {
    sim.addToEntities<calc_damage::tags::Crit, pokesim::tags::RandomEventCheckPassed>();
  });

  simulation.registry.clear<calc_damage::CritChanceDivisor>();
}
}  // namespace pokesim::simulate_turn

/////////////// END OF src/SimulateTurn/CalcDamageSpecifics.cpp ////////////////

//////////////// START OF src/Components/Pokedex/Abilities.hpp /////////////////

namespace pokesim {
// Contains one of the standard abilities a species can have.
struct PrimaryAbility {
  dex::Ability name = dex::Ability::NO_ABILITY;
};

// Contains one of the standard abilities a species can have if the species can have two standard abilities.
struct SecondaryAbility {
  dex::Ability name = dex::Ability::NO_ABILITY;
};

// Contains The hidden ability a species has.
struct HiddenAbility {
  dex::Ability name = dex::Ability::NO_ABILITY;
};
}  // namespace pokesim

///////////////// END OF src/Components/Pokedex/Abilities.hpp //////////////////

//////////////// START OF src/Components/Pokedex/BaseStats.hpp /////////////////

namespace pokesim {
// Contains all of the base stats of a species
struct BaseStats {
  types::baseStat hp = 1;
  types::baseStat atk = 1;
  types::baseStat def = 1;
  types::baseStat spa = 1;
  types::baseStat spd = 1;
  types::baseStat spe = 1;
};
}  // namespace pokesim

///////////////// END OF src/Components/Pokedex/BaseStats.hpp //////////////////

///////////////// START OF src/Pokedex/Setup/DexDataSetup.hpp //////////////////

namespace pokesim::dex::internal {
struct DexDataSetup {
 protected:
  types::handle handle;

 public:
  DexDataSetup(types::registry& registry) : handle(registry, registry.create()) {}

  template <typename Tag>
  void setProperty() {
    handle.emplace<Tag>();
  }

  template <typename... T>
  void setProperties(Tags<T...>) {
    (handle.emplace<T>(), ...);
  }

  types::entity entity() { return handle.entity(); }
};
}  // namespace pokesim::dex::internal

////////////////// END OF src/Pokedex/Setup/DexDataSetup.hpp ///////////////////

////////////// START OF src/Pokedex/Setup/SpeciesDexDataSetup.hpp //////////////

namespace pokesim {
class Pokedex;
}

namespace pokesim::dex::internal {
struct SpeciesDexDataSetup : DexDataSetup {
  SpeciesDexDataSetup(types::registry& registry) : DexDataSetup(registry) {}

  inline void setName(Species species);
  inline void setType(Type type1, Type type2 = Type::NO_TYPE);
  inline void setBaseStats(
    types::baseStat hp, types::baseStat atk, types::baseStat def, types::baseStat spa, types::baseStat spd,
    types::baseStat spe);
  inline void setPrimaryAbility(Ability ability);
  inline void setSecondaryAbility(Ability ability);
  inline void setHiddenAbility(Ability ability);
};
}  // namespace pokesim::dex::internal

/////////////// END OF src/Pokedex/Setup/SpeciesDexDataSetup.hpp ///////////////

////////////// START OF src/Pokedex/Setup/SpeciesDexDataSetup.cpp //////////////

namespace pokesim::dex::internal {
inline void SpeciesDexDataSetup::setName(Species species) {
  handle.emplace<SpeciesName>(species);
}

inline void SpeciesDexDataSetup::setType(Type type1, Type type2) {
  handle.emplace<SpeciesTypes>(type1, type2);
}

inline void SpeciesDexDataSetup::setBaseStats(
  types::baseStat hp, types::baseStat atk, types::baseStat def, types::baseStat spa, types::baseStat spd,
  types::baseStat spe) {
  handle.emplace<BaseStats>(hp, atk, def, spa, spd, spe);
}

inline void SpeciesDexDataSetup::setPrimaryAbility(Ability ability) {
  handle.emplace<PrimaryAbility>(ability);
}

inline void SpeciesDexDataSetup::setSecondaryAbility(Ability ability) {
  handle.emplace<SecondaryAbility>(ability);
}

inline void SpeciesDexDataSetup::setHiddenAbility(Ability ability) {
  handle.emplace<HiddenAbility>(ability);
}
}  // namespace pokesim::dex::internal

/////////////// END OF src/Pokedex/Setup/SpeciesDexDataSetup.cpp ///////////////

//////////////////// START OF src/Components/BasePower.hpp /////////////////////

namespace pokesim {
struct BasePower {
  types::basePower val = 1;
};
}  // namespace pokesim

///////////////////// END OF src/Components/BasePower.hpp //////////////////////

////////////////////// START OF src/Components/Chance.hpp //////////////////////

namespace pokesim {
/**
 * @brief Chance of an effect occurring.
 *
 * Examples: Air Slash has a 60% chance to flinch, Harvest has a 50% chance to restore a used berry.
 */
struct Chance {
  types::baseEffectChance val = 100;
};
}  // namespace pokesim

/////////////////////// END OF src/Components/Chance.hpp ///////////////////////

///////////////// START OF src/Components/Names/TypeNames.hpp //////////////////

namespace pokesim {
struct TypeName {
  dex::Type name = dex::Type::NO_TYPE;
};
}  // namespace pokesim

////////////////// END OF src/Components/Names/TypeNames.hpp ///////////////////

///////////////////// START OF src/Components/Priority.hpp /////////////////////

namespace pokesim {
struct MovePriority {
  types::priority val = 0;
};
}  // namespace pokesim

////////////////////// END OF src/Components/Priority.hpp //////////////////////

/////////////// START OF src/Pokedex/Setup/MoveDexDataSetup.hpp ////////////////

#include <type_traits>


namespace pokesim::dex::internal {
struct MoveDexDataSetup : DexDataSetup {
  MoveDexDataSetup(types::registry& registry) : DexDataSetup(registry) {}

  inline void setName(Move move);
  inline void setType(Type type);
  inline void setAccuracy(types::baseAccuracy accuracy);
  inline void setBasePower(types::basePower basePower);

  inline void setCategoryPhysical();
  inline void setCategorySpecial();
  inline void setCategoryStatus();

  inline void setBasePp(types::pp pp);
  inline void setPriority(types::priority priority);
  inline void setHitCount(types::moveHits hitCount);

  inline void setPrimaryEffect(types::entity entity);
  inline void setSecondaryEffect(types::entity entity);

  inline void addAddedTargets(AddedTargetOptions addedTargets);
};

struct MoveEffectSetup : DexDataSetup {
  MoveEffectSetup(types::registry& registry) : DexDataSetup(registry) {}
  types::entity entity() const { return handle; }

  inline void setChance(types::baseEffectChance chance);
  inline void setEffectsSelf();
  inline void setEffectsTarget();

  template <typename BoostType>
  void setBoost(types::boost boost) {
    static_assert(
      std::is_same<AtkBoost, BoostType>() || std::is_same<DefBoost, BoostType>() ||
        std::is_same<SpaBoost, BoostType>() || std::is_same<SpdBoost, BoostType>() ||
        std::is_same<SpeBoost, BoostType>(),
      "Boosts can only be applied to a Pokemon boost stat struct (excluding HP).");
    handle.emplace<BoostType>(boost);
  }
};
}  // namespace pokesim::dex::internal

//////////////// END OF src/Pokedex/Setup/MoveDexDataSetup.hpp /////////////////

/////////////// START OF src/Pokedex/Setup/MoveDexDataSetup.cpp ////////////////

namespace pokesim::dex::internal {
inline void MoveDexDataSetup::setName(Move move) {
  handle.emplace<MoveName>(move);
}

inline void MoveDexDataSetup::setType(Type type) {
  handle.emplace<TypeName>(type);
}

inline void MoveDexDataSetup::addAddedTargets(AddedTargetOptions addedTargets) {
  AddedTargets& existingTargets = handle.get_or_emplace<AddedTargets>();
  existingTargets.val = static_cast<AddedTargetOptions>(
    static_cast<std::uint8_t>(existingTargets.val) | static_cast<std::uint8_t>(addedTargets));

  switch (addedTargets) {
    case AddedTargetOptions::TARGET_ALLY: {
      setProperty<move::added_targets::tags::TargetAlly>();
      break;
    }
    case AddedTargetOptions::USER_ALLY: {
      setProperty<move::added_targets::tags::UserAlly>();
      break;
    }
    case AddedTargetOptions::TARGET_SIDE: {
      setProperty<move::added_targets::tags::TargetSide>();
      break;
    }
    case AddedTargetOptions::USER_SIDE: {
      setProperty<move::added_targets::tags::UserSide>();
      break;
    }
    case AddedTargetOptions::FIELD: {
      setProperty<move::added_targets::tags::Field>();
      break;
    }
    default: break;
  }
}

inline void MoveDexDataSetup::setAccuracy(types::baseAccuracy accuracy) {
  handle.emplace<Accuracy>(accuracy);
}

inline void MoveDexDataSetup::setBasePower(types::basePower basePower) {
  handle.emplace<BasePower>(basePower);
}

inline void MoveDexDataSetup::setCategoryPhysical() {
  POKESIM_ASSERT(!(handle.any_of<move::tags::Special, move::tags::Status>()), "A move can only have one category.");
  setProperty<move::tags::Physical>();
}

inline void MoveDexDataSetup::setCategorySpecial() {
  POKESIM_ASSERT(!(handle.any_of<move::tags::Physical, move::tags::Status>()), "A move can only have one category.");
  setProperty<move::tags::Special>();
}

inline void MoveDexDataSetup::setCategoryStatus() {
  POKESIM_ASSERT(!(handle.any_of<move::tags::Physical, move::tags::Special>()), "A move can only have one category.");
  setProperty<move::tags::Status>();
}

inline void MoveDexDataSetup::setBasePp(types::pp pp) {
  handle.emplace<Pp>(pp);
}

inline void MoveDexDataSetup::setPriority(types::priority priority) {
  handle.emplace<MovePriority>(priority);
}

inline void MoveDexDataSetup::setHitCount(types::moveHits hitCount) {
  handle.emplace<HitCount>(hitCount);
}

inline void MoveDexDataSetup::setPrimaryEffect(types::entity entity) {
  handle.emplace<MoveEffect>(true, entity);
}

inline void MoveDexDataSetup::setSecondaryEffect(types::entity entity) {
  handle.emplace<MoveEffect>(false, entity);
}

inline void MoveEffectSetup::setChance(types::baseEffectChance chance) {
  handle.emplace<Chance>(chance);
}

inline void MoveEffectSetup::setEffectsSelf() {
  handle.emplace<move::tags::effect::MoveSource>();
}

inline void MoveEffectSetup::setEffectsTarget() {
  handle.emplace<move::tags::effect::MoveTarget>();
}
}  // namespace pokesim::dex::internal

//////////////// END OF src/Pokedex/Setup/MoveDexDataSetup.cpp /////////////////

/////////////// START OF src/Pokedex/Setup/ItemDexDataSetup.hpp ////////////////

namespace pokesim::dex::internal {
struct ItemDexDataSetup : DexDataSetup {
  ItemDexDataSetup(types::registry& registry) : DexDataSetup(registry) {}

  inline void setName(Item item);
};
}  // namespace pokesim::dex::internal

//////////////// END OF src/Pokedex/Setup/ItemDexDataSetup.hpp /////////////////

/////////////// START OF src/Pokedex/Setup/ItemDexDataSetup.cpp ////////////////

namespace pokesim::dex::internal {
inline void ItemDexDataSetup::setName(Item item) {
  handle.emplace<ItemName>(item);
}
}  // namespace pokesim::dex::internal

//////////////// END OF src/Pokedex/Setup/ItemDexDataSetup.cpp /////////////////

////////////////// START OF src/Pokedex/Species/Ampharos.hpp ///////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct Ampharos {
  static constexpr Species name = Species::AMPHAROS;
  static constexpr types::baseStat hp = 90, atk = 75, def = 85, spa = 115, spd = 90, spe = 55;

  static constexpr SpeciesTypes type = {Type::ELECTRIC};

  static constexpr Ability primaryAbility = Ability::STATIC;
  static constexpr Ability hiddenAbility = Ability::PLUS;

  struct Strings {
    static constexpr std::string_view name = "Ampharos";
    static constexpr std::string_view smogonName = "Ampharos";
    static constexpr std::string_view smogonId = "ampharos";
  };
};

namespace latest {
using Ampharos = dex::Ampharos<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Species/Ampharos.hpp ////////////////////

////////////////// START OF src/Pokedex/Species/Dragapult.hpp //////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct Dragapult {
  static constexpr Species name = Species::DRAGAPULT;
  static constexpr types::baseStat hp = 88, atk = 120, def = 75, spa = 100, spd = 75, spe = 142;

  static constexpr SpeciesTypes type = {Type::DRAGON, Type::GHOST};

  static constexpr Ability primaryAbility = Ability::CLEAR_BODY;
  static constexpr Ability secondaryAbility = Ability::INFILTRATOR;
  static constexpr Ability hiddenAbility = Ability::CURSED_BODY;

  struct Strings {
    static constexpr std::string_view name = "Dragapult";
    static constexpr std::string_view smogonName = "Dragapult";
    static constexpr std::string_view smogonId = "dragapult";
  };
};

namespace latest {
using Dragapult = dex::Dragapult<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Species/Dragapult.hpp ///////////////////

////////////////// START OF src/Pokedex/Species/Empoleon.hpp ///////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct Empoleon {
  static constexpr Species name = Species::EMPOLEON;
  static constexpr types::baseStat hp = 84, atk = 86, def = 88, spa = 111, spd = 101, spe = 60;

  static constexpr SpeciesTypes type = {Type::WATER, Type::STEEL};

  static constexpr Ability primaryAbility = Ability::TORRENT;
  static constexpr Ability hiddenAbility = Ability::DEFIANT;

  struct Strings {
    static constexpr std::string_view name = "Empoleon";
    static constexpr std::string_view smogonName = "Empoleon";
    static constexpr std::string_view smogonId = "empoleon";
  };
};

template <>
struct Empoleon<GameMechanics::SCARLET_VIOLET> : Empoleon<GameMechanics::NONE> {
  static constexpr Ability hiddenAbility = Ability::COMPETITIVE;
};

namespace latest {
using Empoleon = dex::Empoleon<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Species/Empoleon.hpp ////////////////////

////////////////// START OF src/Pokedex/Species/Gardevoir.hpp //////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct Gardevoir {
  static constexpr Species name = Species::GARDEVOIR;
  static constexpr types::baseStat hp = 68, atk = 65, def = 65, spa = 125, spd = 115, spe = 80;

  static constexpr SpeciesTypes type = {Type::PSYCHIC, Type::FAIRY};

  static constexpr Ability primaryAbility = Ability::SYNCHRONIZE;
  static constexpr Ability secondaryAbility = Ability::TRACE;
  static constexpr Ability hiddenAbility = Ability::TELEPATHY;

  struct Strings {
    static constexpr std::string_view name = "Gardevoir";
    static constexpr std::string_view smogonName = "Gardevoir";
    static constexpr std::string_view smogonId = "gardevoir";
  };
};

namespace latest {
using Gardevoir = dex::Gardevoir<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Species/Gardevoir.hpp ///////////////////

/////////////////// START OF src/Pokedex/Species/Pangoro.hpp ///////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct Pangoro {
  static constexpr Species name = Species::PANGORO;
  static constexpr types::baseStat hp = 95, atk = 124, def = 78, spa = 69, spd = 71, spe = 58;

  static constexpr SpeciesTypes type = {Type::FIGHTING, Type::DARK};

  static constexpr Ability primaryAbility = Ability::IRON_FIST;
  static constexpr Ability secondaryAbility = Ability::MOLD_BREAKER;
  static constexpr Ability hiddenAbility = Ability::SCRAPPY;

  struct Strings {
    static constexpr std::string_view name = "Pangoro";
    static constexpr std::string_view smogonName = "Pangoro";
    static constexpr std::string_view smogonId = "pangoro";
  };
};

namespace latest {
using Pangoro = dex::Pangoro<GameMechanics::SWORD_SHIELD>;
}
}  // namespace pokesim::dex

//////////////////// END OF src/Pokedex/Species/Pangoro.hpp ////////////////////

////////////////// START OF src/Pokedex/Species/Ribombee.hpp ///////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct Ribombee {
  static constexpr Species name = Species::RIBOMBEE;
  static constexpr types::baseStat hp = 60, atk = 55, def = 60, spa = 95, spd = 70, spe = 124;

  static constexpr SpeciesTypes type = {Type::BUG, Type::FAIRY};

  static constexpr Ability primaryAbility = Ability::HONEY_GATHER;
  static constexpr Ability secondaryAbility = Ability::SHIELD_DUST;
  static constexpr Ability hiddenAbility = Ability::SWEET_VEIL;

  struct Strings {
    static constexpr std::string_view name = "Ribombee";
    static constexpr std::string_view smogonName = "Ribombee";
    static constexpr std::string_view smogonId = "Ribombee";
  };
};

namespace latest {
using Ribombee = dex::Ribombee<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Species/Ribombee.hpp ////////////////////

//////////////// START OF src/Pokedex/Setup/GetSpeciesBuild.cpp ////////////////

#include <type_traits>


// TODO(aed3): Make this and the individual species files auto generated

namespace pokesim {
namespace internal {
template <typename T>
struct BuildSpecies {
 private:
  enum class Optional {
    primaryAbility,
    secondaryAbility,
    hiddenAbility,
  };

  template <auto Member>
  using void_t = std::void_t<decltype(Member)>;

  template <Optional, typename = T, typename V = void>
  struct has : std::false_type {};
  template <typename Type>
  struct has<Optional::primaryAbility, Type, void_t<Type::primaryAbility>> : std::true_type {};
  template <typename Type>
  struct has<Optional::secondaryAbility, Type, void_t<Type::secondaryAbility>> : std::true_type {};
  template <typename Type>
  struct has<Optional::hiddenAbility, Type, void_t<Type::hiddenAbility>> : std::true_type {};

 public:
  static types::entity build(types::registry& registry, bool /*forActiveMove*/) {
    dex::internal::SpeciesDexDataSetup species(registry);

    species.setName(T::name);
    species.setBaseStats(T::hp, T::atk, T::def, T::spa, T::spd, T::spe);
    species.setType(T::type.type1(), T::type.type2());

    if constexpr (has<Optional::primaryAbility>::value) {
      species.setPrimaryAbility(T::primaryAbility);
    }
    if constexpr (has<Optional::secondaryAbility>::value) {
      species.setSecondaryAbility(T::secondaryAbility);
    }
    if constexpr (has<Optional::hiddenAbility>::value) {
      species.setHiddenAbility(T::hiddenAbility);
    }

    return species.entity();
  }
};

template <template <GameMechanics> class T>
auto buildSpeciesSV(types::registry& registry, bool forActiveMove) {
  return BuildSpecies<T<GameMechanics::SCARLET_VIOLET>>::build(registry, forActiveMove);
}
};  // namespace internal

inline types::entity Pokedex::buildSpecies(dex::Species species, types::registry& registry, bool forActiveMove) const {
  // Tidy check ignored because "using namespace" is in function
  using namespace pokesim::dex;       // NOLINT(google-build-using-namespace)
  using namespace pokesim::internal;  // NOLINT(google-build-using-namespace)

  switch (mechanics) {
    case GameMechanics::SCARLET_VIOLET: {
      switch (species) {
        case Species::AMPHAROS: return buildSpeciesSV<Ampharos>(registry, forActiveMove);
        case Species::GARDEVOIR: return buildSpeciesSV<Gardevoir>(registry, forActiveMove);
        case Species::EMPOLEON: return buildSpeciesSV<Empoleon>(registry, forActiveMove);
        case Species::PANGORO: return buildSpeciesSV<Pangoro>(registry, forActiveMove);
        case Species::RIBOMBEE: return buildSpeciesSV<Ribombee>(registry, forActiveMove);
        case Species::DRAGAPULT: return buildSpeciesSV<Dragapult>(registry, forActiveMove);
        default: break;
      }
      break;
    }
    default: break;
  }

  POKESIM_ASSERT_FAIL("Building a species that does not exist.");
  return types::entity{};
}
};  // namespace pokesim

///////////////// END OF src/Pokedex/Setup/GetSpeciesBuild.cpp /////////////////

////////////////// START OF src/Pokedex/Moves/FuryAttack.hpp ///////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct FuryAttack {
  static constexpr Move name = Move::FURY_ATTACK;
  static constexpr Type type = Type::NORMAL;
  static constexpr MoveCategory category = MoveCategory::PHYSICAL;

  static constexpr types::baseAccuracy accuracy = 85;
  static constexpr types::basePower basePower = 15;
  static constexpr types::pp basePp = 20;

  static constexpr Tags<move::tags::Contact, move::tags::VariableHitCount> moveTags{};
  static constexpr MoveTarget target = MoveTarget::ANY_SINGLE_TARGET;

  struct Strings {
    static constexpr std::string_view name = "Fury Attack";
    static constexpr std::string_view smogonId = "furyattack";
  };
};

namespace latest {
using FuryAttack = dex::FuryAttack<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Moves/FuryAttack.hpp ////////////////////

/////////////////// START OF src/Pokedex/Moves/KnockOff.hpp ////////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct KnockOff {
  static constexpr Move name = Move::KNOCK_OFF;
  static constexpr Type type = Type::DARK;
  static constexpr MoveCategory category = MoveCategory::PHYSICAL;

  static constexpr types::baseAccuracy accuracy = 100;
  static constexpr types::basePower basePower = 65;
  static constexpr types::pp basePp = 20;

  static constexpr Tags<move::tags::Contact> moveTags{};
  static constexpr MoveTarget target = MoveTarget::ANY_SINGLE_TARGET;

  struct Strings {
    static constexpr std::string_view name = "Knock Off";
    static constexpr std::string_view smogonId = "knockoff";
  };
};

namespace latest {
using KnockOff = dex::KnockOff<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

//////////////////// END OF src/Pokedex/Moves/KnockOff.hpp /////////////////////

/////////////////// START OF src/Pokedex/Moves/Moonblast.hpp ///////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct Moonblast {
  static constexpr Move name = Move::MOONBLAST;
  static constexpr Type type = Type::FAIRY;
  static constexpr MoveCategory category = MoveCategory::SPECIAL;

  static constexpr types::baseAccuracy accuracy = 100;
  static constexpr types::basePower basePower = 95;
  static constexpr types::pp basePp = 15;

  struct targetSecondaryEffect {
    static constexpr types::baseEffectChance chance = 30;
    static constexpr types::boost spaBoost = -1;

    static constexpr Tags<> effectTags{};
  };

  static constexpr Tags<> moveTags{};
  static constexpr MoveTarget target = MoveTarget::ANY_SINGLE_TARGET;

  struct Strings {
    static constexpr std::string_view name = "Moonblast";
    static constexpr std::string_view smogonId = "moonblast";
  };
};

namespace latest {
using Moonblast = dex::Moonblast<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

//////////////////// END OF src/Pokedex/Moves/Moonblast.hpp ////////////////////

////////////////// START OF src/Pokedex/Moves/QuiverDance.hpp //////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct QuiverDance {
  static constexpr Move name = Move::QUIVER_DANCE;
  static constexpr Type type = Type::BUG;
  static constexpr MoveCategory category = MoveCategory::STATUS;

  static constexpr types::pp basePp = 20;

  struct sourcePrimaryEffect {
    static constexpr types::boost spaBoost = 1, spdBoost = 1, speBoost = 1;

    static constexpr Tags<> effectTags{};
  };

  static constexpr Tags<> moveTags{};
  static constexpr MoveTarget target = MoveTarget::SELF;

  struct Strings {
    static constexpr std::string_view name = "Quiver Dance";
    static constexpr std::string_view smogonId = "quiverdance";
  };
};

namespace latest {
using QuiverDance = dex::QuiverDance<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Moves/QuiverDance.hpp ///////////////////

////////////////// START OF src/Pokedex/Moves/Thunderbolt.hpp //////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct Thunderbolt {
  static constexpr Move name = Move::THUNDERBOLT;
  static constexpr Type type = Type::ELECTRIC;
  static constexpr MoveCategory category = MoveCategory::SPECIAL;

  static constexpr types::baseAccuracy accuracy = 100;
  static constexpr types::basePower basePower = 90;
  static constexpr types::pp basePp = 15;

  struct targetSecondaryEffect {
    static constexpr types::baseEffectChance chance = 10;

    static constexpr Tags<status::tags::Paralysis> effectTags{};
  };

  static constexpr Tags<> moveTags{};
  static constexpr MoveTarget target = MoveTarget::ANY_SINGLE_TARGET;

  struct Strings {
    static constexpr std::string_view name = "Thunderbolt";
    static constexpr std::string_view smogonId = "thunderbolt";
  };
};

namespace latest {
using Thunderbolt = dex::Thunderbolt<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

/////////////////// END OF src/Pokedex/Moves/Thunderbolt.hpp ///////////////////

/////////////////// START OF src/Pokedex/Moves/WillOWisp.hpp ///////////////////

#include <string_view>

namespace pokesim::dex {
template <GameMechanics>
struct WillOWisp {
  static constexpr Move name = Move::WILL_O_WISP;
  static constexpr Type type = Type::FIRE;
  static constexpr MoveCategory category = MoveCategory::STATUS;

  static constexpr types::baseAccuracy accuracy = 85;
  static constexpr types::pp basePp = 15;

  struct targetPrimaryEffect {
    static constexpr Tags<status::tags::Burn> effectTags{};
  };

  static constexpr Tags<> moveTags{};
  static constexpr MoveTarget target = MoveTarget::ANY_SINGLE_TARGET;

  struct Strings {
    static constexpr std::string_view name = "Will-O-Wisp";
    static constexpr std::string_view smogonId = "willowisp";
  };
};

namespace latest {
using WillOWisp = dex::WillOWisp<GameMechanics::SCARLET_VIOLET>;
}
}  // namespace pokesim::dex

//////////////////// END OF src/Pokedex/Moves/WillOWisp.hpp ////////////////////

///////////////// START OF src/Pokedex/Setup/GetMoveBuild.cpp //////////////////

#include <type_traits>


// TODO(aed3): Make this and the individual move files auto generated

namespace pokesim {
namespace internal {
template <typename T>
struct BuildMove {
 private:
  enum class Optional {
    accuracy,
    basePower,
    hitCount,
    targetPrimaryEffect,
    targetSecondaryEffect,
    sourcePrimaryEffect,
    sourceSecondaryEffect,
    chance,
    atkBoost,
    defBoost,
    spaBoost,
    spdBoost,
    speBoost,

    // moveTags and effectTags are not optional because setting them as optional does not work with clang
  };

  template <auto Member>
  using void_t = std::void_t<decltype(Member)>;

  template <Optional, typename, typename V = void>
  struct has : std::false_type {};
  template <typename Type>
  struct has<Optional::accuracy, Type, void_t<Type::accuracy>> : std::true_type {};
  template <typename Type>
  struct has<Optional::basePower, Type, void_t<Type::basePower>> : std::true_type {};
  template <typename Type>
  struct has<Optional::hitCount, Type, void_t<Type::hitCount>> : std::true_type {};
  template <typename Type>
  struct has<Optional::targetPrimaryEffect, Type, std::void_t<typename Type::targetPrimaryEffect>> : std::true_type {};
  template <typename Type>
  struct has<Optional::targetSecondaryEffect, Type, std::void_t<typename Type::targetSecondaryEffect>>
      : std::true_type {};
  template <typename Type>
  struct has<Optional::sourcePrimaryEffect, Type, std::void_t<typename Type::sourcePrimaryEffect>> : std::true_type {};
  template <typename Type>
  struct has<Optional::sourceSecondaryEffect, Type, std::void_t<typename Type::sourceSecondaryEffect>>
      : std::true_type {};
  template <typename Type>
  struct has<Optional::chance, Type, void_t<Type::chance>> : std::true_type {};
  template <typename Type>
  struct has<Optional::atkBoost, Type, void_t<Type::atkBoost>> : std::true_type {};
  template <typename Type>
  struct has<Optional::defBoost, Type, void_t<Type::defBoost>> : std::true_type {};
  template <typename Type>
  struct has<Optional::spaBoost, Type, void_t<Type::spaBoost>> : std::true_type {};
  template <typename Type>
  struct has<Optional::spdBoost, Type, void_t<Type::spdBoost>> : std::true_type {};
  template <typename Type>
  struct has<Optional::speBoost, Type, void_t<Type::speBoost>> : std::true_type {};

  template <typename EffectData>
  static types::entity buildEffect(types::registry& registry, bool effectsTarget) {
    dex::internal::MoveEffectSetup effect(registry);

    if constexpr (has<Optional::chance, EffectData>::value) {
      effect.setChance(EffectData::chance);
    }

    if (effectsTarget) {
      effect.setEffectsTarget();
    }
    else {
      effect.setEffectsSelf();
    }

    if constexpr (has<Optional::atkBoost, EffectData>::value) {
      effect.setBoost<AtkBoost>(EffectData::atkBoost);
    }

    if constexpr (has<Optional::defBoost, EffectData>::value) {
      effect.setBoost<DefBoost>(EffectData::defBoost);
    }

    if constexpr (has<Optional::spaBoost, EffectData>::value) {
      effect.setBoost<SpaBoost>(EffectData::spaBoost);
    }

    if constexpr (has<Optional::spdBoost, EffectData>::value) {
      effect.setBoost<SpdBoost>(EffectData::spdBoost);
    }

    if constexpr (has<Optional::speBoost, EffectData>::value) {
      effect.setBoost<SpeBoost>(EffectData::speBoost);
    }

    effect.setProperties(EffectData::effectTags);

    return effect.entity();
  }

 public:
  static types::entity build(types::registry& registry, bool forActiveMove) {
    dex::internal::MoveDexDataSetup move(registry);

    if (!forActiveMove) {
      move.setName(T::name);
      move.setBasePp(T::basePp);
    }

    move.setType(T::type);
    switch (T::category) {
      case dex::MoveCategory::PHYSICAL: {
        move.setCategoryPhysical();
        break;
      }
      case dex::MoveCategory::SPECIAL: {
        move.setCategorySpecial();
        break;
      }
      case dex::MoveCategory::STATUS: {
        move.setCategoryStatus();
        break;
      }
    }

    if constexpr (has<Optional::accuracy, T>::value) {
      move.setAccuracy(T::accuracy);
    }
    if constexpr (has<Optional::basePower, T>::value) {
      move.setBasePower(T::basePower);
    }
    if constexpr (has<Optional::hitCount, T>::value) {
      move.setHitCount(T::hitCount);
    }

    if (!forActiveMove) {
      if constexpr (has<Optional::sourcePrimaryEffect, T>::value) {
        move.setPrimaryEffect(buildEffect<typename T::sourcePrimaryEffect>(registry, false));
      }

      if constexpr (has<Optional::targetPrimaryEffect, T>::value) {
        move.setPrimaryEffect(buildEffect<typename T::targetPrimaryEffect>(registry, true));
      }

      if constexpr (has<Optional::sourceSecondaryEffect, T>::value) {
        move.setSecondaryEffect(buildEffect<typename T::sourceSecondaryEffect>(registry, false));
      }

      if constexpr (has<Optional::targetSecondaryEffect, T>::value) {
        move.setSecondaryEffect(buildEffect<typename T::targetSecondaryEffect>(registry, true));
      }
    }

    move.setProperties(T::moveTags);

    switch (T::target) {
      case MoveTarget::ANY_SINGLE_TARGET: {
        move.setProperty<move::tags::AnySingleTarget>();
        break;
      }
      case MoveTarget::ANY_SINGLE_FOE: {
        move.setProperty<move::tags::AnySingleFoe>();
        break;
      }
      case MoveTarget::ANY_SINGLE_ALLY: {
        move.setProperty<move::tags::AnySingleAlly>();
        break;
      }
      case MoveTarget::ALLY_OR_SELF: {
        move.setProperty<move::tags::AllyOrSelf>();
        break;
      }
      case MoveTarget::SELF: {
        move.setProperty<move::tags::Self>();
        break;
      }
      case MoveTarget::ALL_FOES: {
        move.setProperty<move::tags::AllFoes>();
        move.addAddedTargets(AddedTargetOptions::TARGET_ALLY);
        break;
      }
      case MoveTarget::ALLIES_AND_FOES: {
        move.setProperty<move::tags::AlliesAndFoes>();
        move.addAddedTargets(AddedTargetOptions::TARGET_ALLY);
        move.addAddedTargets(AddedTargetOptions::USER_ALLY);
        break;
      }
      case MoveTarget::ALLIES_AND_SELF: {
        move.setProperty<move::tags::AlliesAndSelf>();
        // Deliberately not USER_ALLY as the target of AlliesAndSelf moves is the user
        move.addAddedTargets(AddedTargetOptions::TARGET_ALLY);
        break;
      }
      case MoveTarget::FOE_SIDE: {
        move.setProperty<move::tags::FoeSide>();
        move.addAddedTargets(AddedTargetOptions::TARGET_SIDE);
        break;
      }
      case MoveTarget::ALLY_SIDE: {
        move.setProperty<move::tags::AllySide>();
        move.addAddedTargets(AddedTargetOptions::USER_SIDE);
        break;
      }
      case MoveTarget::FIELD: {
        move.setProperty<move::tags::Field>();
        move.addAddedTargets(AddedTargetOptions::FIELD);
        break;
      }
      case MoveTarget::ALLY_TEAM: {
        move.setProperty<move::tags::AllyTeam>();
        move.addAddedTargets(AddedTargetOptions::USER_SIDE);
        break;
      }
      case MoveTarget::RETALIATION: {
        move.setProperty<move::tags::Retaliation>();
        break;
      }
      case MoveTarget::RANDOM_FOE: {
        move.setProperty<move::tags::RandomFoe>();
        break;
      }
      default: break;
    }

    return move.entity();
  }
};

template <template <GameMechanics> class T>
auto buildMoveSV(types::registry& registry, bool forActiveMove) {
  return BuildMove<T<GameMechanics::SCARLET_VIOLET>>::build(registry, forActiveMove);
}
};  // namespace internal

inline types::entity Pokedex::buildMove(dex::Move move, types::registry& registry, bool forActiveMove) const {
  // Tidy check ignored because "using namespace" is in function
  using namespace pokesim::dex;       // NOLINT(google-build-using-namespace)
  using namespace pokesim::internal;  // NOLINT(google-build-using-namespace)

  switch (mechanics) {
    case GameMechanics::SCARLET_VIOLET: {
      switch (move) {
        case Move::FURY_ATTACK: return buildMoveSV<FuryAttack>(registry, forActiveMove);
        case Move::THUNDERBOLT: return buildMoveSV<Thunderbolt>(registry, forActiveMove);
        case Move::WILL_O_WISP: return buildMoveSV<WillOWisp>(registry, forActiveMove);
        case Move::KNOCK_OFF: return buildMoveSV<KnockOff>(registry, forActiveMove);
        case Move::QUIVER_DANCE: return buildMoveSV<QuiverDance>(registry, forActiveMove);
        case Move::MOONBLAST: return buildMoveSV<Moonblast>(registry, forActiveMove);
        default: break;
      }
      break;
    }
    default: break;
  }

  POKESIM_ASSERT_FAIL("Building a move that does not exist.");
  return types::entity{};
}
};  // namespace pokesim

////////////////// END OF src/Pokedex/Setup/GetMoveBuild.cpp ///////////////////

///////////////// START OF src/Pokedex/Setup/GetItemBuild.cpp //////////////////

#include <type_traits>


// TODO(aed3): Make this and the individual item files auto generated

namespace pokesim {
namespace internal {
template <typename T>
struct BuildItem {
 private:
 public:
  static types::entity build(types::registry& registry, bool /*forActiveMove*/) {
    dex::internal::ItemDexDataSetup item(registry);

    item.setName(T::name);

    return item.entity();
  }
};

template <template <GameMechanics> class T>
auto buildItemSV(types::registry& registry, bool forActiveMove) {
  return BuildItem<T<GameMechanics::SCARLET_VIOLET>>::build(registry, forActiveMove);
}
};  // namespace internal

inline types::entity Pokedex::buildItem(dex::Item item, types::registry& registry, bool forActiveMove) const {
  // Tidy check ignored because "using namespace" is in function
  using namespace pokesim::dex;       // NOLINT(google-build-using-namespace)
  using namespace pokesim::internal;  // NOLINT(google-build-using-namespace)

  switch (mechanics) {
    case GameMechanics::SCARLET_VIOLET: {
      switch (item) {
        case Item::ASSAULT_VEST: return buildItemSV<AssaultVest>(registry, forActiveMove);
        case Item::BRIGHT_POWDER: return buildItemSV<BrightPowder>(registry, forActiveMove);
        case Item::CHOICE_SCARF: return buildItemSV<ChoiceScarf>(registry, forActiveMove);
        case Item::CHOICE_SPECS: return buildItemSV<ChoiceSpecs>(registry, forActiveMove);
        case Item::FOCUS_SASH: return buildItemSV<FocusSash>(registry, forActiveMove);
        case Item::LIFE_ORB: return buildItemSV<LifeOrb>(registry, forActiveMove);
        default: break;
      }
      break;
    }
    default: break;
  }

  POKESIM_ASSERT_FAIL("Building an item that does not exist.");
  return types::entity{};
}
};  // namespace pokesim

////////////////// END OF src/Pokedex/Setup/GetItemBuild.cpp ///////////////////

////////////// START OF src/Pokedex/Setup/AbilityDexDataSetup.hpp //////////////

namespace pokesim::dex::internal {
struct AbilityDexDataSetup : DexDataSetup {
  AbilityDexDataSetup(types::registry& registry) : DexDataSetup(registry) {}

  inline void setName(Ability ability);
};
}  // namespace pokesim::dex::internal

/////////////// END OF src/Pokedex/Setup/AbilityDexDataSetup.hpp ///////////////

//////////////// START OF src/Pokedex/Setup/GetAbilityBuild.cpp ////////////////

#include <type_traits>


// TODO(aed3): Make this and the individual ability files auto generated

namespace pokesim {
namespace internal {
template <typename T>
struct BuildAbility {
 private:
 public:
  static types::entity build(types::registry& registry, bool /*forActiveMove*/) {
    dex::internal::AbilityDexDataSetup ability(registry);

    ability.setName(T::name);

    return ability.entity();
  }
};

template <template <GameMechanics> class T>
auto buildAbilitySV(types::registry& registry, bool forActiveMove) {
  return BuildAbility<T<GameMechanics::SCARLET_VIOLET>>::build(registry, forActiveMove);
}
};  // namespace internal

inline types::entity Pokedex::buildAbility(dex::Ability ability, types::registry& registry, bool forActiveMove) const {
  // Tidy check ignored because "using namespace" is in function
  using namespace pokesim::dex;       // NOLINT(google-build-using-namespace)
  using namespace pokesim::internal;  // NOLINT(google-build-using-namespace)

  switch (mechanics) {
    case GameMechanics::SCARLET_VIOLET: {
      switch (ability) {
        case Ability::STATIC: return buildAbilitySV<Static>(registry, forActiveMove);
        default: break;
      }
      break;
    }
    default: break;
  }

  POKESIM_ASSERT_FAIL("Building an ability that does not exist.");
  return types::entity{};
}
};  // namespace pokesim

///////////////// END OF src/Pokedex/Setup/GetAbilityBuild.cpp /////////////////

////////////// START OF src/Pokedex/Setup/AbilityDexDataSetup.cpp //////////////

namespace pokesim::dex::internal {
inline void AbilityDexDataSetup::setName(Ability ability) {
  handle.emplace<AbilityName>(ability);
}
}  // namespace pokesim::dex::internal

/////////////// END OF src/Pokedex/Setup/AbilityDexDataSetup.cpp ///////////////

/////////////////////// START OF src/Pokedex/Pokedex.cpp ///////////////////////

namespace pokesim {
template <typename Build, typename T>
void Pokedex::load(entt::dense_map<T, types::entity>& map, const entt::dense_set<T>& list, Build build) {
  map.reserve(map.size() + list.size());
  for (T listItem : list) {
    POKESIM_ASSERT(!map.contains(listItem), "Shouldn't build data entries twice.");
    map[listItem] = build(listItem);
  }
}

inline void Pokedex::loadSpecies(const entt::dense_set<dex::Species>& speciesSet) {
  load(speciesMap, speciesSet, [this](dex::Species species) { return buildSpecies(species, dexRegistry, false); });
}

inline void Pokedex::loadItems(const entt::dense_set<dex::Item>& itemSet) {
  load(itemsMap, itemSet, [this](dex::Item item) { return buildItem(item, dexRegistry, false); });
}

inline void Pokedex::loadMoves(const entt::dense_set<dex::Move>& moveSet) {
  load(movesMap, moveSet, [this](dex::Move move) { return buildMove(move, dexRegistry, false); });
}

inline void Pokedex::loadAbilities(const entt::dense_set<dex::Ability>& abilitySet) {
  load(abilitiesMap, abilitySet, [this](dex::Ability ability) { return buildAbility(ability, dexRegistry, false); });
}

inline types::entity Pokedex::buildActionMove(dex::Move move, types::registry& registry) const {
  return buildMove(move, registry, true);
}
}  // namespace pokesim

//////////////////////// END OF src/Pokedex/Pokedex.cpp ////////////////////////

////////////////// START OF src/Pokedex/Items/ItemEvents.cpp ///////////////////

namespace pokesim::dex::internal {
inline void setChoiceLock(types::handle pokemonHandle, const Battle& battle) {
  types::entity moveSlot = pokemonHandle.registry()->get<CurrentActionMoveSlot>(battle.val).val;
  pokemonHandle.emplace<pokesim::ChoiceLock>(moveSlot);
}
}  // namespace pokesim::dex::internal

namespace pokesim::dex::internal {
inline void AssaultVestEvents::onModifySpd(EventModifier& eventModifier) {
  chainToModifier(eventModifier.val, latest::AssaultVest::onModifySpdModifier);
}

inline void ChoiceScarfEvents::onModifySpe(EventModifier& eventModifier) {
  chainToModifier(eventModifier.val, latest::ChoiceScarf::onModifySpeModifier);
}

inline void ChoiceScarfEvents::onSourceModifyMove(types::handle pokemonHandle, const Battle& battle) {
  setChoiceLock(pokemonHandle, battle);
}

inline void ChoiceSpecsEvents::onModifySpa(EventModifier& eventModifier) {
  chainToModifier(eventModifier.val, latest::ChoiceSpecs::onModifySpaModifier);
}

inline void ChoiceSpecsEvents::onSourceModifyMove(types::handle pokemonHandle, const Battle& battle) {
  setChoiceLock(pokemonHandle, battle);
}
}  // namespace pokesim::dex::internal

/////////////////// END OF src/Pokedex/Items/ItemEvents.cpp ////////////////////

//////////////// START OF src/Pokedex/Effects/EffectEvents.cpp /////////////////

namespace pokesim::dex {
inline void internal::ChoiceLockEvents::onDisableMove(
  types::registry& registry, const pokesim::ChoiceLock& choiceLocked, const MoveSlots& moveSlots) {
  POKESIM_ASSERT(
    std::find(moveSlots.val.begin(), moveSlots.val.end(), choiceLocked.val),
    "Should skip if the move is no longer present, but when does that happen?");

  for (types::entity entity : moveSlots.val) {
    if (entity != choiceLocked.val) {
      registry.emplace<move::tags::Disabled>(entity);
    }
  }
}
}  // namespace pokesim::dex

///////////////// END OF src/Pokedex/Effects/EffectEvents.cpp //////////////////

/////////////// START OF src/Pokedex/Abilities/AbilityEvents.cpp ///////////////

namespace pokesim::dex {
inline void internal::StaticEvents::onDamagingHit(Simulation& /*simulation*/) {}
inline void internal::StaticEvents::onModifySpe(stat::EffectiveSpe& effectiveSpe) {
  effectiveSpe.val /= 2;
}
}  // namespace pokesim::dex

//////////////// END OF src/Pokedex/Abilities/AbilityEvents.cpp ////////////////

//////////// START OF src/CalcDamage/Setup/CalcDamageInputSetup.cpp ////////////

namespace pokesim::calc_damage {
InputSetup::InputSetup(types::registry& _registry) : registry(_registry) {}

inline void InputSetup::setup(
  types::entity battleEntity, types::entity sourceEntity, types::entity targetEntity, dex::Move move,
  const Pokedex& pokedex) {
  moveEntity = createActionMoveForTarget({registry, targetEntity}, battleEntity, sourceEntity, move, pokedex);
  types::handle handle{registry, moveEntity};

  handle.emplace<MoveName>(move);
  handle.emplace<pokesim::tags::CalculateDamage>();
  registry.emplace_or_replace<tags::Attacker>(sourceEntity);
  registry.emplace_or_replace<tags::Defender>(targetEntity);
}

inline types::entity InputSetup::entity() const {
  POKESIM_ASSERT(moveEntity != entt::null, "Getting move entity before proper setup.");
  return moveEntity;
}
}  // namespace pokesim::calc_damage

///////////// END OF src/CalcDamage/Setup/CalcDamageInputSetup.cpp /////////////

////////////// START OF src/Battle/Pokemon/PokemonDataChecks.hpp ///////////////

#include <limits>

namespace pokesim {
inline constexpr types::typeEffectiveness getAttackEffectiveness(const SpeciesTypes& speciesTypes, dex::Type attackingType) {
  types::typeEffectiveness modifier = 0;
  for (dex::Type defendingType : speciesTypes.val) {
    switch (MechanicConstants::TYPE_CHART.effectiveness(attackingType, defendingType)) {
      case TypeEffectiveness::IMMUNE: {
        return -std::numeric_limits<types::typeEffectiveness>::digits;
      }
      case TypeEffectiveness::NEUTRAL: {
        break;
      }
      case TypeEffectiveness::NOT_VERY_EFFECTIVE: {
        modifier--;
        break;
      }
      case TypeEffectiveness::SUPER_EFFECTIVE: {
        modifier++;
      }
    }
  }

  POKESIM_ASSERT(
    modifier <= speciesTypes.size() && modifier >= -speciesTypes.size(),
    "Modifier cannot exceed the number of types.");
  return modifier;
}
}  // namespace pokesim

/////////////// END OF src/Battle/Pokemon/PokemonDataChecks.hpp ////////////////

//////////////////// START OF src/Components/PlayerSide.hpp ////////////////////

namespace pokesim {
struct PlayerSide {
  PlayerSideId val = PlayerSideId::NONE;
};
}  // namespace pokesim

///////////////////// END OF src/Components/PlayerSide.hpp /////////////////////

////////////// START OF src/CalcDamage/CalcDamageDebugChecks.hpp ///////////////

#ifndef NDEBUG


namespace pokesim::calc_damage::debug {
struct Checks : pokesim::debug::Checks {
  Checks(const Simulation& _simulation) : pokesim::debug::Checks(_simulation) {}

  void checkInputs() {
    checkMoveInputs();
    checkPokemonInputs(true);
    checkPokemonInputs(false);
    checkBattleInputs();
    copyRemainingEntities();

    simulateTurnCount = registry.view<pokesim::tags::SimulateTurn>().size();
    calcDamageCount = registry.view<pokesim::tags::CalculateDamage>().size();
    analyzeEffectCount = registry.view<pokesim::tags::AnalyzeEffect>().size();
  }

  void checkOutputs() const {
    checkMoveOutputs();
    checkPokemonOutputs(true);
    checkPokemonOutputs(false);
    checkBattleOutputs();
    checkRemainingOutputs();

    std::size_t finalEntityCount = getFinalEntityCount();

    if (!simulation.simulateTurnOptions.makeBranchesOnRandomEvents) {
      std::size_t finalSimulationTurnCount = registry.view<pokesim::tags::SimulateTurn>().size();
      POKESIM_ASSERT_NM(simulateTurnCount == finalSimulationTurnCount);
      POKESIM_ASSERT_NM(initialEntityCount == finalEntityCount);
    }
    else if (simulateTurnCount == 0) {
      POKESIM_ASSERT_NM(initialEntityCount == finalEntityCount);
    }

    std::size_t finalCalcDamageCount = registry.view<pokesim::tags::CalculateDamage>().size();
    POKESIM_ASSERT_NM(calcDamageCount == finalCalcDamageCount);
    std::size_t finalAnalyzeEffectCount = registry.view<pokesim::tags::AnalyzeEffect>().size();
    POKESIM_ASSERT_NM(analyzeEffectCount == finalAnalyzeEffectCount);
  }

 private:
  std::size_t simulateTurnCount = 0;
  std::size_t calcDamageCount = 0;
  std::size_t analyzeEffectCount = 0;

  void checkMoveInputs() {
    for (types::entity move : simulation.selectedMoveEntities()) {
      originalToCopy[move] = pokesim::debug::createEntityCopy(move, registry, registryOnInput);

      POKESIM_ASSERT_NM(registry.all_of<Attacker>(move));
      POKESIM_ASSERT_NM(registry.all_of<tags::Attacker>(registry.get<Attacker>(move).val));
      POKESIM_ASSERT_NM(registry.all_of<Defenders>(move));
      POKESIM_ASSERT_NM(registry.all_of<tags::Defender>(registry.get<Defenders>(move).only()));
      POKESIM_ASSERT_NM(registry.all_of<Battle>(move));
      POKESIM_ASSERT_NM(registry.all_of<TypeName>(move));
      bool isPhysical = registry.all_of<move::tags::Physical>(move);
      bool isSpecial = registry.all_of<move::tags::Special>(move);
      bool isStatus = registry.all_of<move::tags::Status>(move);
      POKESIM_ASSERT_NM(isPhysical || isSpecial || isStatus);

      bool hasSimulateTurn = registry.all_of<pokesim::tags::SimulateTurn>(move);
      bool hasCalculateDamage = registry.all_of<pokesim::tags::CalculateDamage>(move);
      bool hasAnalyzeEffect = registry.all_of<pokesim::tags::AnalyzeEffect>(move);
      POKESIM_ASSERT_NM(hasSimulateTurn || hasCalculateDamage || hasAnalyzeEffect);
    }
  }

  std::vector<types::entity> getPokemonList(bool forAttacker) const {
    std::vector<types::entity> selectedPokemon = simulation.selectedPokemonEntities();
    auto end = std::remove_if(selectedPokemon.begin(), selectedPokemon.end(), [&](types::entity entity) {
      if (forAttacker) {
        return !this->registry.all_of<tags::Attacker>(entity);
      }

      return !this->registry.all_of<tags::Defender>(entity);
    });

    return {selectedPokemon.begin(), end};
  }

  void checkPokemonInputs(bool forAttacker) {
    const std::vector<types::entity> pokemonList = getPokemonList(forAttacker);
    for (types::entity pokemon : pokemonList) {
      originalToCopy[pokemon] = pokesim::debug::createEntityCopy(pokemon, registry, registryOnInput);

      POKESIM_ASSERT_NM(registry.all_of<UsedMoves>(pokemon));
      bool needsPhy = false;
      bool needsSpc = false;
      for (types::entity move : registry.get<UsedMoves>(pokemon).val) {
        POKESIM_ASSERT_NM(registry.all_of<tags::UsedMove>(move));
        needsPhy |= registry.all_of<move::tags::Physical>(move);
        needsSpc |= registry.all_of<move::tags::Special>(move);
      }
      POKESIM_ASSERT_NM(registry.all_of<Battle>(pokemon));
      POKESIM_ASSERT_NM(registry.all_of<Side>(pokemon));
      POKESIM_ASSERT_NM(registry.all_of<PlayerSide>(registry.get<Side>(pokemon).val));
      POKESIM_ASSERT_NM(registry.all_of<Level>(pokemon));
      POKESIM_ASSERT_NM(registry.all_of<SpeciesTypes>(pokemon));

      if (forAttacker) {
        if (needsPhy) {
          POKESIM_ASSERT_NM(registry.all_of<stat::EffectiveAtk>(pokemon));
        }
        if (needsSpc) {
          POKESIM_ASSERT_NM(registry.all_of<stat::EffectiveSpa>(pokemon));
        }
      }
      else {
        POKESIM_ASSERT_NM(registry.all_of<stat::CurrentHp>(pokemon));
        if (needsPhy) {
          POKESIM_ASSERT_NM(registry.all_of<stat::EffectiveDef>(pokemon));
        }
        if (needsSpc) {
          POKESIM_ASSERT_NM(registry.all_of<stat::EffectiveSpd>(pokemon));
        }
      }

      bool hasSimulateTurn = registry.all_of<pokesim::tags::SimulateTurn>(pokemon);
      bool hasCalculateDamage = registry.all_of<pokesim::tags::CalculateDamage>(pokemon);
      bool hasAnalyzeEffect = registry.all_of<pokesim::tags::AnalyzeEffect>(pokemon);
      POKESIM_ASSERT_NM(hasSimulateTurn || hasCalculateDamage || hasAnalyzeEffect);
    }
  }

  void checkBattleInputs() {
    for (types::entity battle : simulation.selectedBattleEntities()) {
      originalToCopy[battle] = pokesim::debug::createEntityCopy(battle, registry, registryOnInput);
    }
  }

  DamageRollKind getDamageRollKind(types::entity move, DamageRollOptions damageRollOptions) const {
    const Defenders& defenders = registry.get<Defenders>(move);
    const Side& side = registry.get<Side>(defenders.only());
    PlayerSideId playerSide = registry.get<PlayerSide>(side.val).val;
    switch (playerSide) {
      default: break;
      case PlayerSideId::P1: {
        return damageRollOptions.p1;
        break;
      }
      case PlayerSideId::P2: {
        return damageRollOptions.p2;
        break;
      }
    }

    POKESIM_ASSERT_FAIL("Player side wasn't set properly.");
    return DamageRollKind::NONE;
  }

  void checkCalcDamageResultOutputs(types::entity move) const {
    POKESIM_ASSERT_NM(registry.all_of<DamageRolls>(move));

    DamageRollOptions damageRollOptions;
    bool noKoChanceCalculation;
    bool calculateUpToFoeHp;
    if (registry.all_of<pokesim::tags::CalculateDamage>(move)) {
      damageRollOptions = simulation.calculateDamageOptions.damageRollOptions;
      calculateUpToFoeHp = simulation.calculateDamageOptions.calculateUpToFoeHp;
      noKoChanceCalculation = simulation.calculateDamageOptions.noKoChanceCalculation;
    }
    else if (registry.all_of<pokesim::tags::AnalyzeEffect>(move)) {
      damageRollOptions = simulation.analyzeEffectOptions.damageRollOptions;
      calculateUpToFoeHp = simulation.analyzeEffectOptions.calculateUpToFoeHp;
      noKoChanceCalculation = simulation.analyzeEffectOptions.noKoChanceCalculation;
    }
    else {
      POKESIM_ASSERT_FAIL("Where'd the simulation type go? It was checked in the inputs.");
    }

    types::damage lastDamage = std::numeric_limits<types::damage>::max();
    const auto& [damageRolls, defenders] = registry.get<DamageRolls, Defenders>(move);
    const stat::CurrentHp& defenderHp = registry.get<stat::CurrentHp>(defenders.only());

    POKESIM_ASSERT_NM(!damageRolls.val.empty());

    for (const Damage& damageRoll : damageRolls.val) {
      POKESIM_ASSERT_NM(lastDamage >= damageRoll.val);
      POKESIM_ASSERT_NM(damageRoll.val > 0);
      if (calculateUpToFoeHp) {
        POKESIM_ASSERT_NM(damageRoll.val <= defenderHp.val);
      }

      lastDamage = damageRoll.val;
    }

    DamageRollKind damageRollKind = getDamageRollKind(move, damageRollOptions);

    POKESIM_ASSERT(
      damageRollKind != DamageRollKind::NONE,
      "Cannot calculate damage without knowing what rolls to consider.");

    std::size_t idealDamageRollCount = 0;
    if (damageKindsMatch(damageRollKind, DamageRollKind::ALL_DAMAGE_ROLLS)) {
      idealDamageRollCount = MechanicConstants::MAX_DAMAGE_ROLL_COUNT;
    }
    else {
      if (damageKindsMatch(damageRollKind, DamageRollKind::MAX_DAMAGE)) {
        idealDamageRollCount++;
      }

      if (damageKindsMatch(damageRollKind, DamageRollKind::AVERAGE_DAMAGE)) {
        idealDamageRollCount++;
      }

      if (damageKindsMatch(damageRollKind, DamageRollKind::MIN_DAMAGE)) {
        idealDamageRollCount++;
      }
    }

    POKESIM_ASSERT_NM(idealDamageRollCount);
    POKESIM_ASSERT_NM(damageRolls.val.size() == idealDamageRollCount);

    if (noKoChanceCalculation) {
      POKESIM_ASSERT_NM(!registry.all_of<UsesUntilKo>(move));
    }
    else if (damageKindsMatch(DamageRollKind::ALL_DAMAGE_ROLLS, getDamageRollKind(move, damageRollOptions))) {
      POKESIM_ASSERT_NM(registry.all_of<UsesUntilKo>(move));

      const UsesUntilKo& usesUntilKo = registry.get<UsesUntilKo>(move);
      POKESIM_ASSERT_NM(!usesUntilKo.val.empty());
      POKESIM_ASSERT_NM(usesUntilKo.val.front() == usesUntilKo.minHits());
      POKESIM_ASSERT_NM(usesUntilKo.val.back() == usesUntilKo.maxHits());
      POKESIM_ASSERT_NM(usesUntilKo.val.size() <= MechanicConstants::MAX_DAMAGE_ROLL_COUNT);
      POKESIM_ASSERT_NM(usesUntilKo.val.size() <= damageRolls.val.size());

      types::moveHits lastUses = 0;
      types::useUntilKoChance totalChance = 0;
      for (const auto& useUntilKo : usesUntilKo.val) {
        POKESIM_ASSERT_NM(lastUses < useUntilKo.uses);
        totalChance += useUntilKo.chance;
        lastUses = useUntilKo.uses;
      }

      POKESIM_ASSERT_NM(totalChance == 1.0F);
    }
  }

  void checkAttackHpResults(types::entity move) const {
    const auto [attackerHpRecovered, attackerHpLost] = registry.try_get<AttackerHpRecovered, AttackerHpLost>(move);
    const DamageRolls& damageRolls = registry.get<DamageRolls>(move);
    if (attackerHpRecovered != nullptr) {
      POKESIM_ASSERT_NM(attackerHpRecovered->val.size() == damageRolls.val.size());

      for (std::size_t i = 0; i < damageRolls.val.size(); i++) {
        POKESIM_ASSERT_NM(attackerHpRecovered->val[i].val <= damageRolls.val[i].val);
      }
    }

    if (attackerHpLost != nullptr) {
      POKESIM_ASSERT_NM(attackerHpLost->val.size() == damageRolls.val.size());
    }
  }

  void checkMoveOutputs() const {
    for (types::entity move : simulation.selectedMoveEntities()) {
      pokesim::debug::TypesToIgnore typesToIgnore{};
      if (registry.all_of<pokesim::tags::AnalyzeEffect>(move)) {
        typesToIgnore.add<Damage>();
        POKESIM_ASSERT_NM(registry.all_of<Damage>(move));
      }

      if (registry.all_of<pokesim::tags::SimulateTurn>(move)) {
        typesToIgnore.add<Damage>();
        POKESIM_ASSERT_NM(registry.all_of<Damage>(move));
        POKESIM_ASSERT_NM(registry.get<Damage>(move).val > 0);
        POKESIM_ASSERT_NM(!registry.all_of<DamageRolls>(move));
        POKESIM_ASSERT_NM(!registry.all_of<UsesUntilKo>(move));
      }
      else {
        typesToIgnore.add<DamageRolls, UsesUntilKo>();
        checkCalcDamageResultOutputs(move);

        if (registry.all_of<pokesim::tags::CalculateDamage>(move)) {
          typesToIgnore.add<AttackerHpRecovered, AttackerHpLost>();
          checkAttackHpResults(move);
        }
      }

      types::entity originalMove = pokesim::debug::findCopyParent(originalToCopy, registry, move);
      pokesim::debug::areEntitiesEqual(registry, move, registryOnInput, originalToCopy.at(originalMove), typesToIgnore);
    }
  }

  void checkPokemonOutputs(bool forAttacker) const {
    const std::vector<types::entity> pokemonList = getPokemonList(forAttacker);
    for (types::entity pokemon : pokemonList) {
      types::entity originalPokemon = pokesim::debug::findCopyParent(originalToCopy, registry, pokemon);
      pokesim::debug::areEntitiesEqual(registry, pokemon, registryOnInput, originalToCopy.at(originalPokemon));
    }
  }

  void checkBattleOutputs() const {
    for (types::entity battle : simulation.selectedBattleEntities()) {
      pokesim::debug::TypesToIgnore typesToIgnore;
      if (registry.all_of<pokesim::tags::SimulateTurn>(battle)) {
        typesToIgnore.add<Probability, RngSeed, ParentBattle>();
      }
      types::entity originalBattle = pokesim::debug::findCopyParent(originalToCopy, registry, battle);
      pokesim::debug::areEntitiesEqual(
        registry,
        battle,
        registryOnInput,
        originalToCopy.at(originalBattle),
        typesToIgnore);
    }
  }
};
}  // namespace pokesim::calc_damage::debug
#else
namespace pokesim {
class Simulation;
namespace calc_damage::debug {
struct Checks {
  Checks(const Simulation&) {}
  void checkInputs() const {}
  void checkOutputs() const {}
};
}  // namespace calc_damage::debug
}  // namespace pokesim
#endif

/////////////// END OF src/CalcDamage/CalcDamageDebugChecks.hpp ////////////////

////////// START OF src/Components/CalcDamage/DamageCalcVariables.hpp //////////

namespace pokesim::calc_damage {
struct AttackingLevel {
  types::level val = 1;
};

struct AttackingStat {
  types::stat val = 1;
};

struct DefendingStat {
  types::stat val = 1;
};

namespace tags {
struct P1Defending {};
struct P2Defending {};
}  // namespace tags
}  // namespace pokesim::calc_damage

/////////// END OF src/Components/CalcDamage/DamageCalcVariables.hpp ///////////

//////////////////// START OF src/CalcDamage/CalcDamage.cpp ////////////////////

#include <cmath>
#include <type_traits>


namespace pokesim::calc_damage {
namespace internal {
inline void clearRunVariables(Simulation& simulation) {
  simulation.registry.clear<tags::Crit, AttackingLevel, AttackingStat, DefendingStat, DamageRollModifiers>();
  simulation.removeFromEntities<Damage, pokesim::tags::CalculateDamage>();
}

inline void checkForAndApplyStab(
  types::handle moveHandle, const Attacker& attacker, const TypeName& type, DamageRollModifiers& modifier) {
  const SpeciesTypes& attackerTypes = moveHandle.registry()->get<SpeciesTypes>(attacker.val);

  if (attackerTypes.has(type.name)) {
    modifier.stab = StabBoostKind::STANDARD;
  }
}

inline void checkForAndApplyTypeEffectiveness(
  types::handle moveHandle, const Attacker& attacker, const Defenders& defenders, const TypeName& type,
  DamageRollModifiers& modifier) {
  const SpeciesTypes& defenderTypes = moveHandle.registry()->get<SpeciesTypes>(defenders.only());

  modifier.typeEffectiveness = getAttackEffectiveness(defenderTypes, type.name);
}

inline void applyBurnModifier(types::registry& registry, const CurrentActionMoves& moves) {
  for (types::entity move : moves.val) {
    if (!registry.all_of<move::tags::Physical>(move) /*entt::exclude<ignores burn (i.e. Facade) tag>*/) {
      return;
    }

    registry.get<DamageRollModifiers>(move).burn = true;
  }
}

inline void applyCritDamageIncrease(Damage& damage) {
  damage.val = (types::damage)(damage.val * MechanicConstants::CRIT_MULTIPLIER);
}

inline void setDamageToAtLeastOne(Damage& damage) {
  damage.val = std::max(damage.val, (types::damage)1U);
}

inline void setDefendingSide(types::handle moveHandle, const Defenders& defenders) {
  types::registry& registry = *moveHandle.registry();
  PlayerSideId playerSide = registry.get<PlayerSide>(registry.get<Side>(defenders.only()).val).val;
  switch (playerSide) {
    case PlayerSideId::NONE: {
      POKESIM_ASSERT_FAIL("Player side wasn't set properly.");
      break;
    }
    case PlayerSideId::P1: {
      moveHandle.emplace<tags::P1Defending>();
      break;
    }
    case PlayerSideId::P2: {
      moveHandle.emplace<tags::P2Defending>();
      break;
    }
  }
}

inline void modifyDamage(Damage& damage, const DamageRollModifiers& modifiers) {
  damage.val = fixedPointMultiply(damage.val, ((std::uint8_t)modifiers.stab) / 100.0F);

  types::eventModifier typeEffectivenessModifier = MechanicConstants::FIXED_POINT_SCALE;
  if (modifiers.typeEffectiveness < 0) {
    typeEffectivenessModifier = typeEffectivenessModifier >> -modifiers.typeEffectiveness;
  }
  else {
    typeEffectivenessModifier = typeEffectivenessModifier << modifiers.typeEffectiveness;
  }

  applyChainedModifier(damage.val, typeEffectivenessModifier);
  applyChainedModifier(damage.val, modifiers.modifyDamageEvent);

  if (modifiers.burn) {
    damage.val = fixedPointMultiply(damage.val, 0.5F);
  }

  setDamageToAtLeastOne(damage);
}

inline void calculateAllDamageRolls(DamageRolls& damageRolls, const Damage& damage, const DamageRollModifiers& modifier) {
  damageRolls.val.reserve(MechanicConstants::MAX_DAMAGE_ROLL_COUNT);
  for (std::uint8_t i = 0; i < MechanicConstants::MAX_DAMAGE_ROLL_COUNT; i++) {
    Damage& damageRoll = damageRolls.val.emplace_back(damage);
    applyDamageRoll(damageRoll, i);
    modifyDamage(damageRoll, modifier);
  }
}

inline void applyAverageDamageRollModifier(DamageRolls& damageRolls, Damage damage, const DamageRollModifiers& modifier) {
  applyAverageDamageRoll(damage);
  modifyDamage(damage, modifier);
  damageRolls.val.emplace_back(damage);
}

inline void applyMinDamageRollModifier(DamageRolls& damageRolls, Damage damage, const DamageRollModifiers& modifier) {
  applyMinDamageRoll(damage);
  modifyDamage(damage, modifier);
  damageRolls.val.emplace_back(damage);
}

inline void applyDamageRollModifier(DamageRolls& damageRolls, Damage damage, const DamageRollModifiers& modifier) {
  modifyDamage(damage, modifier);
  damageRolls.val.emplace_back(damage);
}

inline void reduceDamageRollsToDefenderHp(
  types::handle moveHandle, DamageRolls& damageRolls, Damage& damage, const DamageRollModifiers& modifier,
  const Defenders& defenders) {
  const stat::CurrentHp& defenderHp = moveHandle.registry()->get<stat::CurrentHp>(defenders.only());
  for (auto& damageRoll : damageRolls.val) {
    damageRoll.val = std::min(defenderHp.val, damageRoll.val);
  }
  damage.val = std::min(defenderHp.val, damage.val);
}

inline void applyDamageRollsAndModifiers(Simulation& simulation, DamageRollKind damageRollKind) {
  POKESIM_ASSERT(
    damageRollKind != DamageRollKind::NONE,
    "Cannot calculate damage without knowing what rolls to consider.");
  POKESIM_ASSERT(
    damageRollKind != DamageRollKind::GUARANTEED_CRIT_CHANCE,
    "Must pick a damage roll kind to go along with crits.");

  simulation.addToEntities<DamageRolls, DamageRollModifiers, pokesim::tags::SelectedForViewMove>();
  if (damageKindsMatch(damageRollKind, DamageRollKind::ALL_DAMAGE_ROLLS)) {
    simulation.viewForSelectedMoves<calculateAllDamageRolls>();
  }
  else {
    if (damageKindsMatch(damageRollKind, DamageRollKind::MAX_DAMAGE)) {
      simulation.viewForSelectedMoves<applyDamageRollModifier>();
    }

    if (damageKindsMatch(damageRollKind, DamageRollKind::AVERAGE_DAMAGE)) {
      simulation.viewForSelectedMoves<applyAverageDamageRollModifier>();
    }

    if (damageKindsMatch(damageRollKind, DamageRollKind::MIN_DAMAGE)) {
      simulation.viewForSelectedMoves<applyMinDamageRollModifier>();
    }
  }
}

inline void assignCritChanceDivisor(types::handle moveHandle, const CritBoost& critBoost) {
  std::size_t index = std::min((std::size_t)critBoost.val, pokesim::MechanicConstants::CRIT_CHANCE_DIVISORS.size() - 1);
  moveHandle.emplace<CritChanceDivisor>(pokesim::MechanicConstants::CRIT_CHANCE_DIVISORS[index]);
}

inline void setSourceLevel(types::handle moveHandle, const Attacker& attacker) {
  moveHandle.emplace<AttackingLevel>(moveHandle.registry()->get<Level>(attacker.val).val);
}

template <typename Category>
void setUsedAttackStat(types::handle moveHandle, const Attacker& attacker) {
  types::stat attackingStat = 1;
  if constexpr (std::is_same_v<Category, move::tags::Physical>) {
    attackingStat = moveHandle.registry()->get<stat::EffectiveAtk>(attacker.val).val;
  }
  else {
    attackingStat = moveHandle.registry()->get<stat::EffectiveSpa>(attacker.val).val;
  }
  moveHandle.emplace<AttackingStat>(attackingStat);
}

template <typename Category>
void setUsedDefenseStat(types::handle moveHandle, const Defenders& defenders) {
  types::stat defendingStat = 1;
  if constexpr (std::is_same_v<Category, move::tags::Physical>) {
    defendingStat = moveHandle.registry()->get<stat::EffectiveDef>(defenders.only()).val;
  }
  else {
    defendingStat = moveHandle.registry()->get<stat::EffectiveSpd>(defenders.only()).val;
  }
  moveHandle.emplace<DefendingStat>(defendingStat);
}

inline void calculateBaseDamage(
  types::handle moveHandle, const BasePower& basePower, const AttackingLevel& level, const AttackingStat& attack,
  const DefendingStat& defense) {
  // NOLINTNEXTLINE(readability-magic-numbers)
  types::damage damage = (((2U * level.val / 5U + 2U) * basePower.val * attack.val) / defense.val) / 50U + 2;
  moveHandle.emplace<Damage>(damage);
}

inline void applyUsesUntilKo(types::handle moveHandle, const DamageRolls& damageRolls, const Defenders& defender) {
  const stat::CurrentHp& defenderHp = moveHandle.registry()->get<stat::CurrentHp>(defender.only());
  UsesUntilKo usesUntilKo;
  POKESIM_ASSERT(
    damageRolls.val.size() == MechanicConstants::MAX_DAMAGE_ROLL_COUNT,
    "All the damage rolls are needed to calculate this correctly.");

  for (const Damage& damageRoll : damageRolls.val) {
    types::moveHits uses = (types::moveHits)std::ceil(defenderHp.val / (types::useUntilKoChance)damageRoll.val);
    if (usesUntilKo.val.empty() || usesUntilKo.val.back().uses != uses) {
      usesUntilKo.val.push_back({uses, 0.0F});
    }

    usesUntilKo.val.back().chance += (1.0 / MechanicConstants::MAX_DAMAGE_ROLL_COUNT);
  }
  moveHandle.emplace<UsesUntilKo>(usesUntilKo);
}

template <typename SimulationTag, auto ApplyDamageRollKind>
void applySideDamageRollOptions(Simulation& simulation) {
  pokesim::internal::SelectForCurrentActionMoveView<SimulationTag> selectedMoves{simulation};
  if (selectedMoves.hasNoneSelected()) {
    return;
  }

  static constexpr bool isSimulateTurn = std::is_same_v<pokesim::tags::SimulateTurn, SimulationTag>;
  static constexpr bool onlyPassDamageRoll =
    std::is_same_v<std::decay_t<void(Simulation&, DamageRollKind)>, decltype(ApplyDamageRollKind)>;

  DamageRollOptions damageRollOptions;
  bool noKoChanceCalculation = false;
  bool calculateUpToFoeHp = false;
  if constexpr (isSimulateTurn) {
    damageRollOptions = simulation.simulateTurnOptions.damageRollsConsidered;
    calculateUpToFoeHp = true;
  }
  else if constexpr (std::is_same_v<pokesim::tags::CalculateDamage, SimulationTag>) {
    damageRollOptions = simulation.calculateDamageOptions.damageRollOptions;
    calculateUpToFoeHp = simulation.calculateDamageOptions.calculateUpToFoeHp;
    noKoChanceCalculation = simulation.calculateDamageOptions.noKoChanceCalculation;
  }
  else if constexpr (std::is_same_v<pokesim::tags::AnalyzeEffect, SimulationTag>) {
    damageRollOptions = simulation.analyzeEffectOptions.damageRollOptions;
    calculateUpToFoeHp = simulation.analyzeEffectOptions.calculateUpToFoeHp;
    noKoChanceCalculation = simulation.calculateDamageOptions.noKoChanceCalculation;
  }

  if (damageRollOptions.sidesMatch()) {
    if constexpr (onlyPassDamageRoll) {
      ApplyDamageRollKind(simulation, damageRollOptions.p1);
    }
    else {
      ApplyDamageRollKind(simulation, damageRollOptions.p1, calculateUpToFoeHp, noKoChanceCalculation);
    }
  }
  else {
    simulation.viewForSelectedMoves<internal::setDefendingSide>();
    pokesim::internal::SelectForCurrentActionMoveView<tags::P1Defending> p1DefendingMoves{simulation};
    if (!p1DefendingMoves.hasNoneSelected()) {
      if constexpr (onlyPassDamageRoll) {
        ApplyDamageRollKind(simulation, damageRollOptions.p1);
      }
      else {
        ApplyDamageRollKind(simulation, damageRollOptions.p1, calculateUpToFoeHp, noKoChanceCalculation);
      }
    }
    p1DefendingMoves.deselect();

    pokesim::internal::SelectForCurrentActionMoveView<tags::P2Defending> p2DefendingMoves{simulation};
    if (!p2DefendingMoves.hasNoneSelected()) {
      if constexpr (onlyPassDamageRoll) {
        ApplyDamageRollKind(simulation, damageRollOptions.p2);
      }
      else {
        ApplyDamageRollKind(simulation, damageRollOptions.p2, calculateUpToFoeHp, noKoChanceCalculation);
      }
    }

    simulation.registry.clear<tags::P1Defending, tags::P2Defending>();
  }
}
}  // namespace internal

template <typename SimulationTag>
void applyDamageRollsAndModifiers(
  Simulation& simulation, DamageRollKind damageRollKind, bool calculateUpToFoeHp, bool noKoChanceCalculation) {
  internal::applyDamageRollsAndModifiers(simulation, damageRollKind);

  if constexpr (std::is_same_v<pokesim::tags::SimulateTurn, SimulationTag>) {
    if (calculateUpToFoeHp) {
      simulation.viewForSelectedMoves<internal::reduceDamageRollsToDefenderHp>();
    }
    simulate_turn::cloneFromDamageRolls(simulation, damageRollKind);
  }
  else {
    simulation.viewForSelectedMoves<internal::modifyDamage>();
    if (calculateUpToFoeHp) {
      simulation.viewForSelectedMoves<internal::reduceDamageRollsToDefenderHp>();
    }
    if (!noKoChanceCalculation && damageKindsMatch(damageRollKind, DamageRollKind::ALL_DAMAGE_ROLLS)) {
      simulation.viewForSelectedMoves<internal::applyUsesUntilKo, Tags<SimulationTag>>();
    }
  }
}

inline void setDamageRollModifiers(Simulation& simulation) {
  simulation.viewForSelectedMoves<internal::checkForAndApplyStab>();
  simulation.viewForSelectedMoves<internal::checkForAndApplyTypeEffectiveness>();
  simulation.viewForSelectedPokemon<
    internal::applyBurnModifier,
    Tags<status::tags::Burn, tags::Attacker> /*, entt::exclude<ability::tags::Guts> */>();
}

inline void applyDamageRoll(Damage& damage, types::damageRoll damageRoll) {
  damage.val = (types::damage)(damage.val * ((100U - damageRoll) / 100.0F));
}

inline void applyAverageDamageRoll(Damage& damage) {
  damage.val = (types::damage)(damage.val * (100U - (MechanicConstants::MAX_DAMAGE_ROLL_COUNT - 1U) / 2.0F) / 100.0F);
}

inline void applyMinDamageRoll(Damage& damage) {
  applyDamageRoll(damage, MechanicConstants::MAX_DAMAGE_ROLL_COUNT - 1U);
}

template <typename SimulationTag>
void setIfMoveCrits(Simulation& simulation, DamageRollKind damageRollKind) {
  if (damageKindsMatch(damageRollKind, DamageRollKind::GUARANTEED_CRIT_CHANCE)) {
    simulation.addToEntities<tags::Crit, pokesim::tags::SelectedForViewMove>();
    return;
  }

  if constexpr (std::is_same_v<SimulationTag, pokesim::tags::SimulateTurn>) {
    simulation.addToEntities<calc_damage::CritBoost, pokesim::tags::SelectedForViewMove, pokesim::tags::SimulateTurn>();
    runModifyCritBoostEvent(simulation);
    simulation.viewForSelectedMoves<internal::assignCritChanceDivisor>();
    simulation.registry.clear<CritBoost>();

    simulate_turn::setIfMoveCrits(simulation);
  }
}

inline void getDamage(Simulation& simulation) {
  pokesim::internal::SelectForCurrentActionMoveView<> selectedMoves{simulation, entt::exclude<move::tags::Status>};
  if (selectedMoves.hasNoneSelected()) {
    return;
  }

  using SimulateTurn = pokesim::tags::SimulateTurn;
  using CalculateDamage = pokesim::tags::CalculateDamage;
  using AnalyzeEffect = pokesim::tags::AnalyzeEffect;

  internal::applySideDamageRollOptions<SimulateTurn, setIfMoveCrits<SimulateTurn>>(simulation);
  internal::applySideDamageRollOptions<CalculateDamage, setIfMoveCrits<CalculateDamage>>(simulation);
  internal::applySideDamageRollOptions<AnalyzeEffect, setIfMoveCrits<AnalyzeEffect>>(simulation);

  // Get base power, boosts, get atk/def stats
  runBasePowerEvent(simulation);
  simulation.viewForSelectedMoves<internal::setSourceLevel>();

  simulation.viewForSelectedMoves<internal::setUsedAttackStat<move::tags::Physical>, Tags<move::tags::Physical>>();
  simulation.viewForSelectedMoves<internal::setUsedAttackStat<move::tags::Special>, Tags<move::tags::Special>>();
  simulation.viewForSelectedMoves<internal::setUsedDefenseStat<move::tags::Physical>, Tags<move::tags::Physical>>();
  simulation.viewForSelectedMoves<internal::setUsedDefenseStat<move::tags::Special>, Tags<move::tags::Special>>();

  simulation.viewForSelectedMoves<internal::calculateBaseDamage>();

  simulation.viewForSelectedMoves<internal::applyCritDamageIncrease, Tags<tags::Crit>>();

  simulation.addToEntities<DamageRollModifiers, pokesim::tags::SelectedForViewMove>();
  setDamageRollModifiers(simulation);

  internal::applySideDamageRollOptions<SimulateTurn, applyDamageRollsAndModifiers<SimulateTurn>>(simulation);
  internal::applySideDamageRollOptions<CalculateDamage, applyDamageRollsAndModifiers<CalculateDamage>>(simulation);
  internal::applySideDamageRollOptions<AnalyzeEffect, applyDamageRollsAndModifiers<AnalyzeEffect>>(simulation);
}

inline void run(Simulation& simulation) {
  debug::Checks debugChecks(simulation);
  debugChecks.checkInputs();

  getDamage(simulation);

  internal::clearRunVariables(simulation);
  debugChecks.checkOutputs();
}
}  // namespace pokesim::calc_damage

///////////////////// END OF src/CalcDamage/CalcDamage.cpp /////////////////////

///////////////// START OF src/Battle/Setup/SideStateSetup.cpp /////////////////

namespace pokesim {
SideStateSetup::SideStateSetup(types::registry& registry, types::entity entity, PlayerSideId playerSideId)
    : StateSetupBase(registry, entity) {
  handle.emplace<tags::Side>();
  handle.emplace<PlayerSide>(playerSideId);
}

inline void SideStateSetup::initBlank() {
  handle.emplace<Battle>();
  handle.emplace<Team>();
  handle.emplace<FoeSide>();
}

inline void SideStateSetup::setTeam(std::vector<PokemonStateSetup>& team) {
  Team& teamEntities = handle.emplace<Team>();
  Battle battle = handle.get<Battle>();
  POKESIM_ASSERT(team.size() <= teamEntities.val.max_size(), "Cannot add more Pokemon to a team than MAX_TEAM_SIZE.");

  for (std::size_t i = 0; i < team.size(); i++) {
    teamEntities.val.push_back(team[i].entity());
    team[i].setPostion((types::teamPositionIndex)(i + 1));
    team[i].setSide(entity());
    team[i].setBattle(battle.val);
  }
}

inline void SideStateSetup::setOpponent(types::entity entity) {
  handle.emplace<FoeSide>(entity);
}

inline void SideStateSetup::setBattle(types::entity entity) {
  handle.emplace<Battle>(entity);
}

inline void SideStateSetup::setPlayerSide(PlayerSideId playerSideId) {
  handle.emplace<PlayerSide>(playerSideId);
}
}  // namespace pokesim

////////////////// END OF src/Battle/Setup/SideStateSetup.cpp //////////////////

///////////////////// START OF src/Components/Position.hpp /////////////////////

namespace pokesim {
// The position of a Pokemon in its team's order (starts at 1)
struct Position {
  types::teamPositionIndex val = 1;
};
}  // namespace pokesim

////////////////////// END OF src/Components/Position.hpp //////////////////////

///////////////// START OF src/Components/Tags/AbilityTags.hpp /////////////////

// TODO(aed3): Make this auto generated

namespace pokesim::ability::tags {
struct Defiant {};
struct Infiltrator {};
struct IronFist {};
struct Static {};
struct SweetVeil {};
struct Trace {};
}  // namespace pokesim::ability::tags

////////////////// END OF src/Components/Tags/AbilityTags.hpp //////////////////

///////////////// START OF src/Components/Tags/NatureTags.hpp //////////////////

// TODO(aed3): Make this auto generated

namespace pokesim::nature::tags {
struct Adamant {};
struct Bashful {};
struct Bold {};
struct Brave {};
struct Calm {};
struct Careful {};
struct Docile {};
struct Gentle {};
struct Hardy {};
struct Hasty {};
struct Impish {};
struct Jolly {};
struct Lax {};
struct Lonely {};
struct Mild {};
struct Modest {};
struct Naive {};
struct Naughty {};
struct Quiet {};
struct Quirky {};
struct Rash {};
struct Relaxed {};
struct Sassy {};
struct Serious {};
struct Timid {};
}  // namespace pokesim::nature::tags

////////////////// END OF src/Components/Tags/NatureTags.hpp ///////////////////

/////////////// START OF src/Battle/Setup/PokemonStateSetup.cpp ////////////////

namespace pokesim {
PokemonStateSetup::PokemonStateSetup(types::registry& registry, types::entity entity)
    : StateSetupBase(registry, entity) {
  handle.emplace<tags::Pokemon>();
}

inline void PokemonStateSetup::initBlank() {
  handle.emplace<SpeciesName>();
  handle.emplace<Side>();
  handle.emplace<Battle>();
  setAutoID();
}

inline void PokemonStateSetup::setAutoID() {
  setID((uint16_t)handle.registry()->view<SpeciesName>().size() + 1);
}

inline void PokemonStateSetup::setID(types::stateId id) {
  handle.emplace<Id>(id);
}

inline void PokemonStateSetup::setSpecies(dex::Species speciesName) {
  handle.emplace<SpeciesName>(speciesName);
}

inline void PokemonStateSetup::setSide(types::entity entity) {
  handle.emplace<Side>(entity);
}

inline void PokemonStateSetup::setBattle(types::entity entity) {
  handle.emplace<Battle>(entity);
}

inline void PokemonStateSetup::setHp(types::stat hp) {
  handle.emplace<stat::CurrentHp>(hp);
}

inline void PokemonStateSetup::setTypes(SpeciesTypes types) {
  handle.emplace<SpeciesTypes>(types);
}

inline void PokemonStateSetup::setLevel(types::level level) {
  handle.emplace<Level>(level);
}

inline void PokemonStateSetup::setGender(dex::Gender gender) {
  handle.emplace<GenderName>(gender);
}

inline void PokemonStateSetup::setAbility(dex::Ability ability) {
  handle.emplace<AbilityName>(ability);
  ability::tags::enumToTag(ability, handle);
}

inline void PokemonStateSetup::setItem(dex::Item item) {
  handle.emplace<ItemName>(item);
  item::tags::enumToTag(item, handle);
}

inline void PokemonStateSetup::setMoves(const std::vector<types::entity>& moveSlots) {
  MoveSlots& moveEntities = handle.emplace<MoveSlots>();
  POKESIM_ASSERT(
    moveSlots.size() <= moveEntities.val.max_size(),
    "Cannot add more moves to a Pokemon than MAX_MOVE_SLOTS.");
  for (types::entity moveSlot : moveSlots) {
    moveEntities.val.push_back(moveSlot);
  }
}

inline void PokemonStateSetup::setPostion(types::teamPositionIndex position) {
  handle.emplace<Position>(position);
}

inline void PokemonStateSetup::setStatus(dex::Status status) {
  pokesim::setStatus(handle, status);
}

inline void PokemonStateSetup::setNature(dex::Nature nature) {
  handle.emplace<NatureName>(nature);
  nature::tags::enumToTag(nature, handle);
}

inline void PokemonStateSetup::setEVs(
  types::ev hp, types::ev atk, types::ev def, types::ev spa, types::ev spd, types::ev spe) {
  handle.emplace<Evs>(hp, atk, def, spa, spd, spe);
}

inline void PokemonStateSetup::setEVs(const Evs& evs) {
  handle.emplace<Evs>(evs);
}

inline void PokemonStateSetup::setIVs(
  types::iv hp, types::iv atk, types::iv def, types::iv spa, types::iv spd, types::iv spe) {
  handle.emplace<Ivs>(hp, atk, def, spa, spd, spe);
}

inline void PokemonStateSetup::setIVs(const Ivs& ivs) {
  handle.emplace<Ivs>(ivs);
}
}  // namespace pokesim

//////////////// END OF src/Battle/Setup/PokemonStateSetup.cpp /////////////////

///////////////// START OF src/Battle/Setup/MoveStateSetup.cpp /////////////////

namespace pokesim {
inline void MoveStateSetup::initBlank() {
  handle.emplace<MoveName>();
  handle.emplace<Pp>();
  handle.emplace<MaxPp>();
}

inline void MoveStateSetup::setName(dex::Move moveName) {
  handle.emplace<MoveName>(moveName);
}

inline void MoveStateSetup::setPP(types::pp pp) {
  handle.emplace<Pp>(pp);
}

inline void MoveStateSetup::setMaxPP(types::pp maxPp) {
  handle.emplace<MaxPp>(maxPp);
}
}  // namespace pokesim

////////////////// END OF src/Battle/Setup/MoveStateSetup.cpp //////////////////

/////////////////// START OF src/Battle/Setup/EnumToTag.cpp ////////////////////

// TODO(aed3): Make this auto generated

namespace pokesim {
inline void ability::tags::enumToTag(dex::Ability ability, types::handle handle) {
  switch (ability) {
    case dex::Ability::DEFIANT: handle.emplace<Defiant>(); return;
    case dex::Ability::INFILTRATOR: handle.emplace<Infiltrator>(); return;
    case dex::Ability::IRON_FIST: handle.emplace<IronFist>(); return;
    case dex::Ability::STATIC: handle.emplace<Static>(); return;
    case dex::Ability::SWEET_VEIL: handle.emplace<SweetVeil>(); return;
    case dex::Ability::TRACE: handle.emplace<Trace>(); return;
    default: {
      POKESIM_ASSERT(false, "Adding tag for ability that does not exist.");
    }
  }
}

inline void item::tags::enumToTag(dex::Item item, types::handle handle) {
  switch (item) {
    case dex::Item::ASSAULT_VEST: handle.emplace<AssaultVest>(); return;
    case dex::Item::BRIGHT_POWDER: handle.emplace<BrightPowder>(); return;
    case dex::Item::CHOICE_SCARF: handle.emplace<ChoiceScarf>(); return;
    case dex::Item::CHOICE_SPECS: handle.emplace<ChoiceSpecs>(); return;
    case dex::Item::FOCUS_SASH: handle.emplace<FocusSash>(); return;
    case dex::Item::LIFE_ORB: handle.emplace<LifeOrb>(); return;
    default: {
      POKESIM_ASSERT(false, "Adding tag for item that does not exist.");
    }
  }
}

inline void nature::tags::enumToTag(dex::Nature nature, types::handle handle) {
  switch (nature) {
    case dex::Nature::ADAMANT: handle.emplace<Adamant>(); return;
    case dex::Nature::BASHFUL: handle.emplace<Bashful>(); return;
    case dex::Nature::BOLD: handle.emplace<Bold>(); return;
    case dex::Nature::BRAVE: handle.emplace<Brave>(); return;
    case dex::Nature::CALM: handle.emplace<Calm>(); return;
    case dex::Nature::CAREFUL: handle.emplace<Careful>(); return;
    case dex::Nature::DOCILE: handle.emplace<Docile>(); return;
    case dex::Nature::GENTLE: handle.emplace<Gentle>(); return;
    case dex::Nature::HARDY: handle.emplace<Hardy>(); return;
    case dex::Nature::HASTY: handle.emplace<Hasty>(); return;
    case dex::Nature::IMPISH: handle.emplace<Impish>(); return;
    case dex::Nature::JOLLY: handle.emplace<Jolly>(); return;
    case dex::Nature::LAX: handle.emplace<Lax>(); return;
    case dex::Nature::LONELY: handle.emplace<Lonely>(); return;
    case dex::Nature::MILD: handle.emplace<Mild>(); return;
    case dex::Nature::MODEST: handle.emplace<Modest>(); return;
    case dex::Nature::NAIVE: handle.emplace<Naive>(); return;
    case dex::Nature::NAUGHTY: handle.emplace<Naughty>(); return;
    case dex::Nature::QUIET: handle.emplace<Quiet>(); return;
    case dex::Nature::QUIRKY: handle.emplace<Quirky>(); return;
    case dex::Nature::RASH: handle.emplace<Rash>(); return;
    case dex::Nature::RELAXED: handle.emplace<Relaxed>(); return;
    case dex::Nature::SASSY: handle.emplace<Sassy>(); return;
    case dex::Nature::SERIOUS: handle.emplace<Serious>(); return;
    case dex::Nature::TIMID: handle.emplace<Timid>(); return;
    default: {
      POKESIM_ASSERT(false, "Adding tag for nature that does not exist.");
    }
  }
}

inline void status::tags::enumToTag(dex::Status status, types::handle& handle) {
  switch (status) {
    case dex::Status::BRN: handle.emplace<Burn>(); return;
    case dex::Status::FRZ: handle.emplace<Freeze>(); return;
    case dex::Status::PAR: handle.emplace<Paralysis>(); return;
    case dex::Status::PSN: handle.emplace<Poison>(); return;
    case dex::Status::SLP: handle.emplace<Sleep>(); return;
    case dex::Status::TOX: handle.emplace<Toxic>(); return;
    default: {
      POKESIM_ASSERT(false, "Adding tag for status that does not exist.");
    }
  }
}
}  // namespace pokesim

//////////////////// END OF src/Battle/Setup/EnumToTag.cpp /////////////////////

//////////////// START OF src/Battle/Setup/BattleStateSetup.cpp ////////////////

#include <atomic>

namespace pokesim {
BattleStateSetup::BattleStateSetup(types::registry& registry, types::entity entity) : StateSetupBase(registry, entity) {
  if (!handle.any_of<ActionQueue, tags::Battle>()) {
    handle.emplace<ActionQueue>();
    handle.emplace<tags::Battle>();
  }
}

inline void BattleStateSetup::initBlank() {
  handle.emplace<Sides>();
  handle.emplace<ActionQueue>();
  setAutoID();
  setTurn(0);
  setProbability(1);
}

inline void BattleStateSetup::setAutoID() {
  setID((types::stateId)handle.registry()->view<Sides>().size());
}

inline void BattleStateSetup::setID(types::stateId id) {
  handle.emplace_or_replace<Id>(id);
}

inline void BattleStateSetup::setSide(types::entity sideEntity) {
  auto& sides = handle.get_or_emplace<Sides>();
  PlayerSideId sideId = handle.registry()->get<PlayerSide>(sideEntity).val;
  switch (sideId) {
    case PlayerSideId::P1: sides.p1() = sideEntity; break;
    case PlayerSideId::P2: sides.p2() = sideEntity; break;
    default: POKESIM_ASSERT_FAIL("sideID must be assigned P1 or P2."); break;
  }
}

inline void BattleStateSetup::setRNGSeed(std::optional<types::rngState> seed) {
  if (!seed.has_value()) {
    static std::atomic_uint64_t state = 1;
    seed = state;

    types::rngState newState = state;
    internal::nextRandomValue(newState);
    state = newState;
  }
  handle.emplace<RngSeed>(seed.value());
}

inline void BattleStateSetup::setActionQueue(const std::vector<types::entity>& queue) {
  handle.emplace<ActionQueue>(queue);
}

inline void BattleStateSetup::setTurn(types::battleTurn turn) {
  handle.emplace<Turn>(turn);
}

inline void BattleStateSetup::setCurrentActionTarget(types::targets<types::entity> actionTargets) {
  handle.emplace<CurrentActionTargets>(actionTargets);
  for (types::entity entity : actionTargets) {
    handle.registry()->emplace<tags::CurrentActionMoveTarget>(entity);
  }
}

inline void BattleStateSetup::setCurrentActionSource(types::entity actionSource) {
  handle.emplace<CurrentActionSource>(actionSource);
  handle.registry()->emplace<tags::CurrentActionMoveSource>(actionSource);
}

inline void BattleStateSetup::setCurrentActionMove(types::entity actionMove) {
  handle.emplace<CurrentActionMoves>().val.push_back(actionMove);
  handle.registry()->emplace<tags::CurrentActionMove>(actionMove);
}

inline void BattleStateSetup::setProbability(types::probability probability) {
  handle.emplace<Probability>(probability);
}

inline std::vector<BattleStateSetup> BattleStateSetup::clone(std::optional<types::cloneIndex> cloneCount) {
  types::registry& registry = *handle.registry();

  handle.emplace<tags::CloneFrom>();
  const types::ClonedEntityMap entityMap = pokesim::clone(registry, cloneCount);

  const auto& clonedBattles = entityMap.at(handle.entity());
  std::vector<BattleStateSetup> clonedSetups;
  clonedSetups.reserve(clonedBattles.size());

  for (types::entity entity : clonedBattles) {
    clonedSetups.emplace_back(registry, entity);
  }

  return clonedSetups;
}
}  // namespace pokesim

///////////////// END OF src/Battle/Setup/BattleStateSetup.cpp /////////////////

//////////// START OF src/Components/EntityHolders/LastUsedMove.hpp ////////////

namespace pokesim {
struct LastUsedMove {
  types::entity val{};
};
}  // namespace pokesim

///////////// END OF src/Components/EntityHolders/LastUsedMove.hpp /////////////

///////////////// START OF src/Components/Names/StatNames.hpp //////////////////

namespace pokesim {
struct StatName {
  dex::Stat name;
};
}  // namespace pokesim

////////////////// END OF src/Components/Names/StatNames.hpp ///////////////////

////////////// START OF src/Battle/Pokemon/ManagePokemonState.cpp //////////////

namespace pokesim {
inline void setStatus(types::handle pokemonHandle, dex::Status status) {
  clearStatus(pokemonHandle);
  pokemonHandle.emplace<StatusName>(status);
  status::tags::enumToTag(status, pokemonHandle);
}

inline void clearStatus(types::handle pokemonHandle) {
  pokemonHandle.remove<
    StatusName,
    status::tags::Burn,
    status::tags::Freeze,
    status::tags::Paralysis,
    status::tags::Poison,
    status::tags::Sleep,
    status::tags::Toxic>();
}

inline void deductPp(Pp& pp) {
  if (pp.val) {
    pp.val -= 1;
  }
}

inline void setLastMoveUsed(types::registry& registry, const CurrentActionSource& source, const CurrentActionMoveSlot& move) {
  registry.emplace<LastUsedMove>(source.val, move.val);
}

inline void resetEffectiveAtk(types::handle handle, stat::Atk atk) {
  handle.emplace_or_replace<stat::EffectiveAtk>(atk.val);
}

inline void resetEffectiveDef(types::handle handle, stat::Def def) {
  handle.emplace_or_replace<stat::EffectiveDef>(def.val);
}

inline void resetEffectiveSpa(types::handle handle, stat::Spa spa) {
  handle.emplace_or_replace<stat::EffectiveSpa>(spa.val);
}

inline void resetEffectiveSpd(types::handle handle, stat::Spd spd) {
  handle.emplace_or_replace<stat::EffectiveSpd>(spd.val);
}

inline void resetEffectiveSpe(types::handle handle, stat::Spe spe) {
  handle.emplace_or_replace<stat::EffectiveSpe>(spe.val);
}

inline void applyDamageToHp(types::registry& registry, const Damage& damage, CurrentActionTargets& targets) {
  stat::CurrentHp& hp = registry.get<stat::CurrentHp>(targets.only());
  if (damage.val > hp.val) {
    hp.val = 0;
    // Faint
  }
  else {
    hp.val -= damage.val;
  }
}

inline void updateAllStats(Simulation& simulation) {
  updateAtk(simulation);
  updateDef(simulation);
  updateSpa(simulation);
  updateSpd(simulation);
  updateSpe(simulation);
}

inline void updateAtk(Simulation& simulation) {
  internal::SelectForPokemonView<tags::AtkStatUpdateRequired> selectedAtkUpdateRequired{simulation};
  if (selectedAtkUpdateRequired.hasNoneSelected()) return;

  simulation.viewForSelectedPokemon<resetEffectiveAtk>();

  // apply boosts
  runModifyAtk(simulation);

  selectedAtkUpdateRequired.deselect();
  simulation.registry.clear<tags::AtkStatUpdateRequired>();
}

inline void updateDef(Simulation& simulation) {
  internal::SelectForPokemonView<tags::DefStatUpdateRequired> selectedDefUpdateRequired{simulation};
  if (selectedDefUpdateRequired.hasNoneSelected()) return;

  simulation.viewForSelectedPokemon<resetEffectiveDef>();

  // apply boosts
  runModifyDef(simulation);

  selectedDefUpdateRequired.deselect();
  simulation.registry.clear<tags::DefStatUpdateRequired>();
}

inline void updateSpa(Simulation& simulation) {
  internal::SelectForPokemonView<tags::SpaStatUpdateRequired> selectedSpaUpdateRequired{simulation};
  if (selectedSpaUpdateRequired.hasNoneSelected()) return;

  simulation.viewForSelectedPokemon<resetEffectiveSpa>();

  // apply boosts
  runModifySpa(simulation);

  selectedSpaUpdateRequired.deselect();
  simulation.registry.clear<tags::SpaStatUpdateRequired>();
}

inline void updateSpd(Simulation& simulation) {
  internal::SelectForPokemonView<tags::SpdStatUpdateRequired> selectedSpdUpdateRequired{simulation};
  if (selectedSpdUpdateRequired.hasNoneSelected()) return;

  simulation.viewForSelectedPokemon<resetEffectiveSpd>();

  // apply boosts
  runModifySpd(simulation);

  selectedSpdUpdateRequired.deselect();
  simulation.registry.clear<tags::SpdStatUpdateRequired>();
}

inline void updateSpe(Simulation& simulation) {
  internal::SelectForPokemonView<tags::SpeStatUpdateRequired> selectedSpeUpdateRequired{simulation};
  if (selectedSpeUpdateRequired.hasNoneSelected()) return;

  simulation.viewForSelectedPokemon<resetEffectiveSpe>();

  // apply boosts
  runModifySpe(simulation);
  // trick room

  selectedSpeUpdateRequired.deselect();
  simulation.registry.clear<tags::SpeStatUpdateRequired>();
}
}  // namespace pokesim

/////////////// END OF src/Battle/Pokemon/ManagePokemonState.cpp ///////////////

////////////////// START OF src/Battle/ManageBattleState.cpp ///////////////////

namespace pokesim {
inline void assignRootBattle(types::handle battleHandle) {
  const ParentBattle* parentBattle = battleHandle.try_get<ParentBattle>();
  types::entity rootBattle = parentBattle == nullptr ? battleHandle.entity() : parentBattle->val;
  battleHandle.emplace<RootBattle>(rootBattle);
}

inline void collectTurnOutcomeBattles(types::handle leafBattleHandle, const RootBattle& root) {
  leafBattleHandle.registry()->get_or_emplace<simulate_turn::TurnOutcomeBattles>(root.val).val.push_back(
    leafBattleHandle.entity());
}

inline void setCurrentActionSource(types::handle battleHandle, const Sides& sides, const CurrentAction& action) {
  types::registry& registry = *battleHandle.registry();
  const SourceSlotName& sourceSlotName = registry.get<SourceSlotName>(action.val);
  types::entity sourceEntity = slotToPokemonEntity(registry, sides, sourceSlotName.name);

  battleHandle.emplace<CurrentActionSource>(sourceEntity);
  registry.emplace<tags::CurrentActionMoveSource>(sourceEntity);
}

inline void setCurrentActionTarget(
  types::handle battleHandle, const Sides& sides, const CurrentAction& action, const CurrentActionSource& source) {
  types::registry& registry = *battleHandle.registry();
  const TargetSlotName& targetSlotName = registry.get<TargetSlotName>(action.val);
  types::entity targetEntity = slotToPokemonEntity(registry, sides, targetSlotName.name);

  if (!registry.any_of<tags::Fainted>(targetEntity)) {
    battleHandle.emplace<CurrentActionTargets>(types::targets<types::entity>{targetEntity});
    registry.emplace<tags::CurrentActionMoveTarget>(targetEntity);
    registry.emplace<CurrentActionSource>(targetEntity, source);
  }
  else {
    // Set tag to get random target after this function exits
  }
}

inline void setCurrentActionMove(
  types::handle battleHandle, const CurrentActionSource& source, const CurrentActionTargets& targets,
  const CurrentAction& action, const Pokedex& pokedex) {
  types::registry& registry = *battleHandle.registry();
  const action::Move& move = registry.get<action::Move>(action.val);
  const MoveSlots& moveSlots = registry.get<MoveSlots>(source.val);

  types::entity moveSlotEntity = moveToEntity(registry, moveSlots, move.name);

  types::entity moveEntity =
    createActionMoveForTarget({registry, targets.only()}, battleHandle.entity(), source.val, move.name, pokedex);

  if (battleHandle.all_of<tags::SimulateTurn>()) {
    registry.emplace<tags::SimulateTurn>(moveEntity);
  }

  battleHandle.emplace<CurrentActionMoveSlot>(moveSlotEntity);
  registry.emplace<tags::CurrentActionMoveSlot>(moveSlotEntity);
}

inline void clearCurrentAction(Simulation& simulation) {
  types::registry& registry = simulation.registry;
  registry.clear<CurrentAction>();
  registry.clear<CurrentActionTargets>();
  registry.clear<CurrentActionSource>();
  registry.clear<CurrentActionMoves>();
  registry.clear<CurrentActionMoveSlot>();

  registry.clear<tags::CurrentActionMoveTarget>();
  registry.clear<tags::CurrentActionMoveSource>();
  registry.clear<tags::CurrentActionMoveSlot>();

  auto actionMoves = registry.view<tags::CurrentActionMove>();
  registry.destroy(actionMoves.begin(), actionMoves.end());
  auto currentActions = registry.view<action::tags::Current>();
  registry.destroy(currentActions.begin(), currentActions.end());

  auto battles = simulation.selectedBattleEntities();
  registry.remove<
    action::Item,
    action::Move,
    action::tags::BeforeTurn,
    action::tags::Dynamax,
    action::tags::MegaEvolve,
    action::tags::MidTurnSwitchIn,
    action::tags::PostFoeFaintSwitchIn,
    action::tags::PreSwitchOut,
    action::tags::PreTurnSwitchIn,
    action::tags::PrimalRevert,
    action::tags::Residual,
    action::tags::RevivalBlessing,
    action::tags::Switch,
    action::tags::SwitchOut,
    action::tags::Terastallize>(battles.begin(), battles.end());
}
}  // namespace pokesim

/////////////////// END OF src/Battle/ManageBattleState.cpp ////////////////////

/////////////////// START OF src/Battle/Helpers/Helpers.cpp ////////////////////

#include <cstdint>

namespace pokesim {

inline types::entity slotToSideEntity(const Sides& sides, Slot targetSlot) {
  POKESIM_ASSERT(targetSlot != Slot::NONE, "Can only get entity from valid target slot.");
  types::entity sideEntity = sides.val[((std::uint8_t)targetSlot - 1) % 2];
  return sideEntity;
}

inline types::entity slotToPokemonEntity(const types::registry& registry, types::entity sideEntity, Slot targetSlot) {
  types::teamPositionIndex index = ((std::uint8_t)targetSlot - 1) / 2;

  const Team& team = registry.get<Team>(sideEntity);
  POKESIM_ASSERT(team.val.size() > index, "Choosing a target slot for team member that does not exist.");
  return team.val[index];
}

inline types::entity slotToPokemonEntity(const types::registry& registry, const Sides& sides, Slot targetSlot) {
  POKESIM_ASSERT(targetSlot != Slot::NONE, "Can only get entity from valid target slot.");
  return slotToPokemonEntity(registry, slotToSideEntity(sides, targetSlot), targetSlot);
}

inline types::entity slotToAllyPokemonEntity(const types::registry& registry, const Sides& sides, Slot targetSlot) {
  POKESIM_ASSERT(targetSlot != Slot::NONE, "Can only get entity from valid target slot.");
  Slot allySlot = Slot::NONE;
  types::teamPositionIndex index = 0;

  switch (targetSlot) {
    case Slot::P1A: {
      allySlot = Slot::P1B;
      index = 1;
      break;
    }
    case Slot::P1B:
    case Slot::P1C:
    case Slot::P1D:
    case Slot::P1E:
    case Slot::P1F: {
      allySlot = Slot::P1A;
      break;
    }
    case Slot::P2A: {
      allySlot = Slot::P2B;
      index = 1;
      break;
    }
    case Slot::P2B:
    case Slot::P2C:
    case Slot::P2D:
    case Slot::P2E:
    case Slot::P2F: {
      allySlot = Slot::P2A;
      break;
    }
    default: break;
  }

  types::entity sideEntity = slotToSideEntity(sides, allySlot);
  const Team& team = registry.get<Team>(sideEntity);
  if (team.val.size() <= index) {
    return entt::null;
  }

  types::entity allyEntity = team.val[index];
  if (registry.any_of<tags::Fainted>(allyEntity)) {
    return entt::null;
  }

  return allyEntity;
}

inline types::entity moveToEntity(const types::registry& registry, const MoveSlots& moveSlots, dex::Move move) {
  for (types::entity moveSlot : moveSlots.val) {
    if (registry.get<MoveName>(moveSlot).name == move) {
      return moveSlot;
    }
  }

  POKESIM_ASSERT_FAIL("No move of entity found.");
  return entt::null;
}

inline types::entity createActionMoveForTarget(
  types::handle targetHandle, types::entity battleEntity, types::entity sourceEntity, dex::Move move,
  const Pokedex& pokedex) {
  types::registry& registry = *targetHandle.registry();
  types::entity moveEntity = pokedex.buildActionMove(move, registry);

  registry.emplace<tags::CurrentActionMove>(moveEntity);
  registry.emplace<Battle>(moveEntity, battleEntity);
  registry.emplace<CurrentActionSource>(moveEntity, sourceEntity);
  registry.emplace<CurrentActionTargets>(moveEntity).val.push_back(targetHandle.entity());

  targetHandle.get_or_emplace<CurrentActionMoves>().val.push_back(moveEntity);
  registry.get_or_emplace<CurrentActionMoves>(sourceEntity).val.push_back(moveEntity);

  return moveEntity;
}
}  // namespace pokesim

//////////////////// END OF src/Battle/Helpers/Helpers.cpp /////////////////////

////////////// START OF src/Components/EntityHolders/Pokemon.hpp ///////////////

namespace pokesim {
// Contains the entity pointing to a Pokemon.
struct Pokemon {
  types::entity val{};
};
}  // namespace pokesim

/////////////// END OF src/Components/EntityHolders/Pokemon.hpp ////////////////

///////////////////// START OF src/Battle/Clone/Clone.cpp //////////////////////

#include <vector>

namespace pokesim {
namespace internal {
inline void cloneEntity(
  types::entity src, types::registry& registry, types::ClonedEntityMap& entityMap,
  entt::dense_map<entt::id_type, std::vector<types::entity>>& srcEntityStorages, types::cloneIndex cloneCount) {
  for (auto [id, storage] : registry.storage()) {
    if (storage.contains(src)) {
      POKESIM_ASSERT(
        std::find(srcEntityStorages[id].begin(), srcEntityStorages[id].end(), src) == std::end(srcEntityStorages[id]),
        "Adding an entity twice here means an entity will be duplicated more than it should.");
      srcEntityStorages[id].push_back(src);
    }
  }

  auto& destinations = entityMap[src] = std::vector<types::entity>{cloneCount};
  registry.create(destinations.begin(), destinations.end());
}

template <typename VisitEntity = void*>
void traverseBattle(types::registry& registry, VisitEntity visitEntity = nullptr) {
  const static bool ForCloning = !std::is_same_v<void*, VisitEntity>;
  using Tag = std::conditional_t<ForCloning, tags::CloneFrom, tags::CloneToRemove>;

  for (const auto [entity, sides, actionQueue] : registry.view<Tag, tags::Battle, Sides, ActionQueue>().each()) {
    for (auto side : sides.val) {
      registry.emplace<Tag>(side);
    }
    for (auto queueItem : actionQueue.val) {
      registry.emplace<Tag>(queueItem);
    }

    if constexpr (ForCloning) {
      visitEntity(entity);
    }
  }
  for (const auto [entity, currentAction] : registry.view<Tag, tags::Battle, CurrentAction>().each()) {
    registry.emplace<Tag>(currentAction.val);
  }
}

template <typename VisitEntity = void*>
void traverseSide(types::registry& registry, VisitEntity visitEntity = nullptr) {
  const static bool ForCloning = !std::is_same_v<void*, VisitEntity>;
  using Tag = std::conditional_t<ForCloning, tags::CloneFrom, tags::CloneToRemove>;

  for (const auto [entity, team] : registry.view<Tag, tags::Side, Team>().each()) {
    for (auto pokemon : team.val) {
      registry.emplace<Tag>(pokemon);
    }

    if constexpr (ForCloning) {
      visitEntity(entity);
    }
  }
}

template <typename VisitEntity = void*>
void traverseAction(types::registry& registry, VisitEntity visitEntity = nullptr) {
  const static bool ForCloning = !std::is_same_v<void*, VisitEntity>;
  using Tag = std::conditional_t<ForCloning, tags::CloneFrom, tags::CloneToRemove>;

  if constexpr (ForCloning) {
    for (types::entity entity : registry.view<Tag, SpeedSort>()) {
      visitEntity(entity);
    }
  }
}

template <typename VisitEntity = void*>
void traverseCurrentActionMove(types::registry& registry, VisitEntity visitEntity = nullptr) {
  const static bool ForCloning = !std::is_same_v<void*, VisitEntity>;
  using Tag = std::conditional_t<ForCloning, tags::CloneFrom, tags::CloneToRemove>;

  if constexpr (ForCloning) {
    for (types::entity entity : registry.view<Tag, tags::CurrentActionMove>()) {
      visitEntity(entity);
    }
  }
}

template <typename VisitEntity = void*>
void traversePokemon(types::registry& registry, VisitEntity visitEntity = nullptr) {
  const static bool ForCloning = !std::is_same_v<void*, VisitEntity>;
  using Tag = std::conditional_t<ForCloning, tags::CloneFrom, tags::CloneToRemove>;

  for (const auto [entity, moveSlots] : registry.view<Tag, tags::Pokemon, MoveSlots>().each()) {
    for (auto move : moveSlots.val) {
      registry.emplace<Tag>(move);
    }

    if constexpr (ForCloning) {
      visitEntity(entity);
    }
  }

  for (const auto [entity, moves] : registry.view<Tag, CurrentActionMoves>().each()) {
    for (types::entity move : moves.val) {
      registry.emplace_or_replace<Tag>(move);
    }
  }
}

template <typename VisitEntity = void*>
void traverseMove(types::registry& registry, VisitEntity visitEntity = nullptr) {
  const static bool ForCloning = !std::is_same_v<void*, VisitEntity>;
  using Tag = std::conditional_t<ForCloning, tags::CloneFrom, tags::CloneToRemove>;

  if constexpr (ForCloning) {
    for (types::entity entity : registry.view<Tag, MoveName, Pp>()) {
      visitEntity(entity);
    }
  }
}

inline void cloneBattle(
  types::registry& registry, types::ClonedEntityMap& entityMap,
  entt::dense_map<entt::id_type, std::vector<types::entity>>& srcEntityStorages, types::cloneIndex cloneCount) {
  traverseBattle(registry, [&](types::entity entity) {
    cloneEntity(entity, registry, entityMap, srcEntityStorages, cloneCount);
  });
}
inline void cloneSide(
  types::registry& registry, types::ClonedEntityMap& entityMap,
  entt::dense_map<entt::id_type, std::vector<types::entity>>& srcEntityStorages, types::cloneIndex cloneCount) {
  traverseSide(registry, [&](types::entity entity) {
    cloneEntity(entity, registry, entityMap, srcEntityStorages, cloneCount);
  });
}
inline void cloneAction(
  types::registry& registry, types::ClonedEntityMap& entityMap,
  entt::dense_map<entt::id_type, std::vector<types::entity>>& srcEntityStorages, types::cloneIndex cloneCount) {
  traverseAction(registry, [&](types::entity entity) {
    cloneEntity(entity, registry, entityMap, srcEntityStorages, cloneCount);
  });
}
inline void cloneCurrentActionMove(
  types::registry& registry, types::ClonedEntityMap& entityMap,
  entt::dense_map<entt::id_type, std::vector<types::entity>>& srcEntityStorages, types::cloneIndex cloneCount) {
  traverseCurrentActionMove(registry, [&](types::entity entity) {
    cloneEntity(entity, registry, entityMap, srcEntityStorages, cloneCount);
  });
}
inline void clonePokemon(
  types::registry& registry, types::ClonedEntityMap& entityMap,
  entt::dense_map<entt::id_type, std::vector<types::entity>>& srcEntityStorages, types::cloneIndex cloneCount) {
  traversePokemon(registry, [&](types::entity entity) {
    cloneEntity(entity, registry, entityMap, srcEntityStorages, cloneCount);
  });
}
inline void cloneMove(
  types::registry& registry, types::ClonedEntityMap& entityMap,
  entt::dense_map<entt::id_type, std::vector<types::entity>>& srcEntityStorages, types::cloneIndex cloneCount) {
  traverseMove(registry, [&](types::entity entity) {
    cloneEntity(entity, registry, entityMap, srcEntityStorages, cloneCount);
  });
}

inline void deleteBattle(types::registry& registry) {
  traverseBattle(registry);
}
inline void deleteSide(types::registry& registry) {
  traverseSide(registry);
}
inline void deleteAction(types::registry& registry) {
  traverseAction(registry);
}
inline void deleteCurrentActionMove(types::registry& registry) {
  traverseCurrentActionMove(registry);
}
inline void deletePokemon(types::registry& registry) {
  traversePokemon(registry);
}
inline void deleteMove(types::registry& registry) {
  traverseMove(registry);
}

inline void remapEntity(types::entity& entity, const CloneTo& cloneTo, const types::ClonedEntityMap& entityMap) {
  POKESIM_ASSERT(entityMap.contains(entity), "Source node was not loaded into the map.");
  POKESIM_ASSERT(
    entityMap.at(entity).size() > cloneTo.val,
    "More entities are trying to be copied to than were copied.");
  entity = entityMap.at(entity)[cloneTo.val];
}

template <typename Component>
void remapEntityMembers(types::registry& registry, const types::ClonedEntityMap& entityMap) {
  for (auto [clonedEntity, cloneTo, component] : registry.view<CloneTo, Component>().each()) {
    remapEntity(component.val, cloneTo, entityMap);
  }
}

template <typename Component>
void remapEntityListMembers(types::registry& registry, const types::ClonedEntityMap& entityMap) {
  for (auto [clonedEntity, cloneTo, component] : registry.view<CloneTo, Component>().each()) {
    for (types::entity& entity : component.val) {
      remapEntity(entity, cloneTo, entityMap);
    }
  }
}

template <typename Component>
void remapComponentEntities(types::registry& registry, const types::ClonedEntityMap& entityMap) {
  if constexpr (std::is_same_v<decltype(Component::val), types::entity>) {
    remapEntityMembers<Component>(registry, entityMap);
  }
  else {
    remapEntityListMembers<Component>(registry, entityMap);
  }
}
}  // namespace internal

inline types::ClonedEntityMap clone(types::registry& registry, std::optional<types::cloneIndex> cloneCount) {
  types::cloneIndex count = cloneCount.value_or(1);
  types::ClonedEntityMap entityMap, battleMap;
  if (count == 0) {
    return entityMap;
  }

  entt::dense_map<entt::id_type, std::vector<types::entity>> srcEntityStorages;

  internal::cloneBattle(registry, entityMap, srcEntityStorages, count);
  battleMap = entityMap;
  internal::cloneSide(registry, entityMap, srcEntityStorages, count);
  internal::cloneAction(registry, entityMap, srcEntityStorages, count);
  internal::clonePokemon(registry, entityMap, srcEntityStorages, count);
  internal::cloneCurrentActionMove(registry, entityMap, srcEntityStorages, count);
  internal::cloneMove(registry, entityMap, srcEntityStorages, count);

  for (auto [id, storage] : registry.storage()) {
    if (srcEntityStorages.contains(id)) {
      const auto& sources = srcEntityStorages.at(id);
      storage.reserve(storage.size() + sources.size() * count);
      for (types::entity src : sources) {
        auto* value = storage.value(src);
        for (types::cloneIndex i = 0; i < count; i++) {
          storage.push(entityMap[src][i], value);
        }
      }
    }
  }

  auto& cloneToStorage = registry.storage<CloneTo>();
  cloneToStorage.reserve(entityMap.size() * count);

  for (const auto& [src, destinations] : entityMap) {
    cloneToStorage.insert(destinations.begin(), destinations.end());
  }

  for (const auto& [src, destinations] : entityMap) {
    for (types::cloneIndex i = 0; i < count; i++) {
      cloneToStorage.get(destinations[i]).val = i;
    }
  }

  // Not simplified further to a, for example, packed template type list, to make debugging what type went wrong easier
  internal::remapComponentEntities<ActionQueue>(registry, entityMap);
  internal::remapComponentEntities<Battle>(registry, entityMap);
  internal::remapComponentEntities<ChoiceLock>(registry, entityMap);
  internal::remapComponentEntities<CurrentAction>(registry, entityMap);
  internal::remapComponentEntities<CurrentActionMoves>(registry, entityMap);
  internal::remapComponentEntities<CurrentActionMoveSlot>(registry, entityMap);
  internal::remapComponentEntities<CurrentActionSource>(registry, entityMap);
  internal::remapComponentEntities<CurrentActionTargets>(registry, entityMap);
  internal::remapComponentEntities<FoeSide>(registry, entityMap);
  internal::remapComponentEntities<LastUsedMove>(registry, entityMap);
  internal::remapComponentEntities<MoveEffect>(registry, entityMap);
  internal::remapComponentEntities<MoveSlots>(registry, entityMap);
  internal::remapComponentEntities<NextAction>(registry, entityMap);
  internal::remapComponentEntities<Pokemon>(registry, entityMap);
  internal::remapComponentEntities<Side>(registry, entityMap);
  internal::remapComponentEntities<Sides>(registry, entityMap);
  internal::remapComponentEntities<Team>(registry, entityMap);

  registry.clear<CloneTo, tags::CloneFrom>();

  for (const auto& [originalBattle, clonedBattles] : battleMap) {
    registry.remove<ParentBattle>(clonedBattles.begin(), clonedBattles.end());
    registry.insert<ParentBattle>(clonedBattles.begin(), clonedBattles.end(), {originalBattle});
  }

#ifdef POKESIM_DEBUG_CHECK_UTILITIES
  for (const auto& [src, destinations] : entityMap) {
    registry.remove<ParentEntity>(destinations.begin(), destinations.end());
    registry.insert<ParentEntity>(destinations.begin(), destinations.end(), {src});
  }
#endif

  return entityMap;
}

inline void deleteClones(types::registry& registry) {
  internal::deleteBattle(registry);
  internal::deleteSide(registry);
  internal::deleteAction(registry);
  internal::deletePokemon(registry);
  internal::deleteCurrentActionMove(registry);
  internal::deleteMove(registry);
  auto remove = registry.view<tags::CloneToRemove>();
  registry.destroy(remove.begin(), remove.end());
}
}  // namespace pokesim

////////////////////// END OF src/Battle/Clone/Clone.cpp ///////////////////////

///////// START OF src/AnalyzeEffect/Setup/AnalyzeEffectInputSetup.cpp /////////

namespace pokesim::analyze_effect {
InputSetup::InputSetup(types::registry& registry, types::entity entity) : handle(registry, entity) {
  handle.emplace<tags::Input>();
}

inline void InputSetup::setAttacker(types::entity entity) {
  handle.emplace<Attacker>(entity);
  handle.registry()->emplace_or_replace<tags::Attacker>(entity);
}

inline void InputSetup::setEffectTarget(types::entity entity) {
  handle.emplace<EffectTarget>(entity);
}

inline void InputSetup::setDefender(types::entity entity) {
  POKESIM_ASSERT(
    !handle.try_get<Defenders>(),
    "Calc damage only supports one defender per move. Make a new move instead.");
  handle.emplace<Defenders>().val.push_back(entity);
  handle.registry()->emplace_or_replace<tags::Defender>(entity);
}

inline void InputSetup::setEffectMoves(const std::vector<dex::Move>& moves) {
  handle.get_or_emplace<EffectMoves>().val = moves;
}

inline void InputSetup::setEffect(types::effectEnum effect) {
  if (effect.holds<dex::PseudoWeather>()) {
    handle.emplace<PseudoWeatherName>(effect.get<dex::PseudoWeather>());
  }
  else if (effect.holds<dex::SideCondition>()) {
    handle.emplace<SideConditionName>(effect.get<dex::SideCondition>());
  }
  else if (effect.holds<dex::Status>()) {
    handle.emplace<StatusName>(effect.get<dex::Status>());
  }
  else if (effect.holds<dex::Terrain>()) {
    handle.emplace<TerrainName>(effect.get<dex::Terrain>());
  }
  else if (effect.holds<dex::Volatile>()) {
    handle.emplace<VolatileName>(effect.get<dex::Volatile>());
  }
  else if (effect.holds<dex::Weather>()) {
    handle.emplace<WeatherName>(effect.get<dex::Weather>());
  }
  else {
    POKESIM_ASSERT_FAIL("Effect does not contain a valid enum.");
  }
}

inline void InputSetup::setBoostEffect(dex::Stat stat, types::boost boost) {
  switch (stat) {
    case dex::Stat::ATK: {
      handle.emplace<AtkBoost>(boost);
      break;
    }
    case dex::Stat::DEF: {
      handle.emplace<DefBoost>(boost);
      break;
    }
    case dex::Stat::SPA: {
      handle.emplace<SpaBoost>(boost);
      break;
    }
    case dex::Stat::SPD: {
      handle.emplace<SpdBoost>(boost);
      break;
    }
    case dex::Stat::SPE: {
      handle.emplace<SpeBoost>(boost);
      break;
    }
    default: {
      POKESIM_ASSERT_FAIL("Using a stat enum that doesn't have boost.");
    }
  }
}

inline void InputSetup::setBattle(types::entity entity) {
  handle.emplace<Battle>(entity);
  handle.registry()->get_or_emplace<Inputs>(entity).val.push_back(handle.entity());
}
}  // namespace pokesim::analyze_effect

////////// END OF src/AnalyzeEffect/Setup/AnalyzeEffectInputSetup.cpp //////////

/////////// START OF src/AnalyzeEffect/AnalyzeEffectDebugChecks.hpp ////////////

#ifndef NDEBUG

namespace pokesim::analyze_effect::debug {
struct Checks : pokesim::debug::Checks {
  Checks(const Simulation& _simulation) : pokesim::debug::Checks(_simulation) {}

  void checkInputs() {
    for (types::entity input : registry.view<tags::Input>()) {
      originalToCopy[input] = pokesim::debug::createEntityCopy(input, registry, registryOnInput);
    }

    const std::vector<types::entity> attackers = getPokemonList(true);
    const std::vector<types::entity> defenders = getPokemonList(false);

    for (const std::vector<types::entity>& pokemonList : {attackers, defenders}) {
      for (types::entity pokemon : pokemonList) {
        originalToCopy[pokemon] = pokesim::debug::createEntityCopy(pokemon, registry, registryOnInput);
      }
    }

    copyRemainingEntities();
  }

  void checkOutputs() const {
    std::size_t finalEntityCount = getFinalEntityCount();
    POKESIM_ASSERT_NM(initialEntityCount == finalEntityCount);
    checkInputOutputs();
    checkPokemonOutputs(true);
    checkPokemonOutputs(false);
    checkRemainingOutputs();
  }

 private:
  std::vector<types::entity> getPokemonList(bool forAttacker) const {
    if (forAttacker) {
      auto view = registry.view<tags::Attacker>();
      return {view.begin(), view.end()};
    }

    auto view = registry.view<tags::Defender>();
    return {view.begin(), view.end()};
  }

  DamageRollKind getDamageRollKind(types::entity input, DamageRollOptions damageRollOptions) const {
    const Defenders& defenders = registry.get<Defenders>(input);
    const Side& side = registry.get<Side>(defenders.only());
    PlayerSideId playerSide = registry.get<PlayerSide>(side.val).val;
    switch (playerSide) {
      case PlayerSideId::P1: {
        return damageRollOptions.p1;
        break;
      }
      case PlayerSideId::P2: {
        return damageRollOptions.p2;
        break;
      }
      default: break;
    }

    POKESIM_ASSERT_FAIL("Player side wasn't set properly.");
    return DamageRollKind::NONE;
  }

  void checkInputOutputs() const {
    for (types::entity input : registry.view<tags::Input>()) {
      pokesim::debug::TypesToIgnore typesToIgnore{};
      typesToIgnore.add<MultipliedDamageRolls>();

      POKESIM_ASSERT_NM(registry.all_of<MultipliedDamageRolls>(input));

      if (registry.all_of<tags::InfiniteMultiplier>(input)) {
        POKESIM_ASSERT_NM(!registry.all_of<EffectMultiplier>(input));
        typesToIgnore.add<tags::InfiniteMultiplier>();
      }

      bool zeroEffectMultiplier = false;
      if (registry.all_of<EffectMultiplier>(input)) {
        POKESIM_ASSERT_NM(!registry.all_of<tags::InfiniteMultiplier>(input));
        typesToIgnore.add<EffectMultiplier>();

        const auto [effectMultiplier, multipliedDamageRolls] =
          registry.get<EffectMultiplier, MultipliedDamageRolls>(input);
        if (effectMultiplier.val == 0) {
          zeroEffectMultiplier = true;
          for (const Damage& multipliedDamageRoll : multipliedDamageRolls.val) {
            POKESIM_ASSERT_NM(multipliedDamageRoll.val == 0);
          }
        }
      }

      auto damageRollOptions = simulation.analyzeEffectOptions.damageRollOptions;
      auto noKoChanceCalculation = simulation.analyzeEffectOptions.noKoChanceCalculation;
      if (noKoChanceCalculation || zeroEffectMultiplier) {
        POKESIM_ASSERT_NM(!registry.all_of<MultipliedUsesUntilKo>(input));
      }
      else if (calc_damage::damageKindsMatch(
                 DamageRollKind::ALL_DAMAGE_ROLLS,
                 getDamageRollKind(input, damageRollOptions))) {
        POKESIM_ASSERT_NM(registry.all_of<MultipliedUsesUntilKo>(input));
        typesToIgnore.add<MultipliedUsesUntilKo>();
      }

      pokesim::debug::areEntitiesEqual(registry, input, registryOnInput, originalToCopy.at(input), typesToIgnore);
    }
  }

  void checkPokemonOutputs(bool forAttacker) const {
    const std::vector<types::entity> pokemonList = getPokemonList(forAttacker);
    for (types::entity pokemon : pokemonList) {
      pokesim::debug::areEntitiesEqual(registry, pokemon, registryOnInput, originalToCopy.at(pokemon));
    }
  }
};
}  // namespace pokesim::analyze_effect::debug
#else
namespace pokesim {
class Simulation;
namespace analyze_effect::debug {
struct Checks {
  Checks(const Simulation&) {}
  void checkInputs() const {}
  void checkOutputs() const {}
};
}  // namespace analyze_effect::debug
}  // namespace pokesim
#endif

//////////// END OF src/AnalyzeEffect/AnalyzeEffectDebugChecks.hpp /////////////

/////////// START OF src/Components/AnalyzeEffect/RemovedEffect.hpp ////////////

namespace pokesim::analyze_effect {
struct RemovedEffect {
  types::effectEnum val{};
};
}  // namespace pokesim::analyze_effect

//////////// END OF src/Components/AnalyzeEffect/RemovedEffect.hpp /////////////

///////////////// START OF src/AnalyzeEffect/AnalyzeEffect.cpp /////////////////

#include <cstdint>
#include <vector>


namespace pokesim::analyze_effect {
namespace internal {
enum class EffectPresentCheck {
  NOT_PRESENT,
  PRESENT_AND_NOT_APPLIED,
  PRESENT_AND_APPLIED,
};

inline void restoreInputs(
  types::registry& registry, const MovePairs& movePairs, const OriginalInputEntities& originalEntities, Battle& battle,
  Attacker& attacker, Defenders& defenders, EffectTarget& effectTarget) {
  for (types::entity pokemon : {attacker.val, defenders.only(), originalEntities.attacker, originalEntities.defender}) {
    CurrentActionMoves* moves = registry.try_get<CurrentActionMoves>(pokemon);

    if (moves == nullptr) {
      continue;
    }

    auto end = moves->val.end();
    for (const auto& movePair : movePairs.val) {
      end = std::remove_if(moves->val.begin(), end, [&movePair](types::entity entity) {
        return entity == movePair.first || entity == movePair.second;
      });
    }

    moves->val.resize(end - moves->val.begin());
    if (moves->val.empty()) {
      registry.remove<CurrentActionMoves>(pokemon);
    }
  }

  for (auto [parentBattleMove, childBattleMove] : movePairs.val) {
    registry.destroy(parentBattleMove);
    if (parentBattleMove != childBattleMove) {
      registry.destroy(childBattleMove);
    }
  }

  battle.val = originalEntities.battle;
  attacker.val = originalEntities.attacker;
  defenders.val[0] = originalEntities.defender;
  effectTarget.val = originalEntities.effectTarget;
}

inline void assignInputsToClones(
  Simulation& simulation, types::eventPossibilities cloneCount, types::entity originalBattleEntity,
  const types::ClonedEntityMap& clonedEntityMap) {
  types::registry& registry = simulation.registry;
  const Inputs& inputs = registry.get<Inputs>(originalBattleEntity);

  POKESIM_ASSERT(
    (cloneCount == 0) == clonedEntityMap.empty(),
    "There should be no cloned entities if no clones are needed.");

  const auto& battleClones = cloneCount == 0 ? std::vector<types::entity>{} : clonedEntityMap.at(originalBattleEntity);

  POKESIM_ASSERT(
    cloneCount == battleClones.size(),
    "Each input must have a clone and no more clones than inputs should be made.");

  std::size_t cloneIndex = 0;
  for (types::entity input : inputs.val) {
    bool usesClone = !registry.all_of<tags::RunOneCalculation>(input);

    auto [battle, attacker, defenders, effectTarget, moves] =
      registry.get<Battle, Attacker, Defenders, EffectTarget, EffectMoves>(input);

    MovePairs& movePairs = registry.emplace<MovePairs>(input);
    movePairs.val.resize(moves.val.size());

    auto createMove =
      [&](dex::Move move, types::entity battleEntity, types::entity attackerEntity, types::entity defenderEntity) {
        types::entity moveEntity = createActionMoveForTarget(
          {simulation.registry, defenderEntity},
          battleEntity,
          attackerEntity,
          move,
          simulation.pokedex);
        registry.emplace<MoveName>(moveEntity, move);
        registry.emplace<pokesim::tags::AnalyzeEffect>(moveEntity);

        return moveEntity;
      };

    for (std::size_t moveIndex = 0; moveIndex < moves.val.size(); moveIndex++) {
      entt::entity moveEntity = createMove(moves.val[moveIndex], battle.val, attacker.val, defenders.only());
      movePairs.val[moveIndex].first = movePairs.val[moveIndex].second = moveEntity;
    }

    registry.emplace<OriginalInputEntities>(
      input,
      OriginalInputEntities{battle.val, attacker.val, defenders.only(), effectTarget.val});

    if (usesClone) {
      POKESIM_ASSERT(battleClones.size() > cloneIndex, "More inputs want clones than clones made.");

      registry.emplace<tags::BattleCloneForCalculation>(battleClones[cloneIndex]);

      const auto& clonedAttackers = clonedEntityMap.at(attacker.val);
      POKESIM_ASSERT(
        battleClones.size() == clonedAttackers.size(),
        "Each attacker must have a clone and no more clones than inputs should be made.");

      const auto& clonedDefenders = clonedEntityMap.at(defenders.only());
      POKESIM_ASSERT(
        battleClones.size() == clonedDefenders.size(),
        "Each defender must have a clone and no more clones than inputs should be made.");

      const auto& clonedEffectTarget = clonedEntityMap.at(effectTarget.val);
      POKESIM_ASSERT(
        battleClones.size() == clonedEffectTarget.size(),
        "Each effect target must have a clone and no more clones than inputs should be made.");

      for (std::size_t moveIndex = 0; moveIndex < moves.val.size(); moveIndex++) {
        movePairs.val[moveIndex].second = createMove(
          moves.val[moveIndex],
          battleClones[cloneIndex],
          clonedAttackers[cloneIndex],
          clonedDefenders[cloneIndex]);
      }

      battle.val = battleClones[cloneIndex];
      attacker.val = clonedAttackers[cloneIndex];
      defenders.val[0] = clonedDefenders[cloneIndex];
      effectTarget.val = clonedEffectTarget[cloneIndex];

      cloneIndex++;
    }
  }
}

inline EffectPresentCheck hasStatusEffect(types::registry& registry, EffectTarget effectTarget, StatusName status) {
  StatusName* currentStatus = registry.try_get<StatusName>(effectTarget.val);
  if (!currentStatus) {
    return EffectPresentCheck::NOT_PRESENT;
  }

  if (currentStatus->name == status.name) {
    return EffectPresentCheck::PRESENT_AND_APPLIED;
  }

  return EffectPresentCheck::PRESENT_AND_NOT_APPLIED;
}

template <typename BoostType>
EffectPresentCheck hasBoostEffect(types::registry& registry, EffectTarget effectTarget, BoostType boost) {
  BoostType* currentBoost = registry.try_get<BoostType>(effectTarget.val);
  if (!currentBoost) {
    return EffectPresentCheck::NOT_PRESENT;
  }

  if (currentBoost->val == boost.val) {
    return EffectPresentCheck::PRESENT_AND_APPLIED;
  }

  return EffectPresentCheck::PRESENT_AND_NOT_APPLIED;
}

inline void setRunOneCalculation(types::handle inputHandle, Battle battle) {
  inputHandle.emplace<tags::RunOneCalculation>();
  inputHandle.registry()->get_or_emplace<RunsOneCalculationCount>(battle.val).val++;
}

inline void ignoreWithPseudoWeatherEffect(types::handle /*inputHandle*/, Battle /*battle*/, PseudoWeatherName /*effect*/) {}

inline void ignoreWithTerrainEffect(types::handle /*inputHandle*/, Battle /*battle*/, TerrainName /*effect*/) {}

inline void ignoreWithWeatherEffect(types::handle /*inputHandle*/, Battle /*battle*/, WeatherName /*effect*/) {}

inline void ignoreWithSideConditionEffect(
  types::handle /*inputHandle*/, EffectTarget /*effectTarget*/, SideConditionName /*effect*/) {}

inline void ignoreWithStatusEffect(types::handle inputHandle, Battle battle, EffectTarget effectTarget, StatusName effect) {
  types::registry& registry = *inputHandle.registry();

  EffectPresentCheck statusCheck = hasStatusEffect(registry, effectTarget, effect);
  if (statusCheck == EffectPresentCheck::PRESENT_AND_APPLIED) {
    setRunOneCalculation(inputHandle, battle);
  }
}

inline void ignoreWithVolatileEffect(types::handle /*inputHandle*/, EffectTarget /*effectTarget*/, VolatileName /*effect*/) {}

template <typename BoostType>
void ignoreWithBoostEffect(types::handle inputHandle, Battle battle, EffectTarget effectTarget, BoostType effect) {
  types::registry& registry = *inputHandle.registry();

  EffectPresentCheck boostCheck = hasBoostEffect(registry, effectTarget, effect);
  if (boostCheck == EffectPresentCheck::PRESENT_AND_APPLIED) {
    setRunOneCalculation(inputHandle, battle);
  }
}

inline void ignoreBattlesWithEffectActive(Simulation& simulation) {
  simulation.view<ignoreWithPseudoWeatherEffect, Tags<tags::Input>>();
  simulation.view<ignoreWithTerrainEffect, Tags<tags::Input>>();
  simulation.view<ignoreWithWeatherEffect, Tags<tags::Input>>();
  simulation.view<ignoreWithSideConditionEffect, Tags<tags::Input>>();
  simulation.view<ignoreWithStatusEffect, Tags<tags::Input>>();
  simulation.view<ignoreWithVolatileEffect, Tags<tags::Input>>();

  simulation.view<ignoreWithBoostEffect<AtkBoost>, Tags<tags::Input>>();
  simulation.view<ignoreWithBoostEffect<DefBoost>, Tags<tags::Input>>();
  simulation.view<ignoreWithBoostEffect<SpaBoost>, Tags<tags::Input>>();
  simulation.view<ignoreWithBoostEffect<SpdBoost>, Tags<tags::Input>>();
  simulation.view<ignoreWithBoostEffect<SpeBoost>, Tags<tags::Input>>();
}

inline void createAppliedEffectBattles(Simulation& simulation) {
  entt::dense_map<types::eventPossibilities, std::vector<types::entity>> battlesByCloneCount{};

  if (simulation.analyzeEffectOptions.reconsiderActiveEffects) {
    simulation.registry.view<Inputs>().each([&](types::entity battleEntity, const Inputs& inputs) {
      POKESIM_ASSERT(!inputs.val.empty(), "Battles with input components should have input entities.");
      battlesByCloneCount[inputs.val.size()].push_back(battleEntity);
    });
  }
  else {
    simulation.registry.view<Inputs>().each([&](types::entity battleEntity, const Inputs& inputs) {
      POKESIM_ASSERT(!inputs.val.empty(), "Battles with input components should have input entities.");
      const RunsOneCalculationCount* ignoredInputCount =
        simulation.registry.try_get<RunsOneCalculationCount>(battleEntity);
      types::eventPossibilities ignoredCount = ignoredInputCount == nullptr ? 0U : ignoredInputCount->val;

      POKESIM_ASSERT(inputs.val.size() >= ignoredCount, "Must have more inputs than inputs ignored.");
      battlesByCloneCount[inputs.val.size() - ignoredCount].push_back(battleEntity);
    });
  }

  types::ClonedEntityMap clonedBattleMap;
  for (const auto& [cloneCount, battleEntities] : battlesByCloneCount) {
    if (cloneCount) {
      simulation.registry.insert<pokesim::tags::CloneFrom>(battleEntities.begin(), battleEntities.end());
    }

    auto clonedEntityMap = clone(simulation.registry, cloneCount);

    for (types::entity battleEntity : battleEntities) {
      assignInputsToClones(simulation, cloneCount, battleEntity, clonedEntityMap);
    }
  }
}

inline void applyPseudoWeatherEffect(types::handle /*inputHandle*/, Battle /*battle*/, PseudoWeatherName /*effect*/) {}

inline void applyTerrainEffect(types::handle /*inputHandle*/, Battle /*battle*/, TerrainName /*effect*/) {}

inline void applyWeatherEffect(types::handle /*inputHandle*/, Battle /*battle*/, WeatherName /*effect*/) {}

inline void applySideConditionEffect(
  types::handle /*inputHandle*/, EffectTarget /*effectTarget*/, SideConditionName /*effect*/) {}

inline void applyStatusEffect(types::handle inputHandle, EffectTarget effectTarget, StatusName effect) {
  types::registry& registry = *inputHandle.registry();

  EffectPresentCheck statusCheck = hasStatusEffect(registry, effectTarget, effect);
  if (statusCheck == EffectPresentCheck::PRESENT_AND_APPLIED) {
    clearStatus({registry, effectTarget.val});
    inputHandle.emplace<tags::InvertFinalAnswer>();
  }
  else {
    setStatus({registry, effectTarget.val}, effect.name);
  }
}

inline void applyVolatileEffect(types::handle /*inputHandle*/, EffectTarget /*effectTarget*/, VolatileName /*effect*/) {}

template <typename BoostType>
void applyBoostEffect(types::handle inputHandle, EffectTarget effectTarget, BoostType effect) {
  types::registry& registry = *inputHandle.registry();

  EffectPresentCheck boostCheck = hasBoostEffect(registry, effectTarget, effect);
  if (boostCheck == EffectPresentCheck::PRESENT_AND_APPLIED) {
    registry.remove<BoostType>(effectTarget.val);
    inputHandle.emplace<tags::InvertFinalAnswer>();
  }
  else {
    registry.emplace_or_replace<BoostType>(effectTarget.val, effect);
  }
}

inline void createOutput(types::handle inputHandle, const MovePairs& movePairs) {
  bool invert = inputHandle.all_of<tags::InvertFinalAnswer>();
  types::registry& registry = *inputHandle.registry();

  for (auto [parentBattleMove, childBattleMove] : movePairs.val) {
    const auto [childDamage, childDamageRolls] = registry.get<Damage, DamageRolls>(childBattleMove);
    auto [parentDamage, parentDamageRolls] = registry.get<Damage, DamageRolls>(parentBattleMove);

    if (invert) {
      if (childDamage.val == 0) {
        inputHandle.emplace<tags::InfiniteMultiplier>();
      }
      else {
        inputHandle.emplace<EffectMultiplier>((types::effectMultiplier)parentDamage.val / childDamage.val);
      }

      inputHandle.emplace<MultipliedDamageRolls>(parentDamageRolls);
      auto* const parentKoChances = registry.try_get<calc_damage::UsesUntilKo>(parentBattleMove);
      if (parentKoChances != nullptr) {
        inputHandle.emplace<MultipliedUsesUntilKo>(*parentKoChances);
      }
    }
    else {
      if (parentDamage.val == 0) {
        inputHandle.emplace<tags::InfiniteMultiplier>();
      }
      else {
        inputHandle.emplace<EffectMultiplier>((types::effectMultiplier)childDamage.val / parentDamage.val);
      }

      inputHandle.emplace<MultipliedDamageRolls>(childDamageRolls);
      auto* const childKoChances = registry.try_get<calc_damage::UsesUntilKo>(childBattleMove);
      if (childKoChances != nullptr) {
        inputHandle.emplace<MultipliedUsesUntilKo>(*childKoChances);
      }
    }
  }
}

inline void clearRunVariables(Simulation& simulation) {
  simulation.view<restoreInputs>();
  simulation.addToEntities<pokesim::tags::CloneToRemove, tags::BattleCloneForCalculation>();
  deleteClones(simulation.registry);

  simulation.registry.clear<
    MovePairs,
    OriginalInputEntities,
    tags::RunOneCalculation,
    tags::InvertFinalAnswer,
    RunsOneCalculationCount,
    Damage>();
}

inline void run(Simulation& simulation) {
  pokesim::internal::SelectForPokemonView<pokesim::tags::AnalyzeEffect> selectedPokemon(simulation);
  pokesim::internal::SelectForBattleView<pokesim::tags::AnalyzeEffect> selectedBattle(simulation);

  if (selectedPokemon.hasNoneSelected() || selectedBattle.hasNoneSelected()) {
    return;
  }

  if (!simulation.analyzeEffectOptions.reconsiderActiveEffects) {
    internal::ignoreBattlesWithEffectActive(simulation);
  }

  internal::createAppliedEffectBattles(simulation);

  simulation.view<internal::applyPseudoWeatherEffect, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applyTerrainEffect, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applyWeatherEffect, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applySideConditionEffect, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applyStatusEffect, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applyVolatileEffect, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();

  simulation.view<internal::applyBoostEffect<AtkBoost>, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applyBoostEffect<DefBoost>, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applyBoostEffect<SpaBoost>, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applyBoostEffect<SpdBoost>, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();
  simulation.view<internal::applyBoostEffect<SpeBoost>, Tags<tags::Input>, entt::exclude_t<tags::RunOneCalculation>>();

  calc_damage::run(simulation);

  simulation.view<internal::createOutput, Tags<tags::Input>>();
}
}  // namespace internal

inline void run(Simulation& simulation) {
  debug::Checks debugChecks(simulation);
  debugChecks.checkInputs();

  internal::run(simulation);

  internal::clearRunVariables(simulation);
  debugChecks.checkOutputs();
}
}  // namespace pokesim::analyze_effect

////////////////// END OF src/AnalyzeEffect/AnalyzeEffect.cpp //////////////////

////////////////// START OF src/Components/Tags/TypeTags.hpp ///////////////////

// TODO(aed3): Make this auto generated

namespace pokesim::type::tags {
struct Normal {};
struct Fighting {};
struct Flying {};
struct Poison {};
struct Ground {};
struct Rock {};
struct Bug {};
struct Ghost {};
struct Steel {};
struct Fire {};
struct Water {};
struct Grass {};
struct Electric {};
struct Psychic {};
struct Ice {};
struct Dragon {};
struct Dark {};
struct Fairy {};
}  // namespace pokesim::type::tags

/////////////////// END OF src/Components/Tags/TypeTags.hpp ////////////////////

//////////////////////// START OF src/Pokedex/Names.hpp ////////////////////////

#include <string>

// TODO(aed3): Change the move names to be part of the build functions so they aren't all loaded all the time

namespace pokesim::dex {
// Returns the name of a species represented by its enum as a string.
inline std::string toString(Species speciesEnum);

// Returns the name of a move represented by its enum as a string.
inline std::string toString(Move moveEnum);

// Returns the name of an ability represented by its enum as a string.
inline std::string toString(Ability abilityEnum);

// Returns the name of an item represented by its enum as a string.
inline std::string toString(Item itemEnum);

// Returns the name of a nature represented by its enum as a string.
inline std::string toString(Nature natureEnum);

// Returns the name of a status condition represented by its enum as a string.
inline std::string toString(Status statusEnum);

// Returns the name of a gender represented by its enum as a string.
inline std::string toString(Gender genderEnum);

// Returns the name of a type represented by its enum as a string.
inline std::string toString(Type typeEnum);

// Returns the name of a stat represented by its enum as a string.
inline std::string toString(Stat statEnum);

// Returns the Smogon name of a species represented by its enum as a string.
inline std::string toSmogonString(Species speciesEnum);

// Returns the Smogon name of a move represented by its enum as a string.
inline std::string toSmogonString(Move moveEnum);

// Returns the Smogon name of an ability represented by its enum as a string.
inline std::string toSmogonString(Ability abilityEnum);

// Returns the Smogon name of an item represented by its enum as a string.
inline std::string toSmogonString(Item itemEnum);

// Returns the Smogon ID of a species represented by its enum as a string.
inline std::string toSmogonIdString(Species speciesEnum);

// Returns the Smogon ID of a move represented by its enum as a string.
inline std::string toSmogonIdString(Move moveEnum);

// Returns the Smogon ID of an ability represented by its enum as a string.
inline std::string toSmogonIdString(Ability abilityEnum);

// Returns the Smogon ID of an item represented by its enum as a string.
inline std::string toSmogonIdString(Item itemEnum);

/**
 * @brief Returns the enum of the species name string.
 * Returns `MISSING_NO` if the string does not represent a species.
 */
inline Species fromNameToSpeciesEnum(const std::string& name);

/**
 * @brief Returns the enum of the move name string.
 * Returns `NO_MOVE` if the string does not represent a move.
 */
inline Move fromNameToMoveEnum(const std::string& name);

/**
 * @brief Returns the enum of the ability name string.
 * Returns `NO_ABILITY` if the string does not represent an ability.
 */
inline Ability fromNameToAbilityEnum(const std::string& name);

/**
 * @brief Returns the enum of the item name string.
 * Returns `NO_ITEM` if the string does not represent an item.
 */
inline Item fromNameToItemEnum(const std::string& name);

/**
 * @brief Returns the enum of the nature name string.
 * Returns `NO_NATURE` if the string does not represent a nature.
 */
inline Nature fromNameToNatureEnum(const std::string& name);

/**
 * @brief Returns the enum of the status condition name string.
 * Returns `NO_STATUS` if the string does not represent a status condition.
 */
inline Status fromNameToStatusEnum(const std::string& name);

/**
 * @brief Returns the enum of the gender name string.
 * Returns `NO_GENDER` if the string does not represent a gender.
 */
inline Gender fromNameToGenderEnum(const std::string& name);

/**
 * @brief Returns the enum of the type name string.
 * Returns `NO_TYPE` if the string does not represent a type.
 */
inline Type fromNameToTypeEnum(const std::string& name);

/**
 * @brief Returns `NO_STAT` if the string does not represent a stat.
 */
inline Stat fromNameToStatEnum(const std::string& name);

/**
 * @brief Returns the enum of the species Smogon name string.
 * Returns `MISSING_NO` if the string does not represent a species.
 */
inline Species fromSmogonNameToSpeciesEnum(const std::string& name);

/**
 * @brief Returns the enum of the move Smogon name string.
 * Returns `NO_MOVE` if the string does not represent a move.
 */
inline Move fromSmogonNameToMoveEnum(const std::string& name);

/**
 * @brief Returns the enum of the ability Smogon name string.
 * Returns `NO_ABILITY` if the string does not represent an ability.
 */
inline Ability fromSmogonNameToAbilityEnum(const std::string& name);

/**
 * @brief Returns the enum of the item Smogon name string.
 * Returns `NO_ITEM` if the string does not represent an item.
 */
inline Item fromSmogonNameToItemEnum(const std::string& name);

/**
 * @brief Returns the enum of the species Smogon ID string.
 * Returns `MISSING_NO` if the string does not represent a species.
 */
inline Species fromSmogonIDToSpeciesEnum(const std::string& name);

/**
 * @brief Returns the enum of the move Smogon ID string.
 * Returns `NO_MOVE` if the string does not represent a move.
 */
inline Move fromSmogonIDToMoveEnum(const std::string& name);

/**
 * @brief Returns the enum of the ability Smogon ID string.
 * Returns `NO_ABILITY` if the string does not represent an ability.
 */
inline Ability fromSmogonIDToAbilityEnum(const std::string& name);

/**
 * @brief Returns the enum of the item Smogon ID string.
 * Returns `NO_ITEM` if the string does not represent an item.
 */
inline Item fromSmogonIDToItemEnum(const std::string& name);

// Converts a string to only have lowercase alphanumeric characters
inline std::string toID(const std::string& name);
}  // namespace pokesim::dex

///////////////////////// END OF src/Pokedex/Names.hpp /////////////////////////

///////////////// START OF src/Utilities/LambdaToDelegate.hpp //////////////////

namespace pokesim::internal {
struct LambdaToDelegate {
  template <typename Lambda>
  static auto create(Lambda lambda) {
    return DelegateHolder<Lambda>(lambda);
  }

 private:
  template <typename...>
  struct DelegateHolder;

  template <typename ReturnType, typename... LambdaArgs>
  struct DelegateHolder<ReturnType (*)(LambdaArgs...)> {
   private:
    struct LambdaHolder {
      ReturnType (*fn)(LambdaArgs...) = nullptr;
    } lambdaHolder;

    static ReturnType lambdaRunner(const void* ptr, LambdaArgs... args) {
      return static_cast<const LambdaHolder*>(ptr)->fn(args...);
    }

   public:
    entt::delegate<ReturnType(LambdaArgs...)> delegate;
    DelegateHolder(ReturnType (*lambda)(LambdaArgs...))
        : lambdaHolder{lambda}, delegate{&DelegateHolder::lambdaRunner, &lambdaHolder} {}
  };
};
}  // namespace pokesim::internal

////////////////// END OF src/Utilities/LambdaToDelegate.hpp ///////////////////

/////////////////////////// START OF src/PokeSim.hpp ///////////////////////////


//////////////////////////// END OF src/PokeSim.hpp ////////////////////////////